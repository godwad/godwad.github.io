<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><div id="myscoll"></div><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>算法合集 | 不学无墅</title><meta name="keywords" content="算法"><meta name="author" content="小s今天吃什么"><meta name="copyright" content="小s今天吃什么"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="🥧内含多达70种算法，后续会补充案例">
<meta property="og:type" content="article">
<meta property="og:title" content="算法合集">
<meta property="og:url" content="https://godwad.github.io/posts/54150.html">
<meta property="og:site_name" content="不学无墅">
<meta property="og:description" content="🥧内含多达70种算法，后续会补充案例">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://w.wallhaven.cc/full/x6/wallhaven-x6jvdl.jpg">
<meta property="article:published_time" content="2023-03-23T07:19:58.000Z">
<meta property="article:modified_time" content="2023-11-11T09:11:28.744Z">
<meta property="article:author" content="小s今天吃什么">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://w.wallhaven.cc/full/x6/wallhaven-x6jvdl.jpg"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://godwad.github.io/posts/54150"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/font-awesome/6.0.0/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.staticfile.org/fancyapps-ui/4.0.31/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.js',
      css: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '算法合集',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-11-11 17:11:28'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://cdn1.tianli0.top/npm/element-ui@2.15.6/packages/theme-chalk/lib/index.css"><style id="themeColor"></style><style id="rightSide"></style><style id="transPercent"></style><style id="blurNum"></style><style id="settingStyle"></style><span id="fps"></span><style id="defineBg"></style><style id="menu_shadow"></style><svg aria-hidden="true" style="position:absolute; overflow:hidden; width:0; height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="不学无墅" type="application/atom+xml">
</head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img9999.wchunge.cn/i/2022/11/30/xgm0a3.jpg" onerror="onerror=null;src='/assets/r1.jpg'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">53</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">26</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">29</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-home"></use></svg><span class="menu_word" style="font-size:17px"> 首页</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--article"></use></svg><span class="menu_word" style="font-size:17px"> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-guidang1">                   </use></svg><span class="menu_word" style="font-size:17px"> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-sekuaibiaoqian">                   </use></svg><span class="menu_word" style="font-size:17px"> 标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-fenlei">                   </use></svg><span class="menu_word" style="font-size:17px"> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pinweishenghuo"></use></svg><span class="menu_word" style="font-size:17px"> 休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/life/music/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-yinle">                   </use></svg><span class="menu_word" style="font-size:17px"> 八音盒</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/movies/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-dianying1">                   </use></svg><span class="menu_word" style="font-size:17px"> 影院</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/games/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-youxishoubing">                   </use></svg><span class="menu_word" style="font-size:17px"> 游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xiangzi"></use></svg><span class="menu_word" style="font-size:17px"> 八宝箱</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/box/gallery/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-tubiaozhizuomoban">                   </use></svg><span class="menu_word" style="font-size:17px"> 画廊</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/animation/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-nvwumao">                   </use></svg><span class="menu_word" style="font-size:17px"> 动画</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/nav/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-zhifengche">                   </use></svg><span class="menu_word" style="font-size:17px"> 网址导航</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shejiaoxinxi"></use></svg><span class="menu_word" style="font-size:17px"> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/social/fcircle/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pengyouquan">                   </use></svg><span class="menu_word" style="font-size:17px"> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-liuyan">                   </use></svg><span class="menu_word" style="font-size:17px"> 留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/social/link/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-lianjie">                   </use></svg><span class="menu_word" style="font-size:17px"> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-wangye"></use></svg><span class="menu_word" style="font-size:17px"> 网站</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/site/census/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--tongjibiao">                   </use></svg><span class="menu_word" style="font-size:17px"> 网站统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/echarts/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shujutongji1">                   </use></svg><span class="menu_word" style="font-size:17px"> 文章统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/time/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xianxingshalou">                   </use></svg><span class="menu_word" style="font-size:17px"> 旧时光</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-maoliang"></use></svg><span class="menu_word" style="font-size:17px"> 个人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/personal/bb/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-qunliaotian">                   </use></svg><span class="menu_word" style="font-size:17px"> 唠叨</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/personal/love/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-love-sign">                   </use></svg><span class="menu_word" style="font-size:17px"> 小屋</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/personal/about/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-paperplane">                   </use></svg><span class="menu_word" style="font-size:17px"> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">不学无墅</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-home"></use></svg><span class="menu_word" style="font-size:17px"> 首页</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--article"></use></svg><span class="menu_word" style="font-size:17px"> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-guidang1">                   </use></svg><span class="menu_word" style="font-size:17px"> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-sekuaibiaoqian">                   </use></svg><span class="menu_word" style="font-size:17px"> 标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-fenlei">                   </use></svg><span class="menu_word" style="font-size:17px"> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pinweishenghuo"></use></svg><span class="menu_word" style="font-size:17px"> 休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/life/music/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-yinle">                   </use></svg><span class="menu_word" style="font-size:17px"> 八音盒</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/movies/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-dianying1">                   </use></svg><span class="menu_word" style="font-size:17px"> 影院</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/games/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-youxishoubing">                   </use></svg><span class="menu_word" style="font-size:17px"> 游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xiangzi"></use></svg><span class="menu_word" style="font-size:17px"> 八宝箱</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/box/gallery/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-tubiaozhizuomoban">                   </use></svg><span class="menu_word" style="font-size:17px"> 画廊</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/animation/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-nvwumao">                   </use></svg><span class="menu_word" style="font-size:17px"> 动画</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/nav/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-zhifengche">                   </use></svg><span class="menu_word" style="font-size:17px"> 网址导航</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shejiaoxinxi"></use></svg><span class="menu_word" style="font-size:17px"> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/social/fcircle/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pengyouquan">                   </use></svg><span class="menu_word" style="font-size:17px"> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-liuyan">                   </use></svg><span class="menu_word" style="font-size:17px"> 留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/social/link/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-lianjie">                   </use></svg><span class="menu_word" style="font-size:17px"> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-wangye"></use></svg><span class="menu_word" style="font-size:17px"> 网站</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/site/census/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--tongjibiao">                   </use></svg><span class="menu_word" style="font-size:17px"> 网站统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/echarts/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shujutongji1">                   </use></svg><span class="menu_word" style="font-size:17px"> 文章统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/time/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xianxingshalou">                   </use></svg><span class="menu_word" style="font-size:17px"> 旧时光</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-maoliang"></use></svg><span class="menu_word" style="font-size:17px"> 个人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/personal/bb/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-qunliaotian">                   </use></svg><span class="menu_word" style="font-size:17px"> 唠叨</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/personal/love/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-love-sign">                   </use></svg><span class="menu_word" style="font-size:17px"> 小屋</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/personal/about/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-paperplane">                   </use></svg><span class="menu_word" style="font-size:17px"> 关于</span></a></li></ul></div></div><center id="name-container"><a id="page-name" href="javascript:scrollToTop()">PAGE_NAME</a></center><div id="nav-right"><div id="search-button"><a class="search faa-parent animated-hover" title="检索站内任何你想要的信息"><svg class="faa-tada icon" style="height:24px;width:24px;fill:currentColor;position:relative;top:6px" aria-hidden="true"><use xlink:href="#icon-valentine_-search-love-find-heart"></use></svg><span> 搜索</span></a></div><a class="meihua faa-parent animated-hover" onclick="toggleWinbox()" title="美化设置-自定义你的风格" id="meihua-button"><svg class="faa-tada icon" style="height:26px;width:26px;fill:currentColor;position:relative;top:8px" aria-hidden="true"><use xlink:href="#icon-tupian1"></use></svg></a><a class="sun_moon faa-parent animated-hover" onclick="switchNightMode()" title="浅色和深色模式转换" id="nightmode-button"><svg class="faa-tada" style="height:25px;width:25px;fill:currentColor;position:relative;top:7px" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon">       </use></svg></a><div id="toggle-menu"><a><i class="fas fa-bars fa-fw"></i></a></div></div></div></nav><div id="post-info"><h1 class="post-title">算法合集</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><svg class="meta_icon post-meta-icon" style="width:30px;height:30px;position:relative;top:10px"><use xlink:href="#icon-rili"></use></svg><span class="post-meta-label">发表于 </span><time class="post-meta-date-created" datetime="2023-03-23T07:19:58.000Z" title="发表于 2023-03-23 15:19:58">2023-03-23</time><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:18px;height:18px;position:relative;top:5px"><use xlink:href="#icon-gengxin1"></use></svg><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-11-11T09:11:28.744Z" title="更新于 2023-11-11 17:11:28">2023-11-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:18px;height:18px;position:relative;top:5px"><use xlink:href="#icon-biaoqian"></use></svg><a class="post-meta-categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><svg class="meta_icon post-meta-icon" style="width:25px;height:25px;position:relative;top:8px"><use xlink:href="#icon-charuword"></use></svg><span class="post-meta-label">字数总计:</span><span class="word-count">3.3w</span><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:20px;height:20px;position:relative;top:5px"><use xlink:href="#icon-shizhong"></use></svg><span class="post-meta-label">阅读时长:</span><span>139分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="算法合集"><svg class="meta_icon post-meta-icon" style="width:25px;height:25px;position:relative;top:5px"><use xlink:href="#icon-eye"></use></svg><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<p>摘要：<br><span id="more"></span></p>
</blockquote>
<h1 id=""><a href="#" class="headerlink" title=" "></a> </h1><h1 id="longlongint的范围-9223372036854775808～9223372036854775807。19位数，小于10的19次方-（用-lld输出）"><a href="#longlongint的范围-9223372036854775808～9223372036854775807。19位数，小于10的19次方-（用-lld输出）" class="headerlink" title="longlongint的范围-9223372036854775808～9223372036854775807。19位数，小于10的19次方 （用%lld输出）"></a><strong>longlongint的范围-9223372036854775808～9223372036854775807。19位数，小于10的19次方 （用%lld输出）</strong></h1><h1 id="int范围是-2147483648～2147483647（2的31次方）-小于10的10次方-10位数"><a href="#int范围是-2147483648～2147483647（2的31次方）-小于10的10次方-10位数" class="headerlink" title="int范围是-2147483648～2147483647（2的31次方） 小于10的10次方 10位数"></a>int范围是-2147483648～2147483647（2的31次方） 小于10的10次方 10位数</h1><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef class <span class="keyword">node</span><span class="title">&#123;</span></span><br><span class="line"><span class="title">public</span>: int data;</span><br><span class="line">	 <span class="keyword">node</span><span class="title">* next</span>;</span><br><span class="line">&#125;<span class="keyword">Node</span><span class="title">;</span></span><br></pre></td></tr></table></figure>
<h2 id="正序插入"><a href="#正序插入" class="headerlink" title="正序插入"></a>正序插入</h2><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">node</span>* zhengxu() &#123;</span><br><span class="line">	<span class="type">node</span>*<span class="built_in"> head</span> = NULL;</span><br><span class="line">	<span class="type">node</span>* n1 = new <span class="type">node</span>();</span><br><span class="line">	n1-&gt;<span class="keyword">next</span> = NULL;</span><br><span class="line">	<span class="built_in"> head</span> = n1;</span><br><span class="line">	int d;</span><br><span class="line">	printf(<span class="string">&quot;请输入链表的长度:&quot;</span>);</span><br><span class="line">	scanf_s(<span class="string">&quot;%d&quot;</span>, &amp;d);</span><br><span class="line">	<span class="keyword">for</span> (int i = <span class="number">0</span>;i &lt; d;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(<span class="string">&quot;请输入第%d个数的值：&quot;</span>, i + <span class="number">1</span>);</span><br><span class="line">		<span class="type">node</span>* n = new <span class="type">node</span>();</span><br><span class="line">		scanf_s(<span class="string">&quot;%d&quot;</span>, &amp;n-&gt;data);</span><br><span class="line">		n1-&gt;<span class="keyword">next</span> = n;</span><br><span class="line">		n1 = n;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span><span class="built_in"> head</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="倒序插入"><a href="#倒序插入" class="headerlink" title="倒序插入"></a>倒序插入</h2><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">node</span>* daoxu() &#123;</span><br><span class="line">	<span class="type">node</span>*<span class="built_in"> head</span> = NULL, * tem = NULL;</span><br><span class="line">	<span class="type">node</span>* n1 = new <span class="type">node</span>();</span><br><span class="line">	n1-&gt;<span class="keyword">next</span> = NULL;</span><br><span class="line"><span class="built_in">	head</span> = n1;</span><br><span class="line">	int d;</span><br><span class="line">	printf(<span class="string">&quot;请输入链表的长度&quot;</span>);</span><br><span class="line">	scanf_s(<span class="string">&quot;%d&quot;</span>, &amp;d);</span><br><span class="line">	<span class="keyword">for</span> (int i = <span class="number">0</span>;i &lt; d;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(<span class="string">&quot;请输入第%d个数的值：&quot;</span>, i + <span class="number">1</span>);</span><br><span class="line">		<span class="type">node</span>* n = new <span class="type">node</span>();</span><br><span class="line">		scanf_s(<span class="string">&quot;%d&quot;</span>, &amp;n-&gt;data);</span><br><span class="line">		n1-&gt;<span class="keyword">next</span> = n;</span><br><span class="line">		<span class="keyword">if</span> (i &gt;= <span class="number">1</span>) &#123; n-&gt;<span class="keyword">next</span> = tem; &#125;</span><br><span class="line">		tem = n;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span><span class="built_in"> head</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">void</span> bianli(node* &amp;head)</span><br><span class="line">	&#123;</span><br><span class="line">	node* <span class="built_in">p1</span> = head-&gt;next<span class="comment">;</span></span><br><span class="line">	int i = <span class="number">1</span><span class="comment">;</span></span><br><span class="line">	<span class="meta">while</span> (<span class="built_in">p1</span>) &#123;</span><br><span class="line">		printf(<span class="string">&quot;第%d个节点值为：%d\n&quot;</span>,i, <span class="built_in">p1</span>-&gt;<span class="meta">data</span>)<span class="comment">;</span></span><br><span class="line">		<span class="built_in">p1</span> = <span class="built_in">p1</span>-&gt;next<span class="comment">;</span></span><br><span class="line">		i++<span class="comment">;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="1-DFS深度优先算法"><a href="#1-DFS深度优先算法" class="headerlink" title="1.DFS深度优先算法"></a>1.DFS深度优先算法</h2><h2 id="2-BFS广度优先算法"><a href="#2-BFS广度优先算法" class="headerlink" title="2.BFS广度优先算法"></a>2.BFS广度优先算法</h2><h3 id="广搜模板"><a href="#广搜模板" class="headerlink" title="广搜模板"></a>广搜模板</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//广搜模板</span></span><br><span class="line">q.<span class="built_in">push</span>(初始状态)；</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">	a= q.front();</span><br><span class="line">	q.<span class="built_in">pop</span>();</span><br><span class="line">	<span class="keyword">for</span>(枚举a的所有可达状态v)&#123;</span><br><span class="line">		<span class="keyword">if</span>(本状态v合法)&#123;</span><br><span class="line">			执行标记操作；</span><br><span class="line">			q.<span class="built_in">push</span>(v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="P1443-马的遍历-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P1443-马的遍历-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="P1443 马的遍历 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1443">P1443 马的遍历 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><p>1.输入数据n,m,起始点(x0,y0)<br>2.将起始点的位置标记为0 m[x0][y0]=0<br>3.q.push (x0,yo)<br>4.循环直到q为空：<br>取出队列头的点(x,y)<br>对这个点模拟马跳，对能跳到的位置，判断合法性：是否在棋盘，是否为-1<br>将找到的点的值赋值为m[x][y]+1<br>将找到的点push入队列中<br>5.输出</p>
<h2 id="3-最短路之dijkstra"><a href="#3-最短路之dijkstra" class="headerlink" title="3.最短路之dijkstra"></a>3.最短路之dijkstra</h2><h2 id="4-最短路之SPFA"><a href="#4-最短路之SPFA" class="headerlink" title="4.最短路之SPFA"></a>4.最短路之SPFA</h2><h2 id="5-最短路之Floyd"><a href="#5-最短路之Floyd" class="headerlink" title="5.最短路之Floyd"></a>5.最短路之Floyd</h2><h2 id="6-高精度"><a href="#6-高精度" class="headerlink" title="6.高精度"></a>6.高精度</h2><p>此题解只面对与刚刚学算法的童鞋们</p>
<ul>
<li>什么情况下要<strong>使用高精度</strong>？</li>
</ul>
<p>当两个数超过longlong的大小并且要对这两个大数进行运算的时候。</p>
<ul>
<li>既然数这么大，我们用什么存放呢？</li>
</ul>
<p>用<strong>字符串</strong>存放。</p>
<ul>
<li>怎么运算呢？</li>
</ul>
<p>小学学加法的时候，我们是从最低位开始计算，两两相加，逢十进一。</p>
<p>我们也可以用计算机模拟这一过程。</p>
<p>具体代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>; j&lt;=<span class="built_in">max</span>(a[<span class="number">0</span>],b[<span class="number">0</span>])+<span class="number">1</span>; j++) &#123;</span><br><span class="line">	c[j]=a[j]+b[j];</span><br><span class="line">	<span class="keyword">if</span>(c[j]&gt;=<span class="number">10</span>) &#123;</span><br><span class="line">		c[j]%=<span class="number">10</span>;</span><br><span class="line">		a[j+<span class="number">1</span>]++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>既然要进行运算，我们总得知道字符串的长度吧？怎么获取呢？</li>
</ul>
<p>用<em>s<strong>t</strong>r<strong>l</strong>e</em>n函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="number">0</span>]=<span class="built_in">strlen</span>(s);</span><br><span class="line">b[<span class="number">0</span>]=<span class="built_in">strlen</span>(ss);</span><br></pre></td></tr></table></figure>
<ul>
<li>要运算，怎么知道某一位的具体数值是几呢？</li>
</ul>
<p>这个跟a<strong>s</strong>c<strong>l</strong>l码有关了。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/godwad/tianxuan4/main/tianxuan/1-1356-png_6_0_0_0_0_959_1356_959_1356-959-0-0-959.jpg" alt="img"></p>
<p>一个字符数字的a<strong>s</strong>c<strong>l</strong>l<em>码－48（也就是0的a<strong>s</strong>c<strong>l</strong>l</em>码）就是那个数字的a<strong>s</strong>c<strong>l</strong>l码。</p>
<p>转化过程：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=a[<span class="number">0</span>]; i++) a[i]=s[a[<span class="number">0</span>]-i]-<span class="string">&#x27;0&#x27;</span>;<span class="comment">//倒序存入数组，从低到高位</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=b[<span class="number">0</span>]; i++) b[i]=ss[b[<span class="number">0</span>]-i]-<span class="string">&#x27;0&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>☆ 注意：</p>
<h3 id="一定要考虑进位！！"><a href="#一定要考虑进位！！" class="headerlink" title="一定要考虑进位！！"></a>一定要考虑进位！！</h3><p>具体的说，就是最高位相加时可能会有进位，需特判。</p>
<p>如果d<strong>a</strong>l<strong>a</strong>o们看前面的不顺眼觉得蔡那看看这个：</p>
<p>读入第一行字符串A与第二行字符串B，</p>
<p>将两串字符串的每个字符转成数字存储在数组中，字符转数字的方式是：<strong>ch-’0’</strong></p>
<p>我们将个位存在a<em>[1]，高位存在a</em>[l]，l是数字位数，也即字符串长度。</p>
<p>字符串B<em>也用一个数组</em>b来记录。</p>
<p>高精度加法就是模拟加法的过程，我们要做的就是让a和b的每一位相加，并判断任意一位数是否大于等于1010，即应进位的问题。</p>
<p>处理完进位同时也要考虑最终和的位数（长度）是否有变化。 最终逐位输出达成输出大数的效果。</p>
<p>说了这么多，上一下A<em>C</em>代码：</p>
<h3 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">1000001</span>],b[<span class="number">1000001</span>],c[<span class="number">1000001</span>],j;</span><br><span class="line"><span class="type">bool</span> x=<span class="literal">false</span>;</span><br><span class="line"><span class="type">char</span> s[<span class="number">1000001</span>],ss[<span class="number">1000001</span>];<span class="comment">//或string s,ss;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));</span><br><span class="line">	<span class="built_in">memset</span>(b,<span class="number">0</span>,<span class="built_in">sizeof</span>(b));</span><br><span class="line">	<span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="built_in">sizeof</span>(c));<span class="comment">//初始化</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>,s,ss);<span class="comment">//读入两个数</span></span><br><span class="line">	a[<span class="number">0</span>]=<span class="built_in">strlen</span>(s);</span><br><span class="line">	b[<span class="number">0</span>]=<span class="built_in">strlen</span>(ss);<span class="comment">//获取长度</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=a[<span class="number">0</span>]; i++) a[i]=s[a[<span class="number">0</span>]-i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=b[<span class="number">0</span>]; i++) b[i]=ss[b[<span class="number">0</span>]-i]-<span class="string">&#x27;0&#x27;</span>;<span class="comment">//转化为数字</span></span><br><span class="line">	<span class="keyword">for</span>(j=<span class="number">1</span>; j&lt;=<span class="built_in">max</span>(a[<span class="number">0</span>],b[<span class="number">0</span>])+<span class="number">1</span>; j++) &#123;</span><br><span class="line">		c[j]=a[j]+b[j];</span><br><span class="line">		<span class="keyword">if</span>(c[j]&gt;=<span class="number">10</span>) &#123;</span><br><span class="line">			c[j]%=<span class="number">10</span>;</span><br><span class="line">			a[j+<span class="number">1</span>]++;<span class="comment">//或者让c[j+1]++，然后上面换成c[j]+=a[j]+b[j];</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="comment">//模拟加法</span></span><br><span class="line">	c[<span class="number">0</span>]=j;</span><br><span class="line">	<span class="keyword">if</span>(c[j+<span class="number">1</span>]&gt;<span class="number">0</span>) c[<span class="number">0</span>]++;<span class="comment">//特判进位</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=c[<span class="number">0</span>]; i&gt;=<span class="number">1</span>; i--) &#123;<span class="comment">//输出（删除前导零）</span></span><br><span class="line">		<span class="keyword">if</span>(x==<span class="literal">false</span>&amp;&amp;c[i]==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">		x=<span class="literal">true</span>;</span><br><span class="line">		cout&lt;&lt;c[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(x==<span class="literal">false</span>) cout&lt;&lt;<span class="number">0</span>;<span class="comment">//一重保险</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);<span class="comment">//二重保险</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//三重保险</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在以后的学习中，高精度会成为一个很重（ke）要（pa）的算法，T<em>a</em>会成为一种工具。</p>
<h3 id="高精度乘法"><a href="#高精度乘法" class="headerlink" title="高精度乘法"></a>高精度乘法</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> tem =<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;slen;i++)s[i]*=n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;slen;i++)&#123;</span><br><span class="line">tem= tem+s[i];</span><br><span class="line">s[i]=tem% <span class="number">10</span>;</span><br><span class="line">tem/=<span class="number">10</span>;&#125;</span><br><span class="line"><span class="keyword">while</span>(tem !=<span class="number">0</span>)&#123;		<span class="comment">//防止进位过多</span></span><br><span class="line">s[slen]=tem% <span class="number">10</span>;</span><br><span class="line">slen++;</span><br><span class="line">tem/=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	string n1, n2;</span><br><span class="line">	cin &gt;&gt; n1 &gt;&gt; n2;</span><br><span class="line">	int a1[<span class="number">10000</span>] = &#123; <span class="number">0</span> &#125;, b1[<span class="number">10000</span>] = &#123; <span class="number">0</span> &#125;, c1[<span class="number">10000</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	a1[<span class="number">0</span>] = n1.size();</span><br><span class="line">	b1[<span class="number">0</span>]=	n2.size();</span><br><span class="line">	bool flag = false;</span><br><span class="line">	for (int i = <span class="number">1</span>;i &lt;= n1.size();i++) </span><br><span class="line">	&#123;</span><br><span class="line">		a1[a1[<span class="number">0</span>] - i + <span class="number">1</span>] = n1[i<span class="number">-1</span>]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	for (int i = <span class="number">1</span>;i &lt;= n2.size();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		b1[b1[<span class="number">0</span>] - i + <span class="number">1</span>] = n2[i - <span class="number">1</span>]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	for (int i = <span class="number">1</span>;i &lt;= n1.size();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		for (int j = <span class="number">1</span>;j &lt;= n2.size();j++)</span><br><span class="line">		&#123;</span><br><span class="line">			c1[i + j - <span class="number">1</span>]+= a1[i] * b1[j];</span><br><span class="line">			c1[i + j] += c1[i + j - <span class="number">1</span>] / <span class="number">10</span>;</span><br><span class="line">			c1[i + j <span class="number">-1</span>] = c1[i + j - <span class="number">1</span>] <span class="comment">% 10;</span></span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	for (int i = n1.size() + n2.size();i &gt;= <span class="number">1</span>;i--)</span><br><span class="line">	&#123;</span><br><span class="line">		if (flag || c1[i] != <span class="number">0</span> ||i==<span class="number">1</span>) &#123; flag = true;cout &lt;&lt; c1[i]; &#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="用高精度算法算一个数的阶乘-并相加-—-洛谷1009"><a href="#用高精度算法算一个数的阶乘-并相加-—-洛谷1009" class="headerlink" title="用高精度算法算一个数的阶乘(并相加) —-洛谷1009"></a>用高精度算法算一个数的阶乘(并相加) —-洛谷1009</h3><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">这种算法适用于一个数小的时候，也就是在int范围以内，否则就要用上面那个用字符串接收再相乘，这个可以直接相乘。</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n,t=<span class="number">0</span>,a[<span class="number">10000</span>] = &#123; <span class="number">0</span> &#125;, b[<span class="number">10000</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	bool flag = false;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	a[<span class="number">0</span>] = <span class="number">1</span>; //<span class="number">1</span>*任何数都等于它本身</span><br><span class="line">	b[<span class="number">0</span>] = <span class="number">1</span>;//赋值为<span class="number">1</span>，是为了加上<span class="number">1</span>的阶乘，也就是<span class="number">1</span></span><br><span class="line">	for (int i = <span class="number">2</span>;i &lt;= n;i++)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		for (int j = <span class="number">0</span>;j &lt; <span class="number">10000</span>;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			a[j] = t + a[j] * i;</span><br><span class="line">			t = a[j] / <span class="number">10</span>;</span><br><span class="line">			a[j] = a[j] <span class="comment">% 10;</span></span><br><span class="line"></span><br><span class="line">		&#125; //用原数组的每一位分别乘这个数（重点理解！）</span><br><span class="line">		</span><br><span class="line">		for (int j = <span class="number">0</span>;j &lt; <span class="number">10000</span>;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			b[j] += a[j];</span><br><span class="line">			b[j + <span class="number">1</span>] += b[j] / <span class="number">10</span>;</span><br><span class="line">			b[j] = b[j] <span class="comment">% 10;</span></span><br><span class="line">		&#125;//阶乘相加，高精度算法</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	for (int i = <span class="number">100</span>;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line">	&#123;</span><br><span class="line">		if (flag || b[i] != <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			flag = true;</span><br><span class="line">			cout &lt;&lt; b[i];</span><br><span class="line">		&#125;//消除前导<span class="number">0</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">这一种方法可以计算最后数组里面的有效长度，也就是p</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[<span class="number">5000</span>];</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">1001</span>;i++)</span><br><span class="line">    a[i] = <span class="number">0</span>;<span class="comment">//将数组清零。</span></span><br><span class="line">a[<span class="number">1</span>] = <span class="number">1</span>;<span class="comment">//必须设为1。不能为0，不然怎么乘都是0。</span></span><br><span class="line"><span class="type">int</span> n, i, j, k, m;</span><br><span class="line"><span class="type">int</span> p = <span class="number">1</span>, jw = <span class="number">0</span>;<span class="comment">//p代表位数，jw代表进位。</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">2</span>;i &lt;= n;i++)<span class="comment">//从2开始，反正任何数乘1还等于它本身。</span></span><br><span class="line">&#123;</span><br><span class="line">    jw = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>;j &lt;= p;j++)<span class="comment">//高精度*单精度。</span></span><br><span class="line">    &#123;</span><br><span class="line">        a[j] = a[j] * i + jw;<span class="comment">//高精度*单精度+进位。</span></span><br><span class="line">        jw = a[j] / <span class="number">10</span>;<span class="comment">//设置进位。</span></span><br><span class="line">        a[j] = a[j] % <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (jw &gt; <span class="number">0</span>)<span class="comment">//如果还有进位，处理进位。</span></span><br><span class="line">    &#123;</span><br><span class="line">        a[j] = jw % <span class="number">10</span>;<span class="comment">//此时j已经为p+1，因为加了一，不满足循环跳出来了</span></span><br><span class="line">        jw /= <span class="number">10</span>;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    p = j - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="7-最小生成树之kruskal"><a href="#7-最小生成树之kruskal" class="headerlink" title="7.最小生成树之kruskal"></a>7.最小生成树之kruskal</h2><p>【最小生成树(Kruskal(克鲁斯卡尔)和Prim(普里姆))算法动画演示】<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Eb41177d1?vd_source=626e2d95a6f6efebc61310d99bac2d29">https://www.bilibili.com/video/BV1Eb41177d1?vd_source=626e2d95a6f6efebc61310d99bac2d29</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_49786613/article/details/115309103?ops_request_misc=%7B%22request%5Fid%22%3A%22169962809916800182133201%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=169962809916800182133201&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-115309103-null-null.142^v96^pc_search_result_base8&amp;utm_term=最小生成树kruskal算法&amp;spm=1018.2226.3001.4187">最小生成树-Kruskal算法_独钓烟云的博客-CSDN博客</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1000001</span>;</span><br><span class="line"><span class="type">int</span> father[maxn];<span class="comment">//father数组存放的是父亲结点</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">	<span class="type">int</span> u;<span class="comment">//左端点</span></span><br><span class="line">	<span class="type">int</span> v;<span class="comment">//右端点</span></span><br><span class="line">	<span class="type">int</span> dis;<span class="comment">//权值</span></span><br><span class="line">&#125;ed[maxn];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Edge a,Edge b)</span></span>&#123;<span class="comment">//结构体排序</span></span><br><span class="line">	<span class="keyword">return</span> a.dis &lt; b.dis;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;<span class="comment">//初始化</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) father[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_father</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="comment">//并查集核心操作</span></span><br><span class="line">	<span class="keyword">if</span>(x==father[x]) <span class="keyword">return</span> x;<span class="comment">//此种情况是找到了最终父亲，也就是根节点</span></span><br><span class="line">	<span class="type">int</span> temp = <span class="built_in">find_father</span>(father[x]);<span class="comment">//路径压缩</span></span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Kruskal</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> ans = <span class="number">0</span>;<span class="comment">//记入最小生成树的权值</span></span><br><span class="line">	<span class="type">int</span> num_Edge = <span class="number">0</span>;<span class="comment">//边的数目</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">		<span class="type">int</span> fu = <span class="built_in">find_father</span>(ed[i].u);<span class="comment">//找最终父亲</span></span><br><span class="line">		<span class="type">int</span> fv = <span class="built_in">find_father</span>(ed[i].v);<span class="comment">//找最终父亲</span></span><br><span class="line">		<span class="keyword">if</span>(fu!=fv)&#123;<span class="comment">//如果两个节点的最终父亲都一样，则说明两个节点都已经在集合里</span></span><br><span class="line">			father[fu] = fv;<span class="comment">//合并，每次都让新节点的父节点赋值为根节点</span></span><br><span class="line">			ans+=ed[i].dis;</span><br><span class="line">			num_Edge++;</span><br><span class="line">			<span class="keyword">if</span>(num_Edge==n<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(num_Edge!=n<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//退出条件</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n,m;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="built_in">init</span>(n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++) cin&gt;&gt;ed[i].u&gt;&gt;ed[i].v&gt;&gt;ed[i].dis;<span class="comment">//输入</span></span><br><span class="line">	<span class="built_in">sort</span>(ed,ed+m,cmp);<span class="comment">//排序</span></span><br><span class="line">	cout&lt;&lt;<span class="built_in">Kruskal</span>(n,m);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="8-最小生成树之prim"><a href="#8-最小生成树之prim" class="headerlink" title="8.最小生成树之prim"></a>8.最小生成树之prim</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_62213124/article/details/121597780?ops_request_misc=%7B%22request%5Fid%22%3A%22169962736416800226577963%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=169962736416800226577963&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-121597780-null-null.142^v96^pc_search_result_base8&amp;utm_term=最小生成树&amp;spm=1018.2226.3001.4187">最小生成树——Prim算法（详细图解）_prim最小生成树_skynesser的博客-CSDN博客</a></p>
<h3 id="注意，最小生成树可能有很多种，但最后的权值都是相同的，所以遇见两个最小值相同的边取哪一条都可以！"><a href="#注意，最小生成树可能有很多种，但最后的权值都是相同的，所以遇见两个最小值相同的边取哪一条都可以！" class="headerlink" title="注意，最小生成树可能有很多种，但最后的权值都是相同的，所以遇见两个最小值相同的边取哪一条都可以！"></a>注意，最小生成树可能有很多种，但最后的权值都是相同的，所以遇见两个最小值相同的边取哪一条都可以！</h3><figure class="highlight ruleslanguage"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const int <span class="keyword">MAXN</span> = <span class="number">1000</span>,INF = <span class="number">0x3f3f3f3f</span>;<span class="comment">//定义一个INF表示无穷大。</span></span><br><span class="line">int g[<span class="keyword">MAXN</span>][<span class="keyword">MAXN</span>],dist[<span class="keyword">MAXN</span>],n,m,res;</span><br><span class="line"><span class="comment">//我们用g[][]数组存储这个图，dist[]储存到集合S的距离，res保存结果。</span></span><br><span class="line">bool book[<span class="keyword">MAXN</span>];<span class="comment">//用book数组记录某个点是否加入到集合S中。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;<span class="regexp">//</span>读入这个图的点数n和边数m</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">1</span> ; i&lt;= n ;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(int j = <span class="number">1</span>; j &lt;= n ;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            g[i][j] = INF;<span class="regexp">//</span>初始化任意两个点之间的距离为正无穷（表示这两个点之间没有边）</span><br><span class="line">        &#125;</span><br><span class="line">        dist[i] = INF;<span class="regexp">//</span>初始化所有点到集合S的距离都是正无穷</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= m ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int a,b,w;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;w;<span class="regexp">//</span>读入a，b两个点之间的边</span><br><span class="line">        g[a][b] = g[b][a] = w;<span class="regexp">//</span>由于是无向边，我们对g[a][b]和g[b][a]都要赋值</span><br><span class="line">    &#125;</span><br><span class="line">    prim();<span class="regexp">//</span>调用prim函数</span><br><span class="line">    <span class="keyword">if</span>(res==INF)<span class="regexp">//</span>如果res的值是正无穷，表示不能该图不能转化成一棵树，输出orz</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;orz&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;res;<span class="regexp">//</span>否则就输出结果res</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">prim</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">dist</span>[<span class="number">1</span>] = <span class="number">0</span>;<span class="comment">//把点1加入集合S，点1在集合S中，将它到集合的距离初始化为0</span></span><br><span class="line">    book[<span class="number">1</span>] = <span class="literal">true</span>;<span class="comment">//表示点1已经加入到了S集合中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span> ; i &lt;= n ;i++)<span class="built_in">dist</span>[i] = <span class="built_in">min</span>(<span class="built_in">dist</span>[i],g[<span class="number">1</span>][i]);<span class="comment">//用点1去更新dist[]</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span> ; i &lt;= n ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> temp = INF;<span class="comment">//初始化距离</span></span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;<span class="comment">//接下来去寻找离集合S最近的点加入到集合中，用t记录这个点的下标。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">2</span> ; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!book[j]&amp;&amp;<span class="built_in">dist</span>[j]&lt;temp)<span class="comment">//如果这个点没有加入集合S，而且这个点到集合的距离小于temp就将下标赋给t</span></span><br><span class="line">            &#123;</span><br><span class="line">                temp = <span class="built_in">dist</span>[j];<span class="comment">//更新集合V到集合S的最小值</span></span><br><span class="line">                t = j;<span class="comment">//把点赋给t</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(t==<span class="number">-1</span>)&#123;res = INF ; <span class="keyword">return</span> ;&#125;</span><br><span class="line">        <span class="comment">//如果t==-1，意味着在集合V找不到边连向集合S，生成树构建失败，将res赋值正无穷表示构建失败，结束函数</span></span><br><span class="line">        book[t] = <span class="literal">true</span>;<span class="comment">//如果找到了这个点，就把它加入集合S</span></span><br><span class="line">        res+=<span class="built_in">dist</span>[t];<span class="comment">//加上这个点到集合S的距离</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">2</span> ; j &lt;= n ; j++)<span class="built_in">dist</span>[j] = <span class="built_in">min</span>(<span class="built_in">dist</span>[j],g[t][j]);<span class="comment">//用新加入的点更新dist[]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="9-树的直径——BFS"><a href="#9-树的直径——BFS" class="headerlink" title="9.树的直径——BFS"></a>9.树的直径——BFS</h2><h2 id="10-树的直径——DFS"><a href="#10-树的直径——DFS" class="headerlink" title="10.树的直径——DFS"></a>10.树的直径——DFS</h2><h2 id="11-树的直径——树形DP"><a href="#11-树的直径——树形DP" class="headerlink" title="11.树的直径——树形DP"></a>11.树的直径——树形DP</h2><h2 id="12-树状数组"><a href="#12-树状数组" class="headerlink" title="12.树状数组"></a>12.树状数组</h2><h2 id="13-字典树"><a href="#13-字典树" class="headerlink" title="13.字典树"></a>13.字典树</h2><h2 id="14-线段树"><a href="#14-线段树" class="headerlink" title="14.线段树"></a>14.线段树</h2><h1 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h1><h1 id="暴力枚举（适合数据范围小的时候，比如100以内，常见for循环）"><a href="#暴力枚举（适合数据范围小的时候，比如100以内，常见for循环）" class="headerlink" title="暴力枚举（适合数据范围小的时候，比如100以内，常见for循环）"></a>暴力枚举（适合数据范围小的时候，比如100以内，常见for循环）</h1><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3392">P3392 涂国旗 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">int n,m,ans,mi=inf;<span class="regexp">//mi</span>初始化成一个很大的数</span><br><span class="line">char c[N][N];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int i,j,k,g;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	  <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=m;j++) cin&gt;&gt;c[i][j];</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n-<span class="number">2</span>;i++)<span class="regexp">//</span>由于白色下面还有蓝色和红色，所以i（白与蓝的边界）枚举到（n-<span class="number">2</span>）</span><br><span class="line">	  <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;=n-<span class="number">1</span>;j++)<span class="regexp">//</span>j（蓝与红的边界）至少要比i大<span class="number">1</span>，同理枚举到（n-<span class="number">1</span>），这样可以减少枚举次数</span><br><span class="line">	  &#123;</span><br><span class="line">	    ans=<span class="number">0</span>;<span class="regexp">//</span>初始化</span><br><span class="line">        <span class="regexp">//</span>壮观地枚举三个区域</span><br><span class="line">	    <span class="keyword">for</span>(k=<span class="number">1</span>;k&lt;=i;k++)</span><br><span class="line">	      <span class="keyword">for</span>(g=<span class="number">1</span>;g&lt;=m;g++) <span class="keyword">if</span>(c[k][g]!=<span class="string">&#x27;W&#x27;</span>) ans++;</span><br><span class="line">	    <span class="keyword">for</span>(k=i+<span class="number">1</span>;k&lt;=j;k++)</span><br><span class="line">	      <span class="keyword">for</span>(g=<span class="number">1</span>;g&lt;=m;g++) <span class="keyword">if</span>(c[k][g]!=<span class="string">&#x27;B&#x27;</span>) ans++;</span><br><span class="line">	    <span class="keyword">for</span>(k=j+<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">	      <span class="keyword">for</span>(g=<span class="number">1</span>;g&lt;=m;g++) <span class="keyword">if</span>(c[k][g]!=<span class="string">&#x27;R&#x27;</span>) ans++;</span><br><span class="line">        <span class="regexp">//</span>强迫症（本蒟蒻）看到这些语句表示很开心</span><br><span class="line">	    mi=min(ans,mi);<span class="regexp">//</span>更新答案</span><br><span class="line">	  &#125;</span><br><span class="line">	cout&lt;&lt;mi&lt;&lt;endl;</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h1><h1 id="后缀和"><a href="#后缀和" class="headerlink" title="后缀和"></a>后缀和</h1><h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><h1 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h1><h1 id="分块"><a href="#分块" class="headerlink" title="分块"></a>分块</h1><h1 id="LCT"><a href="#LCT" class="headerlink" title="LCT"></a>LCT</h1><h1 id="Splay"><a href="#Splay" class="headerlink" title="Splay"></a>Splay</h1><h1 id="LCA"><a href="#LCA" class="headerlink" title="LCA"></a>LCA</h1><h1 id="Bellman-Ford"><a href="#Bellman-Ford" class="headerlink" title="Bellman-Ford"></a>Bellman-Ford</h1><h1 id="可耻的打表"><a href="#可耻的打表" class="headerlink" title="可耻的打表"></a>可耻的打表</h1><h1 id="SPFA算法"><a href="#SPFA算法" class="headerlink" title="SPFA算法"></a>SPFA算法</h1><h2 id="SPFA求最短路之SLF优化"><a href="#SPFA求最短路之SLF优化" class="headerlink" title="SPFA求最短路之SLF优化"></a>SPFA求最短路之SLF优化</h2><h2 id="SPFA之LLL优化"><a href="#SPFA之LLL优化" class="headerlink" title="SPFA之LLL优化"></a>SPFA之LLL优化</h2><h2 id="SPFA之SLF-LLL优化算法"><a href="#SPFA之SLF-LLL优化算法" class="headerlink" title="SPFA之SLF+LLL优化算法"></a>SPFA之SLF+LLL优化算法</h2><h1 id="只用一个变量"><a href="#只用一个变量" class="headerlink" title="只用一个变量"></a>只用一个变量</h1><h1 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h1><h1 id="STL-dijkstra"><a href="#STL-dijkstra" class="headerlink" title="STL+dijkstra"></a>STL+dijkstra</h1><h1 id="数学表达式"><a href="#数学表达式" class="headerlink" title="数学表达式"></a>数学表达式</h1><h1 id="压位高精度加法"><a href="#压位高精度加法" class="headerlink" title="压位高精度加法"></a>压位高精度加法</h1><h1 id="矩阵DP"><a href="#矩阵DP" class="headerlink" title="矩阵DP"></a>矩阵DP</h1><h1 id="十大经典排序算法"><a href="#十大经典排序算法" class="headerlink" title="十大经典排序算法"></a>十大经典<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=排序算法&amp;spm=1001.2101.3001.7020">排序算法</a></h1><h2 id="0、算法概述"><a href="#0、算法概述" class="headerlink" title="0、算法概述"></a>0、算法概述</h2><h3 id="0-1-算法分类"><a href="#0-1-算法分类" class="headerlink" title="0.1 算法分类"></a>0.1 算法分类</h3><p>十种常见排序算法可以分为两大类：</p>
<p>比较类排序：通过比较来决定元素间的相对次序，由于其<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=时间复杂度&amp;spm=1001.2101.3001.7020">时间复杂度</a>不能突破O(nlogn)，因此也称为非线性时间比较类排序。<br>非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/20200527161235817.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTU0ODkxMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="0-2-算法复杂度"><a href="#0-2-算法复杂度" class="headerlink" title="0.2 算法复杂度"></a>0.2 算法复杂度</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/20200527161247665.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTU0ODkxMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="0-3-相关概念"><a href="#0-3-相关概念" class="headerlink" title="0.3 相关概念"></a>0.3 相关概念</h3><p>稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。<br>不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。<br>时间复杂度：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。<br>空间复杂度：是指算法在计算机<br>内执行时所需存储空间的度量，它也是数据规模n的函数。</p>
<h4 id="1、冒泡排序（Bubble-Sort）"><a href="#1、冒泡排序（Bubble-Sort）" class="headerlink" title="1、冒泡排序（Bubble Sort）"></a>1、冒泡排序（Bubble Sort）</h4><p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p>
<h5 id="1-1-算法描述"><a href="#1-1-算法描述" class="headerlink" title="1.1 算法描述"></a>1.1 算法描述</h5><p>比较相邻的元素。如果第一个比第二个大，就交换它们两个；<br>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；<br>针对所有的元素重复以上的步骤，除了最后一个；<br>重复步骤1~3，直到排序完成。</p>
<h5 id="1-2-动图演示"><a href="#1-2-动图演示" class="headerlink" title="1.2 动图演示"></a>1.2 动图演示</h5><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/20200527161331622.gif" alt="在这里插入图片描述"></p>
<h5 id="1-3-代码实现"><a href="#1-3-代码实现" class="headerlink" title="1.3 代码实现"></a>1.3 代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function <span class="title function_">bubbleSort</span><span class="params">(arr)</span> &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">len</span> <span class="operator">=</span> arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">var</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;        <span class="comment">// 相邻元素两两对比</span></span><br><span class="line">                <span class="type">var</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j+<span class="number">1</span>];        <span class="comment">// 元素交换</span></span><br><span class="line">                arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">                arr[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213</span></span><br></pre></td></tr></table></figure>
<h4 id="2、选择排序（Selection-Sort）"><a href="#2、选择排序（Selection-Sort）" class="headerlink" title="2、选择排序（Selection Sort）"></a>2、选择排序（Selection Sort）</h4><p>选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
<h5 id="2-1-算法描述"><a href="#2-1-算法描述" class="headerlink" title="2.1 算法描述"></a>2.1 算法描述</h5><p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p>
<p>初始状态：无序区为R[1…n]，有序区为空；<br>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1…i-1]和R(i…n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1…i]和R[i+1…n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；<br>n-1趟结束，数组有序化了。</p>
<h5 id="2-2-动图演示"><a href="#2-2-动图演示" class="headerlink" title="2.2 动图演示"></a>2.2 动图演示</h5><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/20200527161414912.gif" alt="在这里插入图片描述"></p>
<h5 id="2-3-代码实现"><a href="#2-3-代码实现" class="headerlink" title="2.3 代码实现"></a>2.3 代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function <span class="title function_">selectionSort</span><span class="params">(arr)</span> &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">len</span> <span class="operator">=</span> arr.length;</span><br><span class="line">    <span class="keyword">var</span> minIndex, temp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">var</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;     <span class="comment">// 寻找最小的数</span></span><br><span class="line">                minIndex = j;                 <span class="comment">// 将最小数的索引保存</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = arr[i];</span><br><span class="line">        arr[i] = arr[minIndex];</span><br><span class="line">        arr[minIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125; </span><br><span class="line"><span class="number">12345678910111213141516</span></span><br></pre></td></tr></table></figure>
<h5 id="2-4-算法分析"><a href="#2-4-算法分析" class="headerlink" title="2.4 算法分析"></a>2.4 算法分析</h5><p>表现最稳定的排序算法之一，因为无论什么数据进去都是O(n2)的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。</p>
<h4 id="3、插入排序（Insertion-Sort）"><a href="#3、插入排序（Insertion-Sort）" class="headerlink" title="3、插入排序（Insertion Sort）"></a>3、插入排序（Insertion Sort）</h4><p>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>
<h5 id="3-1-算法描述"><a href="#3-1-算法描述" class="headerlink" title="3.1 算法描述"></a>3.1 算法描述</h5><p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p>
<p>从第一个元素开始，该元素可以认为已经被排序；<br>取出下一个元素，在已经排序的元素序列中从后向前扫描；<br>如果该元素（已排序）大于新元素，将该元素移到下一位置；<br>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；<br>将新元素插入到该位置后；<br>重复步骤2~5。</p>
<h5 id="3-2-动图演示"><a href="#3-2-动图演示" class="headerlink" title="3.2 动图演示"></a>3.2 动图演示</h5><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvODQ5NTg5LzIwMTcxMC84NDk1ODktMjAxNzEwMTUyMjU2NDUyNzctMTE1MTEwMDAwMC5naWY" alt="在这里插入图片描述"></p>
<h5 id="3-2-代码实现"><a href="#3-2-代码实现" class="headerlink" title="3.2 代码实现"></a>3.2 代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function <span class="title function_">insertionSort</span><span class="params">(arr)</span> &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">len</span> <span class="operator">=</span> arr.length;</span><br><span class="line">    <span class="keyword">var</span> preIndex, current;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        preIndex = i - <span class="number">1</span>;</span><br><span class="line">        current = arr[i];</span><br><span class="line">        <span class="keyword">while</span> (preIndex &gt;= <span class="number">0</span> &amp;&amp; arr[preIndex] &gt; current) &#123;</span><br><span class="line">            arr[preIndex + <span class="number">1</span>] = arr[preIndex];</span><br><span class="line">            preIndex--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[preIndex + <span class="number">1</span>] = current;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314</span></span><br></pre></td></tr></table></figure>
<h5 id="3-4-算法分析"><a href="#3-4-算法分析" class="headerlink" title="3.4 算法分析"></a>3.4 算法分析</h5><p>插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p>
<h4 id="4、希尔排序（Shell-Sort）"><a href="#4、希尔排序（Shell-Sort）" class="headerlink" title="4、希尔排序（Shell Sort）"></a>4、希尔排序（Shell Sort）</h4><p>1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。</p>
<h5 id="4-1-算法描述"><a href="#4-1-算法描述" class="headerlink" title="4.1 算法描述"></a>4.1 算法描述</h5><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p>
<p>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；<br>按增量序列个数k，对序列进行k 趟排序；<br>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p>
<h5 id="4-2-动图演示"><a href="#4-2-动图演示" class="headerlink" title="4.2 动图演示"></a>4.2 动图演示</h5><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvODQ5NTg5LzIwMTgwMy84NDk1ODktMjAxODAzMzExNzAwMTc0MjEtMzY0NTA2MDczLmdpZg" alt="在这里插入图片描述"></p>
<h5 id="4-3-代码实现"><a href="#4-3-代码实现" class="headerlink" title="4.3 代码实现"></a>4.3 代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function <span class="title function_">shellSort</span><span class="params">(arr)</span> &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">len</span> <span class="operator">=</span> arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">var</span> <span class="variable">gap</span> <span class="operator">=</span> Math.floor(len / <span class="number">2</span>); gap &gt; <span class="number">0</span>; gap = Math.floor(gap / <span class="number">2</span>)) &#123;</span><br><span class="line">        <span class="comment">// 注意：这里和动图演示的不一样，动图是分组执行，实际操作是多个分组交替执行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> gap; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="type">var</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="type">var</span> <span class="variable">current</span> <span class="operator">=</span> arr[i];</span><br><span class="line">            <span class="keyword">while</span> (j - gap &gt;= <span class="number">0</span> &amp;&amp; current &lt; arr[j - gap]) &#123;</span><br><span class="line">                 arr[j] = arr[j - gap];</span><br><span class="line">                 j = j - gap;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j] = current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516</span></span><br></pre></td></tr></table></figure>
<h5 id="4-4-算法分析"><a href="#4-4-算法分析" class="headerlink" title="4.4 算法分析"></a>4.4 算法分析</h5><p>希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。动态定义间隔序列的算法是《算法（第4版）》的合著者Robert Sedgewick提出的。</p>
<h4 id="5、归并排序（Merge-Sort）"><a href="#5、归并排序（Merge-Sort）" class="headerlink" title="5、归并排序（Merge Sort）"></a>5、归并排序（Merge Sort）</h4><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。</p>
<h5 id="5-1-算法描述"><a href="#5-1-算法描述" class="headerlink" title="5.1 算法描述"></a>5.1 算法描述</h5><p>把长度为n的输入序列分成两个长度为n/2的子序列；<br>对这两个子序列分别采用归并排序；<br>将两个排序好的子序列合并成一个最终的排序序列。</p>
<h5 id="5-2-动图演示"><a href="#5-2-动图演示" class="headerlink" title="5.2 动图演示"></a>5.2 动图演示</h5><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvODQ5NTg5LzIwMTcxMC84NDk1ODktMjAxNzEwMTUyMzA1NTcwNDMtMzczNzUwMTAuZ2lm" alt="在这里插入图片描述"></p>
<h5 id="5-3-代码实现"><a href="#5-3-代码实现" class="headerlink" title="5.3 代码实现"></a>5.3 代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">function <span class="title function_">mergeSort</span><span class="params">(arr)</span> &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">len</span> <span class="operator">=</span> arr.length;</span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">var</span> <span class="variable">middle</span> <span class="operator">=</span> Math.floor(len / <span class="number">2</span>),</span><br><span class="line">        left = arr.slice(<span class="number">0</span>, middle),</span><br><span class="line">        right = arr.slice(middle);</span><br><span class="line">    <span class="keyword">return</span> merge(mergeSort(left), mergeSort(right));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">function <span class="title function_">merge</span><span class="params">(left, right)</span> &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">result</span> <span class="operator">=</span> [];</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (left.length&gt;<span class="number">0</span> &amp;&amp; right.length&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (left[<span class="number">0</span>] &lt;= right[<span class="number">0</span>]) &#123;</span><br><span class="line">            result.push(left.shift());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.push(right.shift());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (left.length)</span><br><span class="line">        result.push(left.shift());</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (right.length)</span><br><span class="line">        result.push(right.shift());</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930</span></span><br></pre></td></tr></table></figure>
<h5 id="5-4-算法分析"><a href="#5-4-算法分析" class="headerlink" title="5.4 算法分析"></a>5.4 算法分析</h5><p>归并排序是一种稳定的排序方法。和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(nlogn）的时间复杂度。代价是需要额外的内存空间。</p>
<h4 id="6、快速排序（Quick-Sort）"><a href="#6、快速排序（Quick-Sort）" class="headerlink" title="6、快速排序（Quick Sort）"></a>6、快速排序（Quick Sort）</h4><p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p>
<h5 id="6-1-算法描述"><a href="#6-1-算法描述" class="headerlink" title="6.1 算法描述"></a>6.1 算法描述</h5><p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p>
<p>从数列中挑出一个元素，称为 “基准”（pivot）；<br>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；<br>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</p>
<h5 id="6-2-动图演示"><a href="#6-2-动图演示" class="headerlink" title="6.2 动图演示"></a>6.2 动图演示</h5><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvODQ5NTg5LzIwMTcxMC84NDk1ODktMjAxNzEwMTUyMzA5MzYzNzEtMTQxMzUyMzQxMi5naWY" alt="在这里插入图片描述"></p>
<h5 id="6-3-代码实现"><a href="#6-3-代码实现" class="headerlink" title="6.3 代码实现"></a>6.3 代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">function <span class="title function_">quickSort</span><span class="params">(arr, left, right)</span> &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">len</span> <span class="operator">=</span> arr.length,</span><br><span class="line">        partitionIndex,</span><br><span class="line">        left = typeof left != <span class="string">&#x27;number&#x27;</span> ? <span class="number">0</span> : left,</span><br><span class="line">        right = typeof right != <span class="string">&#x27;number&#x27;</span> ? len - <span class="number">1</span> : right;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        partitionIndex = partition(arr, left, right);</span><br><span class="line">        quickSort(arr, left, partitionIndex-<span class="number">1</span>);</span><br><span class="line">        quickSort(arr, partitionIndex+<span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">function <span class="title function_">partition</span><span class="params">(arr, left ,right)</span> &#123;     <span class="comment">// 分区操作</span></span><br><span class="line">    <span class="type">var</span> <span class="variable">pivot</span> <span class="operator">=</span> left,                      <span class="comment">// 设定基准值（pivot）</span></span><br><span class="line">        index = pivot + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> index; i &lt;= right; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; arr[pivot]) &#123;</span><br><span class="line">            swap(arr, i, index);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, pivot, index - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> index-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">function <span class="title function_">swap</span><span class="params">(arr, i, j)</span> &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920212223242526272829303132</span></span><br></pre></td></tr></table></figure>
<h4 id="7、堆排序（Heap-Sort）"><a href="#7、堆排序（Heap-Sort）" class="headerlink" title="7、堆排序（Heap Sort）"></a>7、堆排序（Heap Sort）</h4><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p>
<h5 id="7-1-算法描述"><a href="#7-1-算法描述" class="headerlink" title="7.1 算法描述"></a>7.1 算法描述</h5><p>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；<br>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；<br>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</p>
<h5 id="7-2-动图演示"><a href="#7-2-动图演示" class="headerlink" title="7.2 动图演示"></a>7.2 动图演示</h5><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvODQ5NTg5LzIwMTcxMC84NDk1ODktMjAxNzEwMTUyMzEzMDg2OTktMzU2MTM0MjM3LmdpZg" alt="在这里插入图片描述"></p>
<h5 id="7-3-代码实现"><a href="#7-3-代码实现" class="headerlink" title="7.3 代码实现"></a>7.3 代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> len;    <span class="comment">// 因为声明的多个函数都需要数据长度，所以把len设置成为全局变量</span></span><br><span class="line"> </span><br><span class="line">function <span class="title function_">buildMaxHeap</span><span class="params">(arr)</span> &#123;   <span class="comment">// 建立大顶堆</span></span><br><span class="line">    len = arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> Math.floor(len/<span class="number">2</span>); i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        heapify(arr, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">function <span class="title function_">heapify</span><span class="params">(arr, i)</span> &#123;     <span class="comment">// 堆调整</span></span><br><span class="line">    <span class="type">var</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">1</span>,</span><br><span class="line">        right = <span class="number">2</span> * i + <span class="number">2</span>,</span><br><span class="line">        largest = i;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123;</span><br><span class="line">        largest = left;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123;</span><br><span class="line">        largest = right;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">        swap(arr, i, largest);</span><br><span class="line">        heapify(arr, largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">function <span class="title function_">swap</span><span class="params">(arr, i, j)</span> &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">function <span class="title function_">heapSort</span><span class="params">(arr)</span> &#123;</span><br><span class="line">    buildMaxHeap(arr);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> arr.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        swap(arr, <span class="number">0</span>, i);</span><br><span class="line">        len--;</span><br><span class="line">        heapify(arr, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920212223242526272829303132333435363738394041424344</span></span><br></pre></td></tr></table></figure>
<h4 id="8、计数排序（Counting-Sort）"><a href="#8、计数排序（Counting-Sort）" class="headerlink" title="8、计数排序（Counting Sort）"></a>8、计数排序（Counting Sort）</h4><p>计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>
<h5 id="8-1-算法描述"><a href="#8-1-算法描述" class="headerlink" title="8.1 算法描述"></a>8.1 算法描述</h5><p>找出待排序的数组中最大和最小的元素；<br>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；<br>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；<br>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</p>
<h5 id="8-2-动图演示"><a href="#8-2-动图演示" class="headerlink" title="8.2 动图演示"></a>8.2 动图演示</h5><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvODQ5NTg5LzIwMTcxMC84NDk1ODktMjAxNzEwMTUyMzE3NDA4NDAtNjk2ODE4MS5naWY" alt="在这里插入图片描述"></p>
<h5 id="8-3-代码实现"><a href="#8-3-代码实现" class="headerlink" title="8.3 代码实现"></a>8.3 代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function <span class="title function_">countingSort</span><span class="params">(arr, maxValue)</span> &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">bucket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Array</span>(maxValue + <span class="number">1</span>),</span><br><span class="line">        sortedIndex = <span class="number">0</span>;</span><br><span class="line">        arrLen = arr.length,</span><br><span class="line">        bucketLen = maxValue + <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arrLen; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!bucket[arr[i]]) &#123;</span><br><span class="line">            bucket[arr[i]] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        bucket[arr[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">var</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; bucketLen; j++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(bucket[j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            arr[sortedIndex++] = j;</span><br><span class="line">            bucket[j]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122</span></span><br></pre></td></tr></table></figure>
<h5 id="8-4-算法分析"><a href="#8-4-算法分析" class="headerlink" title="8.4 算法分析"></a>8.4 算法分析</h5><p>计数排序是一个稳定的排序算法。当输入的元素是 n 个 0到 k 之间的整数时，时间复杂度是O(n+k)，空间复杂度也是O(n+k)，其排序速度快于任何比较排序算法。当k不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。</p>
<h4 id="9、桶排序（Bucket-Sort）"><a href="#9、桶排序（Bucket-Sort）" class="headerlink" title="9、桶排序（Bucket Sort）"></a>9、桶排序（Bucket Sort）</h4><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。</p>
<h5 id="9-1-算法描述"><a href="#9-1-算法描述" class="headerlink" title="9.1 算法描述"></a>9.1 算法描述</h5><p>设置一个定量的数组当作空桶；<br>遍历输入数据，并且把数据一个一个放到对应的桶里去；<br>对每个不是空的桶进行排序；<br>从不是空的桶里把排好序的数据拼接起来。<br>9.2 图片演示<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/20200527162046850.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTU0ODkxMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h5 id="9-3-代码实现"><a href="#9-3-代码实现" class="headerlink" title="9.3 代码实现"></a>9.3 代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">function <span class="title function_">bucketSort</span><span class="params">(arr, bucketSize)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">var</span> i;</span><br><span class="line">    <span class="type">var</span> <span class="variable">minValue</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">    <span class="type">var</span> <span class="variable">maxValue</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[i] &lt; minValue) &#123;</span><br><span class="line">          minValue = arr[i];                <span class="comment">// 输入数据的最小值</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &gt; maxValue) &#123;</span><br><span class="line">          maxValue = arr[i];                <span class="comment">// 输入数据的最大值</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 桶的初始化</span></span><br><span class="line">    <span class="type">var</span> <span class="variable">DEFAULT_BUCKET_SIZE</span> <span class="operator">=</span> <span class="number">5</span>;            <span class="comment">// 设置桶的默认数量为5</span></span><br><span class="line">    bucketSize = bucketSize || DEFAULT_BUCKET_SIZE;</span><br><span class="line">    <span class="type">var</span> <span class="variable">bucketCount</span> <span class="operator">=</span> Math.floor((maxValue - minValue) / bucketSize) + <span class="number">1</span>;  </span><br><span class="line">    <span class="type">var</span> <span class="variable">buckets</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Array</span>(bucketCount);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; buckets.length; i++) &#123;</span><br><span class="line">        buckets[i] = [];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 利用映射函数将数据分配到各个桶中</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        buckets[Math.floor((arr[i] - minValue) / bucketSize)].push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    arr.length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; buckets.length; i++) &#123;</span><br><span class="line">        insertionSort(buckets[i]);                      <span class="comment">// 对每个桶进行排序，这里使用了插入排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">var</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; buckets[i].length; j++) &#123;</span><br><span class="line">            arr.push(buckets[i][j]);                     </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="9-4-算法分析"><a href="#9-4-算法分析" class="headerlink" title="9.4 算法分析"></a>9.4 算法分析</h5><p>桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。</p>
<h4 id="10、基数排序（Radix-Sort）"><a href="#10、基数排序（Radix-Sort）" class="headerlink" title="10、基数排序（Radix Sort）"></a>10、基数排序（Radix Sort）</h4><p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p>
<h5 id="10-1-算法描述"><a href="#10-1-算法描述" class="headerlink" title="10.1 算法描述"></a>10.1 算法描述</h5><p>取得数组中的最大数，并取得位数；<br>arr为原始数组，从最低位开始取每个位组成radix数组；<br>对radix进行计数排序（利用计数排序适用于小范围数的特点）；</p>
<h5 id="10-2-动图演示"><a href="#10-2-动图演示" class="headerlink" title="10.2 动图演示"></a>10.2 动图演示</h5><h5 id="10-3-代码实现"><a href="#10-3-代码实现" class="headerlink" title="10.3 代码实现"></a>10.3 代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">counter</span> <span class="operator">=</span> [];</span><br><span class="line">function <span class="title function_">radixSort</span><span class="params">(arr, maxDigit)</span> &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">mod</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">var</span> <span class="variable">dev</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; maxDigit; i++, dev *= <span class="number">10</span>, mod *= <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">var</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="type">var</span> <span class="variable">bucket</span> <span class="operator">=</span> parseInt((arr[j] % mod) / dev);</span><br><span class="line">            <span class="keyword">if</span>(counter[bucket]==<span class="literal">null</span>) &#123;</span><br><span class="line">                counter[bucket] = [];</span><br><span class="line">            &#125;</span><br><span class="line">            counter[bucket].push(arr[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">var</span> <span class="variable">pos</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">var</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; counter.length; j++) &#123;</span><br><span class="line">            <span class="type">var</span> <span class="variable">value</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span>(counter[j]!=<span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> ((value = counter[j].shift()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                      arr[pos++] = value;</span><br><span class="line">                &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324</span></span><br></pre></td></tr></table></figure>
<h5 id="10-4-算法分析"><a href="#10-4-算法分析" class="headerlink" title="10.4 算法分析"></a>10.4 算法分析</h5><p>基数排序基于分别排序，分别收集，所以是稳定的。但基数排序的性能比桶排序要略差，每一次关键字的桶分配都需要O(n)的时间复杂度，而且分配之后得到新的关键字序列又需要O(n)的时间复杂度。假如待排数据可以分为d个关键字，则基数排序的时间复杂度将是O(d*2n) ，当然d要远远小于n，因此基本上还是线性级别的。</p>
<p>基数排序的空间复杂度为O(n+k)，其中k为桶的数量。一般来说n&gt;&gt;k，因此额外空间需要大概n个左右。</p>
<h1 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h1><h1 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h1><h1 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h1><h1 id="背包"><a href="#背包" class="headerlink" title="背包"></a>背包</h1><h2 id="1-01背包"><a href="#1-01背包" class="headerlink" title="1.01背包"></a>1.01背包</h2><h2 id="2-完全背包"><a href="#2-完全背包" class="headerlink" title="2.完全背包"></a>2.完全背包</h2><h2 id="3-多重背包之暴力拆分法"><a href="#3-多重背包之暴力拆分法" class="headerlink" title="3.多重背包之暴力拆分法"></a>3.多重背包之暴力拆分法</h2><h2 id="4-多重背包之二进制拆分"><a href="#4-多重背包之二进制拆分" class="headerlink" title="4.多重背包之二进制拆分"></a>4.多重背包之二进制拆分</h2><h2 id="5-二维费用背包问题"><a href="#5-二维费用背包问题" class="headerlink" title="5.二维费用背包问题"></a>5.二维费用背包问题</h2><h2 id="6-分组背包问题"><a href="#6-分组背包问题" class="headerlink" title="6.分组背包问题"></a>6.分组背包问题</h2><h2 id="7-有依赖的背包问题"><a href="#7-有依赖的背包问题" class="headerlink" title="7.有依赖的背包问题"></a>7.有依赖的背包问题</h2><h2 id="8-多重背包队列优化"><a href="#8-多重背包队列优化" class="headerlink" title="8.多重背包队列优化"></a>8.多重背包队列优化</h2><h1 id="istream-iterator"><a href="#istream-iterator" class="headerlink" title="istream_iterator"></a>istream_iterator</h1><h1 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h1><h1 id="指针算法"><a href="#指针算法" class="headerlink" title="指针算法"></a>指针算法</h1><h1 id="c-自带算法"><a href="#c-自带算法" class="headerlink" title="c++自带算法"></a>c++自带算法</h1><p><strong>C++ 标准模板库 (STL, Standard Template Library)</strong>：包含一些常用数据结构与算法的模板的 C++ 软件库。其包含四个组件——算法 (Algorithms)、容器 (Containers)、仿函数 (Functors)、迭代器 (Iterators).</p>
<p>示例：</p>
<ul>
<li>算法：<code>sort(a.begin(), a.end())</code></li>
<li>容器：<code>priority_queue&lt;int&gt; pque</code></li>
<li>仿函数：<code>greater&lt;int&gt;()</code></li>
<li>迭代器：<code>vector&lt;int&gt;::iterator it = a.begin()</code></li>
</ul>
<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>STL 作为一个封装良好，性能合格的 C++ 标准库，在算法竞赛中运用极其常见。灵活且正确使用 STL 可以节省非常多解题时间，这一点不仅是由于可以直接调用，还是因为它封装良好，可以让代码的可读性变高，解题思路更清晰，调试过程 <del>往往</del> 更顺利。</p>
<p>不过 STL 毕竟使用了很多复杂的结构来实现丰富的功能，它的效率往往是比不上自己手搓针对特定题目的数据结构与算法的。因此，STL 的使用相当于使用更长的运行时间换取更高的编程效率。因此，在实际比赛中要权衡 STL 的利弊，不过这一点就得靠经验了。</p>
<p>接下来，我会分享在算法竞赛中常用的 STL 容器和算法，对于函数和迭代器，就不着重展开讲了。</p>
<h2 id="2-常用容器"><a href="#2-常用容器" class="headerlink" title="2 常用容器"></a>2 常用容器</h2><h2 id="2-1-内容总览"><a href="#2-1-内容总览" class="headerlink" title="2.1 内容总览"></a>2.1 内容总览</h2><p>打勾的是本次将会详细讲解的，加粗的是算法竞赛中有必要学习的。</p>
<ul>
<li>顺序容器<ul>
<li>[ ] <strong>array</strong></li>
<li>[x] <strong>vector</strong></li>
<li>[ ] <strong>deque</strong></li>
<li>[ ] forward_list</li>
<li>[ ] <strong>list</strong></li>
</ul>
</li>
<li>关联容器<ul>
<li>[x] <strong>set</strong></li>
<li>[x] <strong>map</strong></li>
<li>[ ] <strong>multiset</strong></li>
<li>[ ] <strong>multimap</strong></li>
</ul>
</li>
<li>无序关联容器<ul>
<li>[ ] <strong>unordered_set</strong></li>
<li>[ ] <strong>unordered_map</strong></li>
<li>[ ] <strong>unordered_multiset</strong></li>
<li>[ ] <strong>unordered_multimap</strong></li>
</ul>
</li>
<li>容器适配器<ul>
<li>[x] <strong>stack</strong></li>
<li>[x] <strong>queue</strong></li>
<li>[x] <strong>priority_queue</strong></li>
<li>[ ] flat_set</li>
<li>[ ] flat_map</li>
<li>[ ] flat_multiset</li>
<li>[ ] flat_multimap</li>
</ul>
</li>
<li>字符串<ul>
<li>[x] <strong>string</strong> (basic_string\<char\>)</li>
</ul>
</li>
<li>对与元组<ul>
<li>[x] <strong>pair</strong></li>
<li>[ ] <strong>tuple</strong></li>
</ul>
</li>
</ul>
<h2 id="2-2-向量-vector"><a href="#2-2-向量-vector" class="headerlink" title="2.2 向量 vector"></a>2.2 向量 <a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/container/vector">vector</a></h2><p><strong><code>#include &lt;vector&gt;</code></strong></p>
<p>连续的顺序的储存结构（和数组一样的类别），但是有长度可变的特性。</p>
<h3 id="2-2-1-常用方法"><a href="#2-2-1-常用方法" class="headerlink" title="2.2.1 常用方法"></a>2.2.1 常用方法</h3><h4 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h4><p><strong><code>vector&lt;类型&gt; arr(长度, [初值])</code></strong></p>
<p>时间复杂度：O(n)</p>
<p>常用的一维和二维数组构造示例，高维也是一样的（就是会有点长）.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; arr;         <span class="comment">// 构造int数组</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(<span class="number">100</span>)</span></span>;    <span class="comment">// 构造初始长100的int数组</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(<span class="number">100</span>, <span class="number">1</span>)</span></span>; <span class="comment">// 构造初始长100的int数组，初值为1</span></span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">mat</span>(<span class="number">100</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; ());       <span class="comment">// 构造初始100行，不指定列数的二维数组</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">mat</span>(<span class="number">100</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (<span class="number">666</span>, <span class="number">-1</span>)) <span class="comment">// 构造初始100行，初始666列的二维数组，初值为-1</span></span><br></pre></td></tr></table></figure>
<p>构造二维数组的奇葩写法，千万别用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; arr[<span class="number">100</span>];         <span class="comment">// 正确，构造初始100行，不指定列数的二维数组，可用于链式前向星存图</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; arr[<span class="number">100</span>](<span class="number">100</span>, <span class="number">1</span>); <span class="comment">// 语法错误！</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(<span class="number">100</span>, <span class="number">1</span>)</span>[100]</span>; <span class="comment">// 语法错误！</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; arr[<span class="number">100</span>] &#123;&#123;<span class="number">100</span>, <span class="number">1</span>&#125;, 这里省略<span class="number">98</span>个 ,&#123;<span class="number">100</span>, <span class="number">1</span>&#125;&#125;; <span class="comment">// 正确但奇葩，使用列表初始化</span></span><br></pre></td></tr></table></figure>
<h4 id="尾接-amp-尾删"><a href="#尾接-amp-尾删" class="headerlink" title="尾接 &amp; 尾删"></a>尾接 &amp; 尾删</h4><ul>
<li><strong><code>.push_back(元素)</code></strong>：在 vector 尾接一个元素，数组长度 +1+1.</li>
<li><strong><code>.pop_back()</code></strong>：删除 vector 尾部的一个元素，数组长度 −1−1</li>
</ul>
<p>时间复杂度：均摊 O(1)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// init: arr = []</span></span><br><span class="line">arr.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// after: arr = [1]</span></span><br><span class="line">arr.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// after: arr = [1, 2]</span></span><br><span class="line">arr.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="comment">// after: arr = [1]</span></span><br><span class="line">arr.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="comment">// after: arr = []</span></span><br></pre></td></tr></table></figure>
<h4 id="中括号运算符"><a href="#中括号运算符" class="headerlink" title="中括号运算符"></a>中括号运算符</h4><p>和一般数组一样的作用</p>
<p>时间复杂度：O(1)</p>
<h4 id="获取长度"><a href="#获取长度" class="headerlink" title="获取长度"></a>获取长度</h4><p><strong><code>.size()</code></strong></p>
<p>获取当前 vector 的长度</p>
<p>时间复杂度：O(1)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++)</span><br><span class="line">    cout &lt;&lt; a[i] &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h4 id="清空"><a href="#清空" class="headerlink" title="清空"></a>清空</h4><p><strong><code>.clear()</code></strong></p>
<p>清空 vector</p>
<p>时间复杂度：O(n)</p>
<h4 id="判空"><a href="#判空" class="headerlink" title="判空"></a>判空</h4><p><strong><code>.empty()</code></strong></p>
<p>如果是空返回 <code>true</code> 反之返回 <code>false</code>.</p>
<p>时间复杂度：O(1)</p>
<h4 id="改变长度"><a href="#改变长度" class="headerlink" title="改变长度"></a>改变长度</h4><p><strong><code>.resize(新长度, [默认值])</code></strong></p>
<p>修改 vector 的长度</p>
<ul>
<li>如果是缩短，则删除多余的值</li>
<li>如果是扩大，且指定了默认值，则新元素均为默认值<strong>（旧元素不变）</strong></li>
</ul>
<p>时间复杂度：O(n)</p>
<h3 id="2-2-2-适用情形"><a href="#2-2-2-适用情形" class="headerlink" title="2.2.2 适用情形"></a>2.2.2 适用情形</h3><p>一般情况 <code>vector</code> 可以替换掉普通数组，除非该题卡常。</p>
<p>有些情况普通数组没法解决：n×m 的矩阵，1≤n,m≤1061≤ 且 n×m≤106</p>
<ul>
<li>如果用普通数组 <code>int mat[1000010][1000010]</code>，浪费内存，会导致 MLE。</li>
<li>如果使用 <code>vector&lt;vector&lt;int&gt;&gt; mat(n + 10, vector&lt;int&gt; (m + 10))</code>，完美解决该问题。</li>
</ul>
<p>另外，<code>vector</code> 的数据储存在堆空间中，不会爆栈。</p>
<h3 id="2-2-3-注意事项"><a href="#2-2-3-注意事项" class="headerlink" title="2.2.3 注意事项"></a>2.2.3 注意事项</h3><h4 id="提前指定长度"><a href="#提前指定长度" class="headerlink" title="提前指定长度"></a>提前指定长度</h4><p>如果长度已经确定，那么应当直接在构造函数指定长度，而不是一个一个 <code>.push_back()</code>. 因为 <code>vector</code> 额外内存耗尽后的重分配是有时间开销的，直接指定长度就不会出现重分配了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优化前: 522ms</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1e8</span>; i++)</span><br><span class="line">    a.<span class="built_in">push_back</span>(i);</span><br><span class="line"><span class="comment">// 优化后: 259ms</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">1e8</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++)</span><br><span class="line">    a[i] = i;</span><br></pre></td></tr></table></figure>
<h4 id="当心-size-t-溢出"><a href="#当心-size-t-溢出" class="headerlink" title="当心 size_t 溢出"></a>当心 size_t 溢出</h4><p>vector 获取长度的方法 <code>.size()</code> 返回值类型为 <code>size_t</code>，通常 OJ 平台使用的是 32 位编译器（有些平台例如 cf 可选 64 位），那么该类型范围为 [0,232)[0,232).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">65536</span>)</span></span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> a = a.<span class="built_in">size</span>() * a.<span class="built_in">size</span>(); <span class="comment">// 直接溢出变成0了</span></span><br></pre></td></tr></table></figure>
<h2 id="2-3-栈-stack"><a href="#2-3-栈-stack" class="headerlink" title="2.3 栈 stack"></a>2.3 栈 <a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/container/stack">stack</a></h2><p><strong><code>#include &lt;stack&gt;</code></strong></p>
<p>通过二次封装双端队列 (deque) 容器，实现先进后出的栈数据结构。</p>
<h3 id="2-3-1-常用方法"><a href="#2-3-1-常用方法" class="headerlink" title="2.3.1 常用方法"></a>2.3.1 常用方法</h3><div class="table-container">
<table>
<thead>
<tr>
<th>作用</th>
<th>用法</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>构造</td>
<td><code>stack&lt;类型&gt; stk</code></td>
<td><code>stack&lt;int&gt; stk;</code></td>
</tr>
<tr>
<td>进栈</td>
<td><code>.push(元素)</code></td>
<td><code>stk.push(1);</code></td>
</tr>
<tr>
<td>出栈</td>
<td><code>.pop()</code></td>
<td><code>stk.pop();</code></td>
</tr>
<tr>
<td>取栈顶</td>
<td><code>.top()</code></td>
<td><code>int a = stk.top();</code></td>
</tr>
<tr>
<td>查看大小 / 清空 / 判空</td>
<td>略</td>
<td>略</td>
</tr>
</tbody>
</table>
</div>
<h3 id="2-3-2-适用情形"><a href="#2-3-2-适用情形" class="headerlink" title="2.3.2 适用情形"></a>2.3.2 适用情形</h3><p>如果不卡常的话，就可以直接用它而不需要手写栈了。</p>
<p>另外，vector 也可以当栈用，vector 的 <code>.back()</code> 取尾部元素，就相当于取栈顶，<code>.push_back()</code> 相当于进栈，<code>.pop_back()</code> 相当于出栈。</p>
<h3 id="2-3-3-注意事项"><a href="#2-3-3-注意事项" class="headerlink" title="2.3.3 注意事项"></a>2.3.3 注意事项</h3><p>不可访问内部元素！<strong>下面都是错误用法</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; stk.<span class="built_in">size</span>(); i++)</span><br><span class="line">    cout &lt;&lt; stk[i] &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> ele : stk)</span><br><span class="line">    cout &lt;&lt; stk &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h2 id="2-4-队列-queue"><a href="#2-4-队列-queue" class="headerlink" title="2.4 队列 queue"></a>2.4 队列 <a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/container/queue">queue</a></h2><p><strong><code>#include &lt;queue&gt;</code></strong></p>
<p>通过二次封装双端队列 (deque) 容器，实现先进先出的队列数据结构。</p>
<h3 id="2-4-1-常用方法"><a href="#2-4-1-常用方法" class="headerlink" title="2.4.1 常用方法"></a>2.4.1 常用方法</h3><div class="table-container">
<table>
<thead>
<tr>
<th>作用</th>
<th>用法</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>构造</td>
<td><code>queue&lt;类型&gt; que</code></td>
<td><code>queue&lt;int&gt; que;</code></td>
</tr>
<tr>
<td>进队</td>
<td><code>.push(元素)</code></td>
<td><code>que.push(1);</code></td>
</tr>
<tr>
<td>出队</td>
<td><code>.pop()</code></td>
<td><code>que.pop();</code></td>
</tr>
<tr>
<td>取队首</td>
<td><code>.front()</code></td>
<td><code>int a = que.front();</code></td>
</tr>
<tr>
<td>取队尾</td>
<td><code>.back()</code></td>
<td><code>int a = que.back();</code></td>
</tr>
<tr>
<td>查看大小 / 清空 / 判空</td>
<td>略</td>
<td>略</td>
</tr>
</tbody>
</table>
</div>
<h3 id="2-4-2-适用情形"><a href="#2-4-2-适用情形" class="headerlink" title="2.4.2 适用情形"></a>2.4.2 适用情形</h3><p>如果不卡常的话，就可以直接用它而不需要手写队列了。</p>
<h3 id="2-4-3-注意事项"><a href="#2-4-3-注意事项" class="headerlink" title="2.4.3 注意事项"></a>2.4.3 注意事项</h3><p>不可访问内部元素！<strong>下面都是错误用法</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; que.<span class="built_in">size</span>(); i++)</span><br><span class="line">    cout &lt;&lt; que[i] &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> ele : que)</span><br><span class="line">    cout &lt;&lt; ele &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h2 id="2-5-优先队列-priority-queue"><a href="#2-5-优先队列-priority-queue" class="headerlink" title="2.5 优先队列 priority_queue"></a>2.5 优先队列 <a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/container/priority_queue">priority_queue</a></h2><p><strong><code>#include &lt;queue&gt;</code></strong></p>
<p>提供常数时间的最大元素查找，对数时间的插入与提取，底层原理是二叉堆。</p>
<h3 id="2-5-1-常用方法"><a href="#2-5-1-常用方法" class="headerlink" title="2.5.1 常用方法"></a>2.5.1 常用方法</h3><h4 id="构造-1"><a href="#构造-1" class="headerlink" title="构造"></a>构造</h4><p><strong><code>priority_queue&lt;类型, 容器, 比较器&gt; pque</code></strong></p>
<ul>
<li>类型：要储存的数据类型</li>
<li>容器：储存数据的底层容器，默认为 <code>vector&lt;类型&gt;</code>，竞赛中保持默认即可</li>
<li>比较器：比较大小使用的比较器，默认为 <code>less&lt;类型&gt;</code>，可自定义</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>&gt; pque1;                            <span class="comment">// 储存int的大顶堆</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; pque2; <span class="comment">// 储存int的小顶堆</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于需要自定义比较器的情况，涉及一些初学时容易看迷糊的语法（重载小括号运算符 / lambda 表达式），在此就不展开讲了。如果想要了解，可以查阅 cppreference 中的代码示例。</p>
</blockquote>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><div class="table-container">
<table>
<thead>
<tr>
<th>作用</th>
<th>用法</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>进堆</td>
<td><code>.push(元素)</code></td>
<td><code>que.push(1);</code></td>
</tr>
<tr>
<td>出堆</td>
<td><code>.pop()</code></td>
<td><code>que.pop();</code></td>
</tr>
<tr>
<td>取堆顶</td>
<td><code>.top()</code></td>
<td><code>int a = que.top();</code></td>
</tr>
<tr>
<td>查看大小 / 判空</td>
<td>略</td>
<td>略</td>
</tr>
</tbody>
</table>
</div>
<p>进出队复杂度 O(logn)，取堆顶 O(1).</p>
<h3 id="2-5-2-适用情形"><a href="#2-5-2-适用情形" class="headerlink" title="2.5.2 适用情形"></a>2.5.2 适用情形</h3><p>持续维护元素的有序性：每次向队列插入大小不定的元素，或者每次从队列里取出大小最小/最大的元素，元素数量 n，插入操作数量 k.</p>
<ul>
<li>每次插入后进行快速排序：k⋅nlogn</li>
<li>使用优先队列维护：k⋅logn</li>
</ul>
<h3 id="2-5-3-注意事项"><a href="#2-5-3-注意事项" class="headerlink" title="2.5.3 注意事项"></a>2.5.3 注意事项</h3><h4 id="仅堆顶可读"><a href="#仅堆顶可读" class="headerlink" title="仅堆顶可读"></a>仅堆顶可读</h4><p>只可访问堆顶，其他元素都无法读取到。<strong>下面是错误用法：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; pque[<span class="number">1</span>] &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h4 id="所有元素不可写"><a href="#所有元素不可写" class="headerlink" title="所有元素不可写"></a>所有元素不可写</h4><p>堆中所有元素是不可修改的。<strong>下面是错误用法：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pque[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">pque.<span class="built_in">top</span>() = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>如果你恰好要修改的是堆顶元素，那么是可以完成的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> tp = pque.<span class="built_in">top</span>();</span><br><span class="line">pque.<span class="built_in">pop</span>();</span><br><span class="line">pque.<span class="built_in">push</span>(tp + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h2 id="2-6-集合-set"><a href="#2-6-集合-set" class="headerlink" title="2.6 集合 set"></a>2.6 集合 <a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/container/set">set</a></h2><p><strong><code>#include &lt;set&gt;</code></strong></p>
<p>提供对数时间的插入、删除、查找的集合数据结构。底层原理是红黑树。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>集合三要素</th>
<th>解释</th>
<th>set</th>
<th>multiset</th>
<th>unordered_set</th>
</tr>
</thead>
<tbody>
<tr>
<td>确定性</td>
<td>一个元素要么在集合中，要么不在</td>
<td>✔</td>
<td>✔</td>
<td>✔</td>
</tr>
<tr>
<td>互异性</td>
<td>一个元素仅可以在集合中出现一次</td>
<td>✔</td>
<td>❌（任意次）</td>
<td>✔</td>
</tr>
<tr>
<td>无序性</td>
<td>集合中的元素是没有顺序的</td>
<td>❌（从小到大）</td>
<td>❌（从小到大）</td>
<td>✔</td>
</tr>
</tbody>
</table>
</div>
<h3 id="2-6-1-常用方法"><a href="#2-6-1-常用方法" class="headerlink" title="2.6.1 常用方法"></a>2.6.1 常用方法</h3><h4 id="构造-2"><a href="#构造-2" class="headerlink" title="构造"></a>构造</h4><p><strong><code>set&lt;类型, 比较器&gt; st</code></strong></p>
<ul>
<li>类型：要储存的数据类型</li>
<li>比较器：比较大小使用的比较器，默认为 <code>less&lt;类型&gt;</code>，可自定义</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; st1;               <span class="comment">// 储存int的集合（从小到大）</span></span><br><span class="line">set&lt;<span class="type">int</span>, greater&lt;<span class="type">int</span>&gt;&gt; st2; <span class="comment">// 储存int的集合（从大到小）</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于需要自定义比较器的情况，涉及一些初学时容易看迷糊的语法（重载小括号运算符 / lambda 表达式），在此就不展开讲了。</p>
</blockquote>
<h4 id="遍历-1"><a href="#遍历-1" class="headerlink" title="遍历"></a>遍历</h4><p>可使用迭代器进行遍历：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (set&lt;<span class="type">int</span>&gt;::iterator it = st.<span class="built_in">begin</span>(); it != st.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>基于范围的循环（C++ 11）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;ele : st)</span><br><span class="line">    cout &lt;&lt; ele &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h4 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h4><div class="table-container">
<table>
<thead>
<tr>
<th>作用</th>
<th>用法</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入元素</td>
<td><code>.insert(元素)</code></td>
<td><code>st.insert(1);</code></td>
</tr>
<tr>
<td>删除元素</td>
<td><code>.erase(元素)</code></td>
<td><code>st.erase(2);</code></td>
</tr>
<tr>
<td>查找元素</td>
<td><code>.find(元素)</code></td>
<td><code>auto it = st.find(1);</code></td>
</tr>
<tr>
<td>判断元素是否存在</td>
<td><code>.count(元素)</code></td>
<td><code>st.count(3);</code></td>
</tr>
<tr>
<td>查看大小 / 清空 / 判空</td>
<td>略</td>
<td>略</td>
</tr>
</tbody>
</table>
</div>
<h4 id="begin-返回set容器的第一个元素的-地址"><a href="#begin-返回set容器的第一个元素的-地址" class="headerlink" title="begin() 　　 返回set容器的第一个元素的 地址"></a>begin() 　　 返回set容器的第一个元素的 <strong><em>地址</em></strong></h4><h4 id="end-返回set容器的最后一个元素-地址"><a href="#end-返回set容器的最后一个元素-地址" class="headerlink" title="end() 　　　　 返回set容器的最后一个元素 地址 "></a>end() 　　　　 返回set容器的最后一个元素 <strong><em>地址</em> </strong></h4><h4 id="clear-删除set容器中的所有的元素"><a href="#clear-删除set容器中的所有的元素" class="headerlink" title="clear() 　　 删除set容器中的所有的元素"></a>clear() 　　 删除set容器中的所有的元素</h4><h4 id="empty-判断set容器是否为空"><a href="#empty-判断set容器是否为空" class="headerlink" title="empty() 　　　 判断set容器是否为空"></a>empty() 　　　 判断set容器是否为空</h4><h4 id="max-size-返回set容器可能包含的元素最大个数"><a href="#max-size-返回set容器可能包含的元素最大个数" class="headerlink" title="max_size() 　 返回set容器可能包含的元素最大个数"></a>max_size() 　 返回set容器可能包含的元素最大个数</h4><h4 id="size-返回当前set容器中的元素个数"><a href="#size-返回当前set容器中的元素个数" class="headerlink" title="size() 　　　　 返回当前set容器中的元素个数"></a>size() 　　　　 返回当前set容器中的元素个数</h4><h4 id="erase-it-删除迭代器指针it处元素"><a href="#erase-it-删除迭代器指针it处元素" class="headerlink" title="erase(it) 删除迭代器指针it处元素"></a>erase(it) 删除迭代器指针it处元素</h4><h4 id="insert-a-插入某个元素"><a href="#insert-a-插入某个元素" class="headerlink" title="insert(a) 插入某个元素"></a>insert(a) 插入某个元素</h4><p>增删查时间复杂度均为 O(logn)</p>
<h3 id="2-6-2-适用情形"><a href="#2-6-2-适用情形" class="headerlink" title="2.6.2 适用情形"></a>2.6.2 适用情形</h3><ul>
<li>元素去重：[1,1,3,2,4,4]→[1,2,3,4][1,1,3,2,4,4]→[1,2,3,4]</li>
<li>维护顺序：[1,5,3,7,9]→[1,3,5,7,9][1,5,3,7,9]→[1,3,5,7,9]</li>
<li>元素是否出现过：元素大小 [−1018,1018][−1018,1018]，元素数量 106106，vis 数组无法实现，通过 set 可以完成。</li>
</ul>
<h3 id="2-6-3-注意事项"><a href="#2-6-3-注意事项" class="headerlink" title="2.6.3 注意事项"></a>2.6.3 注意事项</h3><h4 id="不存在下标索引"><a href="#不存在下标索引" class="headerlink" title="不存在下标索引"></a>不存在下标索引</h4><p>set 虽说可遍历，但仅可使用迭代器进行遍历，它不存在下标这一概念，无法通过下标访问到数据。<strong>下面是错误用法：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; st[<span class="number">0</span>] &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h4 id="元素只读"><a href="#元素只读" class="headerlink" title="元素只读"></a>元素只读</h4><p>set 的迭代器取到的元素是只读的（因为是 const 迭代器），不可修改其值。如果要改，需要先 erase 再 insert. <strong>下面是错误用法：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; *st.<span class="built_in">begin</span>() &lt;&lt; endl; <span class="comment">// 正确。可读。</span></span><br><span class="line">*st.<span class="built_in">begin</span>() = <span class="number">1</span>;             <span class="comment">// 错误！不可写！</span></span><br></pre></td></tr></table></figure>
<h4 id="不可用迭代器计算下标"><a href="#不可用迭代器计算下标" class="headerlink" title="不可用迭代器计算下标"></a>不可用迭代器计算下标</h4><p>set 的迭代器不能像 vector 一样相减得到下标。<strong>下面是错误用法：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = st.<span class="built_in">find</span>(<span class="number">2</span>);      <span class="comment">// 正确，返回2所在位置的迭代器。</span></span><br><span class="line"><span class="type">int</span> idx = it - st.<span class="built_in">begin</span>(); <span class="comment">// 错误！不可相减得到下标。</span></span><br></pre></td></tr></table></figure>
<h2 id="2-7-映射-map"><a href="#2-7-映射-map" class="headerlink" title="2.7 映射 map"></a>2.7 映射 <a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/container/map">map</a></h2><p><strong><code>#include &lt;map&gt;</code></strong></p>
<p>提供对数时间的有序键值对结构。底层原理是红黑树。</p>
<p>映射：</p>
<p>1234→→→→⋮22151→22→23→14→5⋮</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>性质</th>
<th>解释</th>
<th>map</th>
<th>multimap</th>
<th>unordered_map</th>
</tr>
</thead>
<tbody>
<tr>
<td>互异性</td>
<td>一个键仅可以在映射中出现一次</td>
<td>✔</td>
<td>❌（任意次）</td>
<td>✔</td>
</tr>
<tr>
<td>无序性</td>
<td>键是没有顺序的</td>
<td>❌（从小到大）</td>
<td>❌（从小到大）</td>
<td>✔</td>
</tr>
</tbody>
</table>
</div>
<h3 id="2-7-1-常用方法"><a href="#2-7-1-常用方法" class="headerlink" title="2.7.1 常用方法"></a>2.7.1 常用方法</h3><h4 id="构造-3"><a href="#构造-3" class="headerlink" title="构造"></a>构造</h4><p><strong><code>map&lt;键类型, 值类型, 比较器&gt; mp</code></strong></p>
<ul>
<li>键类型：要储存键的数据类型</li>
<li>值类型：要储存值的数据类型</li>
<li>比较器：键比较大小使用的比较器，默认为 <code>less&lt;类型&gt;</code>，可自定义</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp1;               <span class="comment">// int-&gt;int 的映射（键从小到大）</span></span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>, greater&lt;<span class="type">int</span>&gt;&gt; st2; <span class="comment">// int-&gt;int 的映射（键从大到小）</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于需要自定义比较器的情况，涉及一些初学时容易看迷糊的语法（重载小括号运算符 / lambda 表达式），在此就不展开讲了。</p>
</blockquote>
<h4 id="遍历-2"><a href="#遍历-2" class="headerlink" title="遍历"></a>遍历</h4><p>可使用迭代器进行遍历：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator it = mp.<span class="built_in">begin</span>(); it != mp.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>基于范围的循环（C++ 11）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;pr : mp)</span><br><span class="line">    cout &lt;&lt; pr.first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; pr.second &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>结构化绑定 + 基于范围的循环（C++17）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[key, val] : mp)</span><br><span class="line">    cout &lt;&lt; key &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; val &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h4 id="其他-2"><a href="#其他-2" class="headerlink" title="其他"></a>其他</h4><div class="table-container">
<table>
<thead>
<tr>
<th>作用</th>
<th>用法</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>增 / 改 / 查元素</td>
<td>中括号</td>
<td><code>mp[1] = 2;</code></td>
</tr>
<tr>
<td>查元素（返回迭代器）</td>
<td><code>.find(元素)</code></td>
<td><code>auto it = mp.find(1);</code></td>
</tr>
<tr>
<td>删除元素</td>
<td><code>.erase(元素)</code></td>
<td><code>mp.erase(2);</code></td>
</tr>
<tr>
<td>判断元素是否存在</td>
<td><code>.count(元素)</code></td>
<td><code>mp.count(3);</code></td>
</tr>
<tr>
<td>查看大小 / 清空 / 判空</td>
<td>略</td>
<td>略</td>
</tr>
</tbody>
</table>
</div>
<p>增删改查时间复杂度均为 O(logn)�(log⁡�)</p>
<h3 id="2-7-2-适用情形"><a href="#2-7-2-适用情形" class="headerlink" title="2.7.2 适用情形"></a>2.7.2 适用情形</h3><p>需要维护映射的场景可以使用：输入若干字符串，统计每种字符串的出现次数。(<code>map&lt;string, int&gt; mp</code>)</p>
<h3 id="2-7-3-注意事项"><a href="#2-7-3-注意事项" class="headerlink" title="2.7.3 注意事项"></a>2.7.3 注意事项</h3><h4 id="中括号访问时默认值"><a href="#中括号访问时默认值" class="headerlink" title="中括号访问时默认值"></a>中括号访问时默认值</h4><p>如果使用中括号访问 map 时对应的键不存在，那么会新增这个键，并且值为默认值，因此中括号会影响键的存在性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">cout &lt;&lt; mp.<span class="built_in">count</span>(<span class="string">&#x27;a&#x27;</span>) &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line">mp[<span class="string">&#x27;a&#x27;</span>];                       <span class="comment">// 即使什么都没做，此时mp[&#x27;a&#x27;]=0已经插入了</span></span><br><span class="line">cout &lt;&lt; mp.<span class="built_in">count</span>(<span class="string">&#x27;a&#x27;</span>) &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line">cout &lt;&lt; mp[<span class="string">&#x27;a&#x27;</span>] &lt;&lt; endl;       <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<h4 id="不可用迭代器计算下标-1"><a href="#不可用迭代器计算下标-1" class="headerlink" title="不可用迭代器计算下标"></a>不可用迭代器计算下标</h4><p>map 的迭代器不能像 vector 一样相减得到下标。<strong>下面是错误用法：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = mp.<span class="built_in">find</span>(<span class="string">&#x27;a&#x27;</span>);      <span class="comment">// 正确，返回2所在位置的迭代器。</span></span><br><span class="line"><span class="type">int</span> idx = it - mp.<span class="built_in">begin</span>();   <span class="comment">// 错误！不可相减得到下标。</span></span><br></pre></td></tr></table></figure>
<h2 id="2-8-字符串-string"><a href="#2-8-字符串-string" class="headerlink" title="2.8 字符串 string"></a>2.8 字符串 <a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/string">string</a></h2><p><strong><code>#include &lt;string&gt;</code></strong></p>
<p>顾名思义，就是储存字符串的。</p>
<h3 id="2-8-1-常用方法"><a href="#2-8-1-常用方法" class="headerlink" title="2.8.1 常用方法"></a>2.8.1 常用方法</h3><h4 id="构造-4"><a href="#构造-4" class="headerlink" title="构造"></a>构造</h4><p>构造函数：<code>string(长度, 初值)</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s1;           <span class="comment">// 构造字符串，为空</span></span><br><span class="line">string s2 = <span class="string">&quot;awa!&quot;</span>;  <span class="comment">// 构造字符串，并赋值awa!</span></span><br><span class="line"><span class="function">string <span class="title">s3</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;6&#x27;</span>)</span></span>;  <span class="comment">// 构造字符串，通过构造函数构造为6666666666</span></span><br></pre></td></tr></table></figure>
<h4 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h4><p>C++</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s;</span><br><span class="line">cin &gt;&gt; s;</span><br><span class="line">cout &lt;&lt; s;</span><br></pre></td></tr></table></figure>
<p>C</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string s;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, &amp;buf);</span><br><span class="line">s = buf;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, s.<span class="built_in">c_str</span>());</span><br></pre></td></tr></table></figure>
<h4 id="其他-3"><a href="#其他-3" class="headerlink" title="其他"></a>其他</h4><div class="table-container">
<table>
<thead>
<tr>
<th>作用</th>
<th>用法</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>修改、查询指定下标字符</td>
<td><code>[]</code></td>
<td><code>s[1] = &#39;a&#39;;</code></td>
</tr>
<tr>
<td>是否相同</td>
<td><code>==</code></td>
<td><code>if (s1 == s2) ...</code></td>
</tr>
<tr>
<td>字符串连接</td>
<td><code>+</code></td>
<td><code>string s = s1 + s2;</code></td>
</tr>
<tr>
<td>尾接字符串</td>
<td><code>+=</code></td>
<td><code>s += &quot;awa&quot;;</code></td>
</tr>
<tr>
<td>取子串</td>
<td><code>.substr(起始下标, 子串长度)</code></td>
<td><code>string sub = s.substr(2, 10);</code></td>
</tr>
<tr>
<td>查找字符串</td>
<td><code>.find(字符串, 起始下标)</code></td>
<td><code>int pos = s.find(&quot;awa&quot;);</code></td>
</tr>
</tbody>
</table>
</div>
<h4 id="数值与字符串互转（C-11）"><a href="#数值与字符串互转（C-11）" class="headerlink" title="数值与字符串互转（C++11）"></a>数值与字符串互转（C++11）</h4><div class="table-container">
<table>
<thead>
<tr>
<th>源</th>
<th>目的</th>
<th>函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>int / long long / float / double / long double</td>
<td>string</td>
<td>to_string()</td>
</tr>
<tr>
<td>string</td>
<td>int</td>
<td>stoi()</td>
</tr>
<tr>
<td>string</td>
<td>long long</td>
<td>stoll()</td>
</tr>
<tr>
<td>string</td>
<td>float</td>
<td>stof()</td>
</tr>
<tr>
<td>string</td>
<td>double</td>
<td>stod()</td>
</tr>
<tr>
<td>string</td>
<td>long double</td>
<td>stold()</td>
</tr>
</tbody>
</table>
</div>
<h3 id="2-8-2-适用情形"><a href="#2-8-2-适用情形" class="headerlink" title="2.8.2 适用情形"></a>2.8.2 适用情形</h3><p>非常好用！<del>建议直接把字符数组扔了，赶快投入 string 的怀抱。</del></p>
<h3 id="2-8-3-注意事项"><a href="#2-8-3-注意事项" class="headerlink" title="2.8.3 注意事项"></a>2.8.3 注意事项</h3><h4 id="尾接字符串一定要用"><a href="#尾接字符串一定要用" class="headerlink" title="尾接字符串一定要用 +="></a>尾接字符串一定要用 <code>+=</code></h4><p>string 的 += 运算符，将会在原字符串原地尾接字符串。而 + 了再 = 赋值，会先生成一个临时变量，在复制给 string.</p>
<p>通常字符串长度可以很长，如果使用 + 字符串很容易就 TLE 了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优化前: 15139ms</span></span><br><span class="line">string s;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5e5</span>; i++)</span><br><span class="line">    s = s + <span class="string">&quot;a&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化后: &lt; 1ms (计时器显示0)</span></span><br><span class="line">string s;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5e5</span>; i++)</span><br><span class="line">    s += <span class="string">&quot;a&quot;</span>;</span><br></pre></td></tr></table></figure>
<h4 id="substr-方法的奇葩参数"><a href="#substr-方法的奇葩参数" class="headerlink" title=".substr() 方法的奇葩参数"></a><code>.substr()</code> 方法的奇葩参数</h4><p>一定要注意，C++ string 的取子串的第一个参数是<strong>子串起点下标</strong>，第二个参数是<strong>子串长度</strong>。</p>
<p>第二个参数不是子串终点！不是子串终点！要与 java 等其他语言区分开来。</p>
<h4 id="find-方法的复杂度"><a href="#find-方法的复杂度" class="headerlink" title=".find() 方法的复杂度"></a><code>.find()</code> 方法的复杂度</h4><p>该方法实现为暴力实现，时间复杂度为 O(n2)�(�2).</p>
<p><del>不要幻想 STL 内置了个 O(n)�(�) 的 KMP 算法</del></p>
<p>toupper是小写转大写函数</p>
<h3 id="toupper大写"><a href="#toupper大写" class="headerlink" title="toupper大写"></a>toupper大写</h3><h3 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">toupper</span><span class="params">(<span class="type">int</span> c)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> ((c &gt;= <span class="string">&#x27;a&#x27;</span>) &amp;&amp; (c &lt;= <span class="string">&#x27;z&#x27;</span>))  </span><br><span class="line">        <span class="keyword">return</span> c + (<span class="string">&#x27;A&#x27;</span> - <span class="string">&#x27;a&#x27;</span>);  </span><br><span class="line">    <span class="keyword">return</span> c;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再普及一下大写转小写函数:</p>
<h3 id="tolower小写"><a href="#tolower小写" class="headerlink" title="tolower小写"></a>tolower小写</h3><h3 id="函数原型-1"><a href="#函数原型-1" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">tolower</span><span class="params">(<span class="type">int</span> c)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> ((c &gt;= <span class="string">&#x27;A&#x27;</span>) &amp;&amp; (c &lt;= <span class="string">&#x27;Z&#x27;</span>))  </span><br><span class="line">        <span class="keyword">return</span> c + (<span class="string">&#x27;a&#x27;</span> - <span class="string">&#x27;A&#x27;</span>);  </span><br><span class="line">    <span class="keyword">return</span> c;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>它们有一个优点:只会修改英文字母</p>
<p>注意,这两个函数只能一次修改一个字符</p>
<h3 id="kmp算法（重要）"><a href="#kmp算法（重要）" class="headerlink" title="kmp算法（重要）"></a>kmp算法（重要）</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">void <span class="constructor">Getnext(<span class="params">int</span> <span class="params">next</span>[], <span class="params">string</span> <span class="params">t</span>)</span> <span class="comment">//求next数组</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">int</span> j = <span class="number">0</span>, k = -<span class="number">1</span>;</span><br><span class="line">	next<span class="literal">[<span class="number">0</span>]</span> = -<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (j &lt; t.length<span class="literal">()</span> - <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (k<span class="operator"> == </span>-<span class="number">1</span><span class="operator"> || </span>t<span class="literal">[<span class="identifier">j</span>]</span><span class="operator"> == </span>t<span class="literal">[<span class="identifier">k</span>]</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			j++;</span><br><span class="line">			k++;</span><br><span class="line">			next<span class="literal">[<span class="identifier">j</span>]</span> = k;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> k = next<span class="literal">[<span class="identifier">k</span>]</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">int</span> <span class="constructor">KMP(<span class="params">string</span> <span class="params">s</span>, <span class="params">string</span> <span class="params">t</span>)</span> <span class="comment">//默认t为短串，传值时要注意！</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">int</span> next<span class="literal">[<span class="number">10000</span>]</span>, i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">	<span class="constructor">Getnext(<span class="params">next</span>, <span class="params">t</span>)</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; s.length<span class="literal">()</span><span class="operator"> &amp;&amp; </span>j &lt; t.length<span class="literal">()</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (j<span class="operator"> == </span>-<span class="number">1</span><span class="operator"> || </span>s<span class="literal">[<span class="identifier">i</span>]</span><span class="operator"> == </span>t<span class="literal">[<span class="identifier">j</span>]</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			i++;</span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> j = next<span class="literal">[<span class="identifier">j</span>]</span>;               <span class="comment">//j回退。。。</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (j &gt;= t.length<span class="literal">()</span>)</span><br><span class="line">		return (i - t.length<span class="literal">()</span>);         <span class="comment">//匹配成功，返回子串的位置</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		return <span class="number">(-1)</span>;                  <span class="comment">//没找到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="2-9-二元组-pair"><a href="#2-9-二元组-pair" class="headerlink" title="2.9 二元组 pair"></a>2.9 二元组 <a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/utility/pair">pair</a></h2><p><strong><code>#include &lt;utility&gt;</code></strong></p>
<p>顾名思义，就是储存二元组的。</p>
<h3 id="2-9-1-常用方法"><a href="#2-9-1-常用方法" class="headerlink" title="2.9.1 常用方法"></a>2.9.1 常用方法</h3><h4 id="构造-5"><a href="#构造-5" class="headerlink" title="构造"></a>构造</h4><p><strong><code>pair&lt;第一个值类型, 第二个值类型&gt; pr</code></strong></p>
<ul>
<li>第一个值类型：要储存的第一个值的数据类型</li>
<li>第二个值类型：要储存的第二个值的数据类型</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; p1;</span><br><span class="line">pair&lt;<span class="type">int</span>, <span class="type">long</span> <span class="type">long</span>&gt; p2;</span><br><span class="line">pair&lt;<span class="type">char</span>, <span class="type">int</span>&gt; p3;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<h4 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h4><p>老式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="type">int</span>, <span class="type">char</span>&gt; pr = <span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>列表构造 C++11</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="type">int</span>, <span class="type">char</span>&gt; pr = &#123;<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="取值"><a href="#取值" class="headerlink" title="取值"></a>取值</h4><p>直接取值</p>
<ul>
<li>取第一个值：<code>.first</code></li>
<li>取第二个值：<code>.second</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="type">int</span>, <span class="type">char</span>&gt; pr = &#123;<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>&#125;;</span><br><span class="line"><span class="type">int</span> awa = pr.first;</span><br><span class="line"><span class="type">char</span> bwb = pr.second;</span><br></pre></td></tr></table></figure>
<p>结构化绑定 C++17</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="type">int</span>, <span class="type">char</span>&gt; pr = &#123;<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> &amp;[awa, bwb] = pr;</span><br></pre></td></tr></table></figure>
<h4 id="判同"><a href="#判同" class="headerlink" title="判同"></a>判同</h4><p>直接用 <code>==</code> 运算符</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; p1 = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; p2 = &#123;<span class="number">1</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">if</span> (p1 == p2) &#123; ... &#125; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="2-9-2-适用场景"><a href="#2-9-2-适用场景" class="headerlink" title="2.9.2 适用场景"></a>2.9.2 适用场景</h3><p>所有需要二元组的场景均可使用，效率和自己定义结构体差不多。</p>
<h3 id="2-9-3-注意事项"><a href="#2-9-3-注意事项" class="headerlink" title="2.9.3 注意事项"></a>2.9.3 注意事项</h3><p>无</p>
<h2 id="3-迭代器简介"><a href="#3-迭代器简介" class="headerlink" title="3 迭代器简介"></a>3 迭代器简介</h2><h3 id="3-1-迭代器是什么？"><a href="#3-1-迭代器是什么？" class="headerlink" title="3.1 迭代器是什么？"></a>3.1 迭代器是什么？</h3><p>不搞抽象，直接举例。</p>
<p>对于一个 vector，我们可以用下标遍历：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++)</span><br><span class="line">    cout &lt;&lt; a[i] &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>我们同时也可以用迭代器来遍历：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = a.<span class="built_in">begin</span>(); it != a.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>a.begin()</code> 是一个迭代器，指向的是第一个元素</li>
<li><code>a.end()</code> 是一个迭代器，指向的是最后一个元素<strong>再后面一位</strong></li>
<li>上述迭代器具有自增运算符，自增则迭代器向下一个元素移动</li>
<li>迭代器与指针相似，如果对它使用解引用运算符，即 <code>*it</code>，就能取到对应值了</li>
</ul>
<h3 id="3-2-为何需要迭代器？"><a href="#3-2-为何需要迭代器？" class="headerlink" title="3.2 为何需要迭代器？"></a>3.2 为何需要迭代器？</h3><p>很多数据结构并不是线性的（例如红黑树），对于非线性数据结构，下标是无意义的。无法使用下标来遍历整个数据结构。</p>
<p>迭代器的作用就是定义某个数据结构的遍历方式，通过迭代器的增减，代表遍历到的位置，通过迭代器便能成功遍历非线性结构了。</p>
<p>例如，set 的实现是红黑树，我们是没法用下标来访问元素的。但是通过迭代器，我们就能遍历 set 中的元素了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (set&lt;<span class="type">int</span>&gt;::iterator it = st.<span class="built_in">begin</span>(); it != st.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-迭代器用法"><a href="#3-3-迭代器用法" class="headerlink" title="3.3 迭代器用法"></a>3.3 迭代器用法</h3><p>对于 vector 容器，它的迭代器功能比较完整，以它举例：</p>
<ul>
<li><code>.begin()</code>：头迭代器</li>
<li><code>.end()</code>：尾迭代器</li>
<li><code>.rbegin()</code>：反向头迭代器</li>
<li><code>.rend()</code>：反向尾迭代器</li>
<li>迭代器 <code>+</code> 整型：将迭代器向后移动</li>
<li>迭代器 <code>-</code> 整型：将迭代器向前移动</li>
<li>迭代器 <code>++</code>：将迭代器向后移动 1 位</li>
<li>迭代器 <code>--</code>：将迭代器向前移动 1 位</li>
<li>迭代器 <code>-</code> 迭代器：两个迭代器的距离</li>
<li><code>prev(it)</code>：返回 it 的前一个迭代器</li>
<li><code>next(it)</code>：返回 it 的后一个迭代器</li>
</ul>
<p>对于其他容器，由于其结构特性，上面的功能不一定都有（例如 set 的迭代器是不能相减求距离的）</p>
<h3 id="3-4-常见问题"><a href="#3-4-常见问题" class="headerlink" title="3.4 常见问题"></a>3.4 常见问题</h3><p><strong><code>.end()</code> 和 <code>.rend()</code> 指向的位置是无意义的值</strong></p>
<p>对于一个长度为 10 的数组：<code>for (int i = 0; i &lt; 10; i++)</code>，第 10 位是不可访问的</p>
<p>对于一个长度为 10 的容器：<code>for (auto it = a.begin(); it != a.end(); ++it)</code>，.end 是不可访问的</p>
<p><strong>不同容器的迭代器功能可能不一样</strong></p>
<p>迭代器细化的话有正向、反向、双向，每个容器的迭代器支持的运算符也可能不同，因此不同容器的迭代器细节很有可能是不一样的。</p>
<p><strong>删除操作时需要警惕</strong></p>
<p>为什么 3 没删掉？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; a&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = a.<span class="built_in">begin</span>(); it != a.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    <span class="keyword">if</span> (*it == <span class="number">2</span> || *it == <span class="number">3</span>)</span><br><span class="line">        a.<span class="built_in">erase</span>(it);</span><br><span class="line"><span class="comment">// a = [1, 3, 4]</span></span><br></pre></td></tr></table></figure>
<p>为啥 RE 了？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; a&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = a.<span class="built_in">begin</span>(); it != a.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    <span class="keyword">if</span> (*it == <span class="number">4</span>)</span><br><span class="line">        a.<span class="built_in">erase</span>(it);</span><br></pre></td></tr></table></figure>
<p><strong>建议：如无必要，别用迭代器操作容器。（遍历与访问没关系）</strong></p>
<h2 id="4-常用算法"><a href="#4-常用算法" class="headerlink" title="4 常用算法"></a>4 常用算法</h2><h3 id="4-1-内容总览"><a href="#4-1-内容总览" class="headerlink" title="4.1 内容总览"></a>4.1 内容总览</h3><p>打勾的是本次将会详细讲解的，其他的是算法竞赛中建议学习的，不在下表列出的在比赛中基本用不到。</p>
<p>（很多函数的功能很简单，自己都能快速写出来，但是使用函数可以让代码可读性变得更高，这在比赛中是至关紧要的）</p>
<ul>
<li>算法库 Algorithm<ul>
<li>[ ] <code>count()</code></li>
<li>[ ] <code>find()</code></li>
<li>[ ] <code>fill()</code></li>
<li>[x] <a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/algorithm/swap"><code>swap()</code></a></li>
<li>[x] <a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/algorithm/reverse"><code>reverse()</code></a></li>
<li>[ ] <code>shuffle()</code> C++11</li>
<li>[x] <a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/algorithm/unique"><code>unique()</code></a></li>
<li>[x] <a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/algorithm/sort"><code>sort()</code></a></li>
<li>[x] <a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/algorithm/lower_bound"><code>lower_bound()</code></a> / <a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/algorithm/upper_bound"><code>upper_bound()</code></a></li>
<li>[x] <a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/algorithm/max"><code>max()</code></a> / <a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/algorithm/min"><code>min()</code></a></li>
<li>[ ] <code>max_element()</code> / <code>min_element()</code></li>
<li>[ ] <code>prev_permutation()</code> / <code>next_permutation()</code></li>
</ul>
</li>
<li>数学函数 cmath<ul>
<li>[x] <a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/numeric/math/fabs"><code>abs()</code></a></li>
<li>[x] <a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/numeric/math/exp"><code>exp()</code></a></li>
<li>[x] <a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/numeric/math/log"><code>log()</code></a> / <code>log10()</code> / <code>log2()</code></li>
<li>[x] <a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/numeric/math/pow"><code>pow()</code></a></li>
<li>[x] <a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/numeric/math/sqrt"><code>sqrt()</code></a></li>
<li>[ ] <code>sin()</code> / <code>cos()</code> / <code>tan()</code></li>
<li>[ ] <code>asin()</code> / <code>acos()</code> / <code>atan()</code></li>
<li>[ ] <code>sinh()</code> / <code>cosh()</code> / <code>tanh()</code></li>
<li>[ ] <code>asinh()</code> / <code>acosh()</code> / <code>atanh()</code> C++11</li>
<li>[x] <a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/numeric/math/ceil"><code>ceil()</code></a> / <a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/numeric/math/floor"><code>floor()</code></a></li>
<li>[x] <a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/numeric/math/round"><code>round()</code></a> C++11</li>
</ul>
</li>
<li>数值算法 numeric<ul>
<li>[ ] <code>iota()</code> C++11</li>
<li>[ ] <code>accumulate()</code></li>
<li>[x] <a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/numeric/gcd"><code>gcd()</code></a> C++17</li>
<li>[x] <a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/numeric/lcm"><code>lcm()</code></a> C++17</li>
</ul>
</li>
<li>伪随机数生成 random<ul>
<li>[ ] <code>mt19937</code></li>
<li>[ ] <code>random_device()</code></li>
</ul>
</li>
</ul>
<h3 id="4-2-swap"><a href="#4-2-swap" class="headerlink" title="4.2 swap()"></a>4.2 <code>swap()</code></h3><p>交换两个变量的值（也可交换结构体等）</p>
<p><strong>用法示例</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> T &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">( T&amp; a, T&amp; b )</span></span>;</span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">swap</span>(a, b);</span><br><span class="line"><span class="comment">// now a = 1, b = 0</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[<span class="number">10</span>] &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="built_in">swap</span>(arr[<span class="number">4</span>], arr[<span class="number">6</span>]);</span><br><span class="line"><span class="comment">// now arr = &#123;0, 1, 2, 3, 6, 5, 4, 7, 8, 9&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>注意事项</strong></p>
<p>这个 swap 参数是引用的，不需要像 C 语言一样取地址。</p>
<h3 id="4-3-sort"><a href="#4-3-sort" class="headerlink" title="4.3 sort()"></a>4.3 <code>sort()</code></h3><p>使用快速排序给一个可迭代对象排序</p>
<p><strong>用法示例</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> RandomIt, <span class="keyword">class</span> Compare &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">( RandomIt first, RandomIt last, Compare comp )</span></span>;</span><br></pre></td></tr></table></figure>
<p>默认排序从小到大</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; arr&#123;<span class="number">1</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br><span class="line"><span class="comment">// arr = [0, 1, 1, 1, 8, 9, 9]</span></span><br></pre></td></tr></table></figure>
<p>如果要从大到小，则需要传比较器进去。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; arr&#123;<span class="number">1</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line"><span class="comment">// arr = [9, 9, 8, 1, 1, 1, 0]</span></span><br></pre></td></tr></table></figure>
<p>如果需要完成特殊比较，则需要手写比较器。</p>
<p>比较器函数返回值是 bool 类型，传参是需要比较的两个元素。记我们定义的该比较操作为 ⋆⋆：</p>
<ul>
<li>若 a⋆b，则比较器函数应当返回 <code>true</code></li>
<li>若 a⋆̸b，则比较器函数应当返回 <code>false</code></li>
</ul>
<p><strong>注意：</strong>如果 a=b=�，比较器函数必须返回 <code>false</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; a, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.second != b.second)</span><br><span class="line">        <span class="keyword">return</span> a.second &lt; b.second;</span><br><span class="line">    <span class="keyword">return</span> a.first &gt; b.first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; arr&#123;&#123;<span class="number">1</span>, <span class="number">9</span>&#125;, &#123;<span class="number">2</span>, <span class="number">9</span>&#125;, &#123;<span class="number">8</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), cmp);</span><br><span class="line">    <span class="comment">// arr = [(0, 0), (8, 1), (2, 9), (1, 9)]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-4-lower-bound-upper-bound"><a href="#4-4-lower-bound-upper-bound" class="headerlink" title="4.4 lower_bound() / upper_bound()"></a>4.4 <code>lower_bound()</code> / <code>upper_bound()</code></h3><p>在<strong>已升序排序</strong>的元素中，应用二分查找检索指定元素，返回对应元素迭代器位置。<strong>找不到则返回尾迭代器。</strong></p>
<ul>
<li><code>lower_bound()</code>: 寻找 ≥x的第一个元素的位置</li>
<li><code>upper_bound()</code>: 寻找 &gt;x的第一个元素的位置</li>
</ul>
<p>怎么找 ≤x/ &lt;x第一个元素呢？</p>
<ul>
<li>>x 的第一个元素的前一个元素（如果有）便是 ≤x 的第一个元素</li>
<li>≥x 的第一个元素的前一个元素（如果有）便是 &lt;x 的第一个元素</li>
</ul>
<p>返回的是迭代器，如何转成下标索引呢？减去头迭代器即可。</p>
<h3 id="记得考虑全部都比要找的大或者小的特殊情况！！！"><a href="#记得考虑全部都比要找的大或者小的特殊情况！！！" class="headerlink" title="记得考虑全部都比要找的大或者小的特殊情况！！！"></a>记得考虑全部都比要找的大或者小的特殊情况！！！</h3><p><strong>用法示例</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> ForwardIt, <span class="keyword">class</span> T &gt;</span></span><br><span class="line"><span class="function">ForwardIt <span class="title">lower_bound</span><span class="params">( ForwardIt first, ForwardIt last, <span class="type">const</span> T&amp; value )</span></span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; arr&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">9</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">lower_bound</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), <span class="number">7</span>);</span><br><span class="line"><span class="type">int</span> idx = it - arr.<span class="built_in">begin</span>();</span><br><span class="line"><span class="comment">// idx = 4</span></span><br></pre></td></tr></table></figure>
<p>我们通常写成一行：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; arr&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">9</span>&#125;;</span><br><span class="line">idx = <span class="built_in">lower_bound</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), <span class="number">7</span>) - arr.<span class="built_in">begin</span>(); <span class="comment">// 4</span></span><br><span class="line">idx = <span class="built_in">lower_bound</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), <span class="number">8</span>) - arr.<span class="built_in">begin</span>(); <span class="comment">// 4</span></span><br><span class="line">idx = <span class="built_in">upper_bound</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), <span class="number">7</span>) - arr.<span class="built_in">begin</span>(); <span class="comment">// 4</span></span><br><span class="line">idx = <span class="built_in">upper_bound</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), <span class="number">8</span>) - arr.<span class="built_in">begin</span>(); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<h3 id="4-5-reverse"><a href="#4-5-reverse" class="headerlink" title="4.5 reverse()"></a>4.5 <code>reverse()</code></h3><p>反转一个可迭代对象的元素顺序</p>
<p><strong>用法示例</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> BidirIt &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">( BidirIt first, BidirIt last )</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="built_in">iota</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 1, 2, 3, 4, 5, 6, 7, 8, 9, 10</span></span><br><span class="line"><span class="built_in">reverse</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br><span class="line"><span class="comment">// 10, 9, 8, 7, 6, 5, 4, 3, 2, 1</span></span><br></pre></td></tr></table></figure>
<h3 id="4-6-max-min"><a href="#4-6-max-min" class="headerlink" title="4.6 max() / min()"></a>4.6 <code>max()</code> / <code>min()</code></h3><p>返回最大值 / 最小值的<strong>数值</strong></p>
<p><strong>用法示例</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> mx = <span class="built_in">max</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 2</span></span><br><span class="line"><span class="type">int</span> mn = <span class="built_in">min</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>在 C++11 之后，可以使用列表构造语法传入一个列表，这样就能一次性给多个元素找最大值而不用套娃了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Before C++11</span></span><br><span class="line"><span class="type">int</span> mx = <span class="built_in">max</span>(<span class="built_in">max</span>(<span class="number">1</span>, <span class="number">2</span>), <span class="built_in">max</span>(<span class="number">3</span>, <span class="number">4</span>)); <span class="comment">// 4</span></span><br><span class="line"><span class="type">int</span> mn = <span class="built_in">min</span>(<span class="built_in">min</span>(<span class="number">1</span>, <span class="number">2</span>), <span class="built_in">min</span>(<span class="number">3</span>, <span class="number">4</span>)); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// After C++11</span></span><br><span class="line"><span class="type">int</span> mx = <span class="built_in">max</span>(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;); <span class="comment">// 4</span></span><br><span class="line"><span class="type">int</span> mn = <span class="built_in">min</span>(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h3 id="4-7-unique"><a href="#4-7-unique" class="headerlink" title="4.7 unique()"></a>4.7 <code>unique()</code></h3><p>消除数组的重复<strong>相邻</strong>元素，数组长度不变，但是有效数据缩短，返回的是有效数据位置的结尾迭代器。</p>
<p>例如：[1,1,4,5,1,4]→[1,4,5,1,4,?–][1,1,4,5,1,4]→[1,4,5,1,4,?_]，下划线位置为返回的迭代器指向。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> ForwardIt &gt;</span></span><br><span class="line"><span class="function">ForwardIt <span class="title">unique</span><span class="params">( ForwardIt first, ForwardIt last )</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>用法示例</strong></p>
<p>单独使用 unique 并不能达成去重效果，因为它只消除<strong>相邻</strong>的重复元素。但是如果序列有序，那么它就能去重了。</p>
<p>但是它去重后，序列尾部会产生一些无效数据：[1,1,2,4,4,4,5]→[1,2,4,5,?–,?,?][1,1,2,4,4,4,5]→[1,2,4,5,?_,?,?]，为了删掉这些无效数据，我们需要结合 erase.</p>
<p>最终，给 vector 去重的写法便是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; arr&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br><span class="line">arr.<span class="built_in">erase</span>(<span class="built_in">unique</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>()), arr.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>
<h3 id="4-8-数学函数"><a href="#4-8-数学函数" class="headerlink" title="4.8 数学函数"></a>4.8 数学函数</h3><p>所有函数参数均支持 <code>int</code> / <code>long long</code> / <code>float</code> / <code>double</code> / <code>long double</code></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>公式</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>f(x)=\</td>
<td>x\</td>
<td></td>
<td><code>abs(-1.0)</code></td>
</tr>
<tr>
<td>f(x)=ex</td>
<td><code>exp(2)</code></td>
</tr>
<tr>
<td>f(x)=lnx</td>
<td><code>log(3)</code></td>
</tr>
<tr>
<td>f(x,y)=xy</td>
<td><code>pow(2, 3)</code></td>
</tr>
<tr>
<td>f(x)=x−−√�(�)=�</td>
<td><code>sqrt(2)</code></td>
</tr>
<tr>
<td>f(x)=⌈x⌉</td>
<td><code>ceil(2.1)</code></td>
</tr>
<tr>
<td>f(x)=⌊x⌋</td>
<td><code>floor(2.1)</code></td>
</tr>
<tr>
<td>f(x)=⟨x⟩</td>
<td><code>rount(2.1)</code></td>
</tr>
</tbody>
</table>
</div>
<p><strong>注意事项</strong></p>
<p>由于浮点误差，有些的数学函数的行为可能与预期不符，导致 WA。如果你的操作数都是整型，那么用下面的写法会更稳妥。</p>
<blockquote>
<p>原文地址：<a target="_blank" rel="noopener" href="https://codeforces.com/blog/entry/107717">https://codeforces.com/blog/entry/107717</a></p>
</blockquote>
<ul>
<li>⌊ab⌋<ul>
<li>别用：<code>floor(1.0 * a / b)</code></li>
<li>要用：<code>a / b</code></li>
</ul>
</li>
<li>⌈ab⌉<ul>
<li>别用：<code>ceil(1.0 * a / b)</code></li>
<li>要用：<code>(a + b - 1) / b</code> （⌈ab⌉=⌊a+b−1b⌋）</li>
</ul>
</li>
<li>⌊a−−√⌋⌊�⌋<ul>
<li>别用：<code>(int) sqrt(a)</code></li>
<li>要用：二分查找 <a target="_blank" rel="noopener" href="https://io.zouht.com/7.html">https://io.zouht.com/7.html</a></li>
</ul>
</li>
<li>ab<ul>
<li>别用：<code>pow(a, b)</code></li>
<li>要用：快速幂 <a target="_blank" rel="noopener" href="https://io.zouht.com/18.html">https://io.zouht.com/18.html</a></li>
</ul>
</li>
<li>⌊log2a⌋<ul>
<li>别用：<code>log2(a)</code></li>
<li>要用：<code>__lg</code> （不规范，但是这是竞赛）/ <code>bit_width</code>（C++20 可用）</li>
</ul>
</li>
</ul>
<h3 id="4-9-gcd-lcm"><a href="#4-9-gcd-lcm" class="headerlink" title="4.9 gcd() / lcm()"></a>4.9 <code>gcd()</code> / <code>lcm()</code></h3><p>（C++17）返回最大公因数 / 最小公倍数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="built_in">gcd</span>(<span class="number">8</span>, <span class="number">12</span>); <span class="comment">// 4</span></span><br><span class="line"><span class="type">int</span> y = <span class="built_in">lcm</span>(<span class="number">8</span>, <span class="number">12</span>); <span class="comment">// 24</span></span><br></pre></td></tr></table></figure>
<p>如果不是 C++17，但是是 GNU 编译器（g++），那么可以用内置函数 <code>__gcd()</code>.</p>
<p>当然，<code>gcd</code> / <code>lcm</code> 函数也挺好写，直接写也行（欧几里得算法）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lcm</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a / <span class="built_in">gcd</span>(a, b) * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-10-nth-element"><a href="#4-10-nth-element" class="headerlink" title="4.10 nth_element"></a>4.10 nth_element</h3><p>在 STL 里有一个神奇的函数 <code>nth_element</code>。</p>
<p>它的用法是 <code>nth_element(a+x,a+x+y,a+x+len);</code>。</p>
<p>执行之后数组 <em>a</em> 下标 <em>x</em> 到 x<em>+</em>y<em>−1 的元素都小于 a</em>[<em>x</em>+<em>y</em>]，下标 x<em>+</em>y<em>+1 到 </em>x<em>+</em>l<strong>e</strong>n<em>−1 的元素 都大于 a</em>[<em>x</em>+<em>y</em>]，但不保证数组有序。此时 a<em>[</em>x<em>+</em>y<em>] 就是数组区间 x</em> 到 x<em>+</em>l<strong>e</strong>n<em>−1 中第 y</em> 小的数，当然也可以自己定义 c<strong>m</strong>p 函数。</p>
<p>结论：差不多就是将我们的思路 2 做了一遍。</p>
<p><code>nth_element</code> 的时间复杂度是 )<em>O</em>(<em>n</em>) 的，不过 STL 常数普遍较大……但还是能过此题。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> x[<span class="number">5000005</span>],k;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x[i]);</span><br><span class="line">	<span class="built_in">nth_element</span>(x,x+k,x+n);<span class="comment">//简短又高效</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,x[k]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-11-next-permutation"><a href="#4-11-next-permutation" class="headerlink" title="4.11 next_permutation"></a>4.11 next_permutation</h3><h4 id="一、next-permutation的介绍"><a href="#一、next-permutation的介绍" class="headerlink" title="一、next_permutation的介绍"></a>一、next_permutation的介绍</h4><p>next_permutation的意思是下一个排列，与其相对的是prev_permutation,即上一个排列。我们需要使用全排列的时候就可以直接使用这两个函数，方便又快捷</p>
<h4 id="二、next-permutation的基本用法"><a href="#二、next-permutation的基本用法" class="headerlink" title="二、next_permutation的基本用法"></a>二、next_permutation的基本用法</h4><p>由于prev_permutation和next_permutation的用法是一样的，下面就值讲解next_permutation的基本用法</p>
<p>next_permutation只能获得上一个排列，如果要获得全排列，那么就需要先对数组进行升序排序</p>
<p>基本定义如下：<br>next_permutaion(起始地址，末尾地址+1)<br>next_permutaion(起始地址，末尾地址+1，自定义排序)</p>
<p>可以使用默认的升序排序，也可以使用自定义的排序方法</p>
<h5 id="1、普通数组全排列"><a href="#1、普通数组全排列" class="headerlink" title="1、普通数组全排列"></a>1、普通数组全排列</h5><p>普通数组可以通过数组名表示地址，非常容易实现</p>
<p>示例代码：</p>
<h1 id="include"><a href="#include" class="headerlink" title="include"></a>include<iostream></h1><h1 id="include-使用-next-permutation-和sort-需要导入的头文件"><a href="#include-使用-next-permutation-和sort-需要导入的头文件" class="headerlink" title="include//使用 next_permutation()和sort()需要导入的头文件"></a>include<algorithm>//使用 next_permutation()和sort()需要导入的头文件</h1><p>using namespace std;<br>int main(){<br>    int a[4]={2,1,4,3};</p>
<pre><code>sort(a,a+4);//对数组排序 

do&#123;
    for(int i=0;i&lt;4;i++)&#123;//打印排列 
        cout&lt;&lt;a[i]&lt;&lt;&#39; &#39;;
    &#125;
    cout&lt;&lt;endl;
&#125;while(next_permutation(a,a+4));//获取下一个排列 
</code></pre><p>} </p>
<p>运行结果：</p>
<p>1 2 3 4<br>1 2 4 3<br>1 3 2 4<br>1 3 4 2<br>1 4 2 3<br>1 4 3 2<br>2 1 3 4<br>2 1 4 3<br>2 3 1 4<br>2 3 4 1<br>2 4 1 3<br>2 4 3 1<br>3 1 2 4<br>3 1 4 2<br>3 2 1 4<br>3 2 4 1<br>3 4 1 2<br>3 4 2 1<br>4 1 2 3<br>4 1 3 2<br>4 2 1 3<br>4 2 3 1<br>4 3 1 2<br>4 3 2 1</p>
<h5 id="2、结构体全排列"><a href="#2、结构体全排列" class="headerlink" title="2、结构体全排列"></a>2、结构体全排列</h5><p>结构体默认是不能比较大小的，那么就不能使用默认的next_permutation()排列比较函数，需要使用自定义排列比较函数</p>
<p>示例代码：</p>
<h1 id="include-1"><a href="#include-1" class="headerlink" title="include"></a>include<iostream></h1><h1 id="include-使用-next-permutation-和sort-需要导入的头文件-1"><a href="#include-使用-next-permutation-和sort-需要导入的头文件-1" class="headerlink" title="include//使用 next_permutation()和sort()需要导入的头文件"></a>include<algorithm>//使用 next_permutation()和sort()需要导入的头文件</h1><p>using namespace std;</p>
<p>struct test{//结构体test<br>    int val;<br>}; </p>
<p>bool cmp(test t1,test t2){//自定义的排列<br>    return t1.val&lt;t2.val;<br>}</p>
<p>int main(){<br>    test t[4];//结构体数组<br>    t[0].val=1;<br>    t[1].val=2;<br>    t[2].val=3;<br>    t[3].val=4;</p>
<pre><code>do&#123;
    for(int i=0;i&lt;4;i++)&#123;//打印排列 
        cout&lt;&lt;t[i].val&lt;&lt;&#39; &#39;;
    &#125;
    cout&lt;&lt;endl;
&#125;while(next_permutation(t,t+4,cmp));//获取下一个排列 
</code></pre><p>运行结果：</p>
<p>1 2 3 4<br>1 2 4 3<br>1 3 2 4<br>1 3 4 2<br>1 4 2 3<br>1 4 3 2<br>2 1 3 4<br>2 1 4 3<br>2 3 1 4<br>2 3 4 1<br>2 4 1 3<br>2 4 3 1<br>3 1 2 4<br>3 1 4 2<br>3 2 1 4<br>3 2 4 1<br>3 4 1 2<br>3 4 2 1<br>4 1 2 3<br>4 1 3 2<br>4 2 1 3<br>4 2 3 1<br>4 3 1 2<br>4 3 2 1</p>
<h5 id="3、vector"><a href="#3、vector" class="headerlink" title="3、vector"></a>3、vector</h5><p>vector及string等数据结构不能直接用名字代表地址，只能够使用自带的迭代器begin()、end()实现全排列</p>
<p>示例代码：</p>
<h1 id="include-2"><a href="#include-2" class="headerlink" title="include"></a>include<iostream></h1><h1 id="include-使用vector需要导入的头文件"><a href="#include-使用vector需要导入的头文件" class="headerlink" title="include //使用vector需要导入的头文件"></a>include<vector> //使用vector需要导入的头文件</h1><h1 id="include-使用-next-permutation-和sort-需要导入的头文件-2"><a href="#include-使用-next-permutation-和sort-需要导入的头文件-2" class="headerlink" title="include//使用 next_permutation()和sort()需要导入的头文件"></a>include<algorithm>//使用 next_permutation()和sort()需要导入的头文件</h1><p>using namespace std;</p>
<p>int main(){<br>    vector<int> v;//定义一个int型的vector<br>    v.push_back(1);//在尾部插入数据1<br>    v.push_back(2);<br>    v.push_back(3);<br>    v.push_back(4);</p>
<pre><code>do&#123;
    for(int i=0;i&lt;v.size();i++)&#123;//打印排列 
        cout&lt;&lt;v[i]&lt;&lt;&#39; &#39;;
    &#125;
    cout&lt;&lt;endl;
&#125;while(next_permutation(v.begin(),v.end()));//获取下一个排列 
</code></pre><p>} </p>
<p>运行结果：</p>
<p>1 2 3 4<br>1 2 4 3<br>1 3 2 4<br>1 3 4 2<br>1 4 2 3<br>1 4 3 2<br>2 1 3 4<br>2 1 4 3<br>2 3 1 4<br>2 3 4 1<br>2 4 1 3<br>2 4 3 1<br>3 1 2 4<br>3 1 4 2<br>3 2 1 4<br>3 2 4 1<br>3 4 1 2<br>3 4 2 1<br>4 1 2 3<br>4 1 3 2<br>4 2 1 3<br>4 2 3 1<br>4 3 1 2<br>4 3 2 1</p>
<p>同样地，prev_permutation拥有同样的用法，大家可以动手尝试一下</p>
<p>学完next_permutation的这些基本用法就足够使用了，进阶的可以搭配其它的数据结构进行使用<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_52115456/article/details/127626074">https://blog.csdn.net/weixin_52115456/article/details/127626074</a></p>
<h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><h2 id="一、时间复杂度"><a href="#一、时间复杂度" class="headerlink" title="一、时间复杂度"></a><strong>一、时间复杂度</strong></h2><p>我们想要知道一个算法的「时间复杂度」，很多人首先想到的的方法就是把这个算法程序运行一遍，那么它所消耗的时间就自然而然知道了。</p>
<p>这种方式可以吗？当然可以，不过它也有很多弊端。<br>这种方式非常容易受运行环境的影响，在性能高的机器上跑出来的结果与在性能低的机器上跑的结果相差会很大。而且对测试时使用的数据规模也有很大关系。再者，并我们在写算法的时候，还没有办法完整的去运行呢。</p>
<p>因此，另一种更为通用的方法就出来了：「 <strong>大O符号表示法</strong> 」，即 T(n) = O(f(n))</p>
<p>我们先来看个例子：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(i=1; i&lt;=n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">   j = i;</span><br><span class="line">   j++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过「 大O符号表示法 」，这段代码的时间复杂度为：O(n) ，为什么呢?</p>
<p>在 大O符号表示法中，时间复杂度的公式是： T(n) = O( f(n) )，其中f(n) 表示每行代码执行次数之和，而 O 表示正比例关系，这个公式的全称是：<strong>算法的渐进时间复杂度</strong>。</p>
<p>我们继续看上面的例子，假设每行代码的执行时间都是一样的，我们用 1颗粒时间 来表示，那么这个例子的第一行耗时是1个颗粒时间，第三行的执行时间是 n个颗粒时间，第四行的执行时间也是 n个颗粒时间（第二行和第五行是符号，暂时忽略），那么总时间就是 1颗粒时间 + n颗粒时间 + n颗粒时间 ，即 (1+2n)个颗粒时间，即： T(n) = (1+2n)*颗粒时间，从这个结果可以看出，这个算法的耗时是随着n的变化而变化，因此，我们可以简化的将这个算法的时间复杂度表示为：T(n) = O(n)</p>
<p>为什么可以这么去简化呢，因为大O符号表示法并不是用于来真实代表算法的执行时间的，它是用来表示代码执行时间的增长变化趋势的。</p>
<p>所以上面的例子中，如果n无限大的时候，T(n) = time(1+2n)中的常量1就没有意义了，倍数2也意义不大。因此直接简化为T(n) = O(n) 就可以了。</p>
<p>常见的时间复杂度量级有：</p>
<ul>
<li>常数阶O(1)</li>
<li>对数阶O(logN)</li>
<li>线性阶O(n)</li>
<li>线性对数阶O(nlogN)</li>
<li>平方阶O(n²)</li>
<li>立方阶O(n³)</li>
<li>K次方阶O(n^k)</li>
<li>指数阶(2^n)</li>
</ul>
<p>上面从上至下依次的时间复杂度越来越大，执行的效率越来越低。</p>
<p>下面选取一些较为常用的来讲解一下（没有严格按照顺序）：</p>
<ol>
<li><strong>常数阶O(1)</strong></li>
</ol>
<p>无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1)，如：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int i = 1;</span><br><span class="line">int j = 2;</span><br><span class="line">++i;</span><br><span class="line">j++;</span><br><span class="line">int m = i + j;</span><br></pre></td></tr></table></figure>
<p>上述代码在执行的时候，它消耗的时候并不随着某个变量的增长而增长，那么无论这类代码有多长，即使有几万几十万行，都可以用O(1)来表示它的时间复杂度。</p>
<ol>
<li><strong>线性阶O(n)</strong></li>
</ol>
<p>这个在最开始的代码示例中就讲解过了，如：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(i=1; i&lt;=n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">   j = i;</span><br><span class="line">   j++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码，for循环里面的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的，因此这类代码都可以用O(n)来表示它的时间复杂度。</p>
<ol>
<li><strong>对数阶O(logN)</strong></li>
</ol>
<p>还是先来看代码：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int i = 1;</span><br><span class="line">while(i&lt;n)</span><br><span class="line">&#123;</span><br><span class="line">    i = i * 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面代码可以看到，在while循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了。我们试着求解一下，假设循环x次之后，i 就大于 2 了，此时这个循环就退出了，也就是说 2 的 x 次方等于 n，那么 x = log2^n<br>也就是说当循环 log2^n 次以后，这个代码就结束了。因此这个代码的时间复杂度为：<strong>O(logn)</strong></p>
<ol>
<li><strong>线性对数阶O(nlogN)</strong></li>
</ol>
<p>线性对数阶O(nlogN) 其实非常容易理解，将时间复杂度为O(logn)的代码循环N遍的话，那么它的时间复杂度就是 n * O(logN)，也就是了O(nlogN)。</p>
<p>就拿上面的代码加一点修改来举例：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for(m=1; m&lt;n; m++)</span><br><span class="line">&#123;</span><br><span class="line">    i = 1;</span><br><span class="line">    while(i&lt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        i = i * 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>平方阶O(n²)</strong></li>
</ol>
<p>平方阶O(n²) 就更容易理解了，如果把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²) 了。<br>举例：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for(x=1; i&lt;=n; x++)</span><br><span class="line">&#123;</span><br><span class="line">   for(i=1; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">       j = i;</span><br><span class="line">       j++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码其实就是嵌套了2层n循环，它的时间复杂度就是 O(n*n)，即 O(n²)<br>如果将其中一层循环的n改成m，即：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for(x=1; i&lt;=m; x++)</span><br><span class="line">&#123;</span><br><span class="line">   for(i=1; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">       j = i;</span><br><span class="line">       j++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那它的时间复杂度就变成了 O(m*n)</p>
<ol>
<li><strong>立方阶O(n³)</strong>、<strong>K次方阶O(n^k)</strong></li>
</ol>
<p>参考上面的O(n²) 去理解就好了，O(n³)相当于三层n循环，其它的类似。</p>
<p>除此之外，其实还有 平均时间复杂度、均摊时间复杂度、最坏时间复杂度、最好时间复杂度 的分析方法，有点复杂，这里就不展开了。</p>
<h2 id="二、空间复杂度"><a href="#二、空间复杂度" class="headerlink" title="二、空间复杂度"></a><strong>二、空间复杂度</strong></h2><p>既然时间复杂度不是用来计算程序具体耗时的，那么我也应该明白，空间复杂度也不是用来计算程序实际占用的空间的。</p>
<p>空间复杂度是对一个算法在运行过程中临时占用存储空间大小的一个量度，同样反映的是一个趋势，我们用 S(n) 来定义。</p>
<p>空间复杂度比较常用的有：O(1)、O(n)、O(n²)，我们下面来看看：</p>
<ol>
<li><strong>空间复杂度 O(1)</strong></li>
</ol>
<p>如果算法执行所需要的临时空间不随着某个变量n的大小而变化，即此算法空间复杂度为一个常量，可表示为 O(1)<br>举例：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int i = 1;</span><br><span class="line">int j = 2;</span><br><span class="line">++i;</span><br><span class="line">j++;</span><br><span class="line">int m = i + j;</span><br></pre></td></tr></table></figure>
<p>代码中的 i、j、m 所分配的空间都不随着处理数据量变化，因此它的空间复杂度 S(n) = O(1)</p>
<ol>
<li><strong>空间复杂度 O(n)</strong></li>
</ol>
<p>我们先看一个代码：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int[] m = new int[n]</span><br><span class="line">for(i=1; i&lt;=n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">   j = i;</span><br><span class="line">   j++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码中，第一行new了一个数组出来，这个数据占用的大小为n，这段代码的2-6行，虽然有循环，但没有再分配新的空间，因此，这段代码的空间复杂度主要看第一行即可，即 S(n) = O(n)</p>
<h1 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h1><blockquote>
<p>一、概念概念来自百度百科。链接如下：异或异或也叫半加运算，其运算法则相当于不带进位的二进制加法：二进制下用1表示真，0表示假，则异或的运算法则为：0⊕0=0，1⊕0=1，0⊕1=1，1⊕1=0（同为0，异为1），这些法则与加法是相同的，只是不带进位，所以异或常被认作不进位加法。二、运算过程通过三个例子和划重点：异或的运算口诀是相等为0，不相等为1。当然这是在二进制的层面。下面手动演示一遍以 12 和 12 为例进行异或演示十进制的12 在二进制是1100，根据口诀 相等为0，不相等为1</p>
</blockquote>
<hr>
<h2 id="异或运算：按位异或运算符"><a href="#异或运算：按位异或运算符" class="headerlink" title="　异或运算：按位异或运算符"></a>　<strong>异或运算：按位异或运算符</strong></h2><p>　　首先异或表示当两个数的二进制表示，进行异或运算时，当前位的两个二进制表示不同则为1相同则为0.该方法被广泛推广用来统计一个数的1的位数！</p>
<p>　　参与运算的两个值，如果两个相应bit位相同，则结果为0，否则为1。</p>
<p>　　即：</p>
<p>　　0^0 = 0，</p>
<p>　　1^0 = 1，</p>
<p>　　0^1 = 1，</p>
<p>　　1^1 = 0</p>
<p>　　按位异或的3个特点：</p>
<p>　　（1） 0^0=0，0^1=1 0异或任何数＝任何数</p>
<p>　　（2） 1^0=1，1^1=0 1异或任何数－任何数取反</p>
<p>　　（3） 任何数异或自己＝把自己置0</p>
<p>　　按位异或的几个常见用途：</p>
<p>　　（1） 使某些特定的位翻转</p>
<p>　　例如对数10100001的第2位和第3位翻转，则可以将该数与00000110进行按位异或运算。</p>
<p>　　10100001^00000110 = 10100111</p>
<p>　　（2） 实现两个值的交换，而不必使用临时变量。</p>
<p>　　例如交换两个整数a=10100001，b=00000110的值，可通过下列语句实现：</p>
<p>　　a = a^b； 　　//a=10100111</p>
<p>　　b = b^a； 　　//b=10100001</p>
<p>　　a = a^b； 　　//a=00000110</p>
<p>　　位运算</p>
<p>　　位运算时把数字用二进制表示之后，对每一位上0或者1的运算。理解位运算的第一步是理解二进制。二进制是指数字的每一位都是0或者1.比如十进制的2转化为二进制之后就是10。</p>
<p>　　其实二进制的运算并不是很难掌握，因为位运算总共只有5种运算：与、或、异或、左移、右移。如下表：</p>
<p>　　<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvNzIzNjIxLzIwMTgxMS83MjM2MjEtMjAxODExMDkxMDI3MzIwODAtODA0NDkyNTQzLnBuZw?x-oss-process=image/format,png" alt="img"></p>
<p>　　左移运算：</p>
<p>　　左移运算符m《《n表示吧m左移n位。左移n位的时候，最左边的n位将被丢弃，同时在最右边补上n个0.比如：</p>
<p>　　<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvNzIzNjIxLzIwMTgxMS83MjM2MjEtMjAxODExMDkxMDI3NDk2OTQtMzE4MDA3NzY4LnBuZw?x-oss-process=image/format,png" alt="img"></p>
<p>　　右移运算：</p>
<p>　　右移运算符m》》n表示把m右移n位。右移n位的时候，最右边的n位将被丢弃。但右移时处理最左边位的情形要稍微复杂一点。这里要特别注意，如果数字是一个无符号数值，则用0填补最左边的n位。如果数字是一个有符号数值，则用数字的符号位填补最左边的n位。也就是说如果数字原先是一个正数，则右移之后再最左边补n个0；如果数字原先是负数，则右移之后在最左边补n个1.下面是堆两个8位有符号数作右移的例子：</p>
<p>　　<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvNzIzNjIxLzIwMTgxMS83MjM2MjEtMjAxODExMDkxMDI4MDk4OTUtMzc2MTY3MDQxLnBuZw?x-oss-process=image/format,png" alt="img"></p>
<p>　　关于移位的运算有这样的等价关系：把整数右移一位和把整数除以2在数学上是等价的。</p>
<p>　　<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvNzIzNjIxLzIwMTgxMS83MjM2MjEtMjAxODExMDkxMDI4MjIyODktMjMxODA5Njc1LnBuZw?x-oss-process=image/format,png" alt="img"></p>
<p>　　计算机内部只识别1、0，十进制需变成二进制才能使用移位运算符《《，》》 。</p>
<p>　　int j = 8;</p>
<p>　　p = j 《《 1;</p>
<p>　　cout《《p《《endl;</p>
<p>　　在这里，8左移一位就是8*2的结果16 。</p>
<p>　　移位运算是最有效的计算乘/除乘法的运算之一。</p>
<p>　　按位与（&amp;）其功能是参与运算的两数各对应的二进制位相与。只有对应的两个二进制位均为1时，结果位才为1，否则为0 。参与运算的数以补码方式出现。</p>
<p>　　先举一个例子如下：</p>
<p>　　题目：请实现一个函数，输入一个正数，输出该数二进制表示中1的个数。</p>
<p>　　<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvNzIzNjIxLzIwMTgxMS83MjM2MjEtMjAxODExMDkxMDI4MzQ1NTYtMTg3OTIzMjg1NS5wbmc?x-oss-process=image/format,png" alt="img"></p>
<p>　　这里用到了这样一个知识点：把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0 。 那么一个整数的二进制表示中有多少个1，就可以进行多少次这样的操作。</p>
<p>　　总结：把一个整数减去1之后再和原来的整数做位与运算，得到的结果相当于是把整数的二进制表示中的最右边一个1变成0 。</p>
<p>　　位运算的应用可以运用于很多场合：</p>
<p>　　清零特定位（mask中特定位置0，其它位为1 ， s = s &amp; mask）。</p>
<p>　　取某数中指定位（mask中特定位置，其它位为0， s = s &amp; mask）。</p>
<p>　　举例：输入两个整数m和n，计算需要改变m的二进制表示中的多少位才能得到n。</p>
<p>　　解决方法：第一步，求这两个数的异或；第二步，统计异或结果中1的位数。</p>
<p>　　<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvNzIzNjIxLzIwMTgxMS83MjM2MjEtMjAxODExMDkxMDI4NDY4NDItMTUxMzU2MjAwNi5wbmc?x-oss-process=image/format,png" alt="img"></p>
<p>　　接下来我们再举一例，就可以更好的说明移位运算了：用一条语句判断一个整数是不是2的整数次方。</p>
<p>　　解决方法：一个整数如果是2的整数次方，那么它的二进制表示中有且只有一位是1，而其它所有位都是0 。 根据前面的分析，把这个整数减去1后再和它自己做与运算，这个整数中唯一的1就变成0了。</p>
<p>　　解答：！（x &amp; （x - 1））</p>
<h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3><h3 id="【题目】"><a href="#【题目】" class="headerlink" title="【题目】"></a>【题目】</h3><blockquote>
<p>给一个数组arr，其中只有一个数出现了奇数次，其它数出现了偶数次，打印这个数。</p>
</blockquote>
<h3 id="【输入】"><a href="#【输入】" class="headerlink" title="【输入】"></a>【输入】</h3><blockquote>
<p> 输出包含两行，第一行包含一个整数n（1 \leq n \leq 10^5）（1≤n≤105），代表数组arr长度，第二行有n个数，代表数组arrarr_i 为32位整数arri为32位整数。输出包含两行，第一行包含一个整数n（1 \leq n \leq 10^5）（1≤n≤105），代表数组arr长度，第二行有n个数，代表数组arrarr_i 为32位整数arri为32位整数。</p>
</blockquote>
<h3 id="【输出】"><a href="#【输出】" class="headerlink" title="【输出】"></a>【输出】</h3><blockquote>
<p>输出一个整数，代表出现次数为奇数次的那个数。</p>
</blockquote>
<h3 id="【示例】"><a href="#【示例】" class="headerlink" title="【示例】"></a>【示例】</h3><blockquote>
<p>输入：5</p>
<p>​      3 1 3 1 2</p>
<p>输出：2</p>
</blockquote>
<h3 id="【复杂度】"><a href="#【复杂度】" class="headerlink" title="【复杂度】"></a>【复杂度】</h3><blockquote>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">时间复杂度<span class="built_in">O</span>(n),额外空间复杂度<span class="built_in">O</span>(<span class="number">1</span>)。</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="【代码】"><a href="#【代码】" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//每次将输入的值进行异或运算</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;count;i++)&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            res ^= tmp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(res);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="进阶：数组中存在两个出现奇数次的数"><a href="#进阶：数组中存在两个出现奇数次的数" class="headerlink" title="进阶：数组中存在两个出现奇数次的数"></a>进阶：数组中存在两个出现奇数次的数</h1><h3 id="【题目】-1"><a href="#【题目】-1" class="headerlink" title="【题目】"></a>【题目】</h3><blockquote>
<p>给定一个数字arr，其中只有两个数字出现了奇数次，其它数字都出现了偶数次，按照从小到大顺序输出这两个数。 </p>
</blockquote>
<h3 id="【输入】-1"><a href="#【输入】-1" class="headerlink" title="【输入】"></a>【输入】</h3><blockquote>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">第一行输入一个<span class="built_in">n</span>，第二行输入<span class="built_in">n</span>个数</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="【输出】-1"><a href="#【输出】-1" class="headerlink" title="【输出】"></a>【输出】</h3><blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出出现奇数次的两个数，按照从小到大的顺序。 </span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="【示例】-1"><a href="#【示例】-1" class="headerlink" title="【示例】"></a>【示例】</h3><blockquote>
<p>输入 4</p>
<p>​     1 1 2 3<br>输出<br>​    2 3</p>
</blockquote>
<h3 id="【分析】"><a href="#【分析】" class="headerlink" title="【分析】"></a>【分析】</h3><ol>
<li><p>先把数组中所有数全部<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=异或运算&amp;spm=1001.2101.3001.7020">异或运算</a>，得到的结果为两个所求数ab的异或值</p>
</li>
<li><p>由于ab异或的值不为0（因为如果为0，那么意味着ab相等），所以ab的二进制位中必然存在一个不相等的位，对ab两个数进行异或运算时，这个位上的运算结果为1，所以要先找到ab异或结果中为1的位置（找到一位即可），那么我们找最右侧的1</p>
<p>寻找的方法是：把ab异或后的结果eor<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=取反&amp;spm=1001.2101.3001.7020">取反</a>后加1，然后与eor进行并运算（rightOne的结果如：（00000100）</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> rightOne = <span class="keyword">eor</span> &amp; (~<span class="keyword">eor</span> +<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>筛选出所有在该位置上不为1的数进行异或运算（这样做的目的是把a和b分开，进行异或运算得到其中一个数）</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">if</span><span class="params">((cur &amp; rightOne)</span></span> == <span class="number">0</span>)             <span class="comment">//筛选出所有在该位置上不为1的数进行异或</span></span><br><span class="line"><span class="function"><span class="title">if</span><span class="params">((cur &amp; rightOne)</span></span> == rightOne)      <span class="comment">//筛选出所有在该位置上为1的数进行异或</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>这样，有了a和b的异或值，有了a或b的值，那么将eor和neweor异或就能得到另一个值</p>
</li>
</ol>
<h3 id="【代码】-1"><a href="#【代码】-1" class="headerlink" title="【代码】"></a>【代码】</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[count];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//求出总体的异或和</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;count; i++)&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            arr[i] = sc.nextInt();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            total ^= arr[i];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//取出异或和的最右侧的‘1’位</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        total = total &amp; (~total + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">even</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">odd</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;count; i++)&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//‘1’位上为0的数进行异或和</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>((arr[i]&amp;total) == <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                even ^= arr[i];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//‘1’位上位1的数异或求和</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                odd ^= arr[i];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        res[<span class="number">0</span>] = even&lt;odd?even:odd;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        res[<span class="number">1</span>] = even+odd-res[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(res[<span class="number">0</span>]+<span class="string">&quot; &quot;</span>+res[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="day-10-15"><a href="#day-10-15" class="headerlink" title="day 10.15"></a>day 10.15</h1><h2 id="求两点之间的距离（两点距离平方再开方）"><a href="#求两点之间的距离（两点距离平方再开方）" class="headerlink" title="求两点之间的距离（两点距离平方再开方）"></a>求两点之间的距离（两点距离平方再开方）</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://dss0.baidu.com/6ONWsjip0QIZ8tyhnq/it/u=2977505688,268921554&amp;fm=58" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sqrt(abs((x1 - x2) * (x1 - x2)) + abs((y1 - y2) * (y1 - y2)));</span><br></pre></td></tr></table></figure>
<h1 id="day10-16"><a href="#day10-16" class="headerlink" title="day10.16"></a>day10.16</h1><h2 id="求素数方法"><a href="#求素数方法" class="headerlink" title="求素数方法"></a>求素数方法</h2><h3 id="1-开根"><a href="#1-开根" class="headerlink" title="1.开根"></a>1.开根</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isprime</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="comment">//判断是否素数</span></span><br><span class="line">	<span class="keyword">if</span>(x&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//如果小于2，一定不是素数</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="built_in">sqrt</span>(x);i++)&#123;<span class="comment">//为什么要到sqrt(x)呢，因为如果有一个大于sqrt(n)的数可以被n整除，那么必有一个数n/i也可以被n整除且小于i</span></span><br><span class="line">		<span class="keyword">if</span>(x%i==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//如果可以整除，那么不是素数</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//是素数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-开根优化"><a href="#2-开根优化" class="headerlink" title="2.开根优化"></a>2.开根优化</h3><p>有一个优化的代码，速度是上面的3倍，可以看一看</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isprime</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">2</span>||n==<span class="number">3</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(n%<span class="number">6</span>!=<span class="number">1</span>&amp;&amp;n%<span class="number">6</span>!=<span class="number">5</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">5</span>;i*i&lt;=n;i+=<span class="number">6</span>) <span class="keyword">if</span>(n%i==<span class="number">0</span>||n%(i+<span class="number">2</span>)==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除2,3外，其他所有素数都必须是6<em>n</em>+1或6<em>n</em>+5，因为6n+2=2(3n+1) 6<em>n</em>+2=2(3<em>n</em>+1)，6n+3=3(2n+1) 6<em>n</em>+4=2(3<em>n</em>+2)，都有非1和本身因数，不是素数</p>
<h3 id="3-欧拉筛法（最优解）："><a href="#3-欧拉筛法（最优解）：" class="headerlink" title="3.欧拉筛法（最优解）："></a>3.欧拉筛法（最优解）：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> n,m;</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">10000001</span>]=&#123;<span class="number">1</span>,<span class="number">1</span>&#125;;<span class="comment">//0，1均既不是素数，也不是和数，所以先标记为不是</span></span><br><span class="line"><span class="type">int</span> Prime[<span class="number">10000001</span>],k;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prime</span><span class="params">(<span class="type">long</span> <span class="type">long</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)<span class="comment">//最小的素数是2</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])</span><br><span class="line">        &#123;</span><br><span class="line">            Prime[++k]=i;<span class="comment">//如果是素数就标记一下</span></span><br><span class="line">         &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=k;j++)<span class="comment">//j小于当前所有的素数的个数</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(Prime[j]*i&gt;n)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            vis[Prime[j]*i]=<span class="literal">true</span>;<span class="comment">//用素数依次×i，结果标记为合数</span></span><br><span class="line">            <span class="keyword">if</span>(i%Prime[j]==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//欧拉筛法，就是拿当前的数×之前的筛出来的素数，这个数即为合数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">prime</span>(<span class="number">100001</span>);<span class="comment">//在10的5次方范围内筛素数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t;</span><br><span class="line">        cin&gt;&gt;t;</span><br><span class="line">        <span class="keyword">if</span>(!vis[t])<span class="comment">//上面标记过了，这时输入后直接判断就行了</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;t&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-最后：埃氏筛法（比欧拉筛法更容易理解）"><a href="#4-最后：埃氏筛法（比欧拉筛法更容易理解）" class="headerlink" title="4.最后：埃氏筛法（比欧拉筛法更容易理解）"></a>4.最后：埃氏筛法（比欧拉筛法更容易理解）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">100001</span>]=&#123;<span class="number">1</span>,<span class="number">1</span>&#125;;<span class="comment">//0,1标为不是</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Era</span><span class="params">(<span class="type">int</span> qwq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=qwq;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;<span class="comment">//是合数就不执行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i*<span class="number">2</span>;j&lt;=qwq;j+=i)<span class="comment">//从i×2开始筛，因为进过判断后i为素数</span></span><br><span class="line">        &#123;</span><br><span class="line">            vis[j]=<span class="literal">true</span>;<span class="comment">//j=i的倍数，每次加i，即为i的倍数每次加1，p数组的第j个元素标为合数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> tmp;</span><br><span class="line">    <span class="built_in">Era</span>(<span class="number">100001</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;tmp);</span><br><span class="line">        <span class="keyword">if</span>(!vis[tmp])<span class="comment">//已经记下了，判断一下即可</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;tmp&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;<span class="comment">//真就不是，假就是</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="分治-杨辉三角-递归"><a href="#分治-杨辉三角-递归" class="headerlink" title="分治/杨辉三角/递归"></a>分治/杨辉三角/递归</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>现有 $2^n\times 2^n (n\le10)$ 名作弊者站成一个正方形方阵等候 kkksc03 的发落。kkksc03 决定赦免一些作弊者。他将正方形矩阵均分为 4 个更小的正方形矩阵，每个更小的矩阵的边长是原矩阵的一半。其中左上角那一个矩阵的所有作弊者都将得到赦免，剩下 3 个小矩阵中，每一个矩阵继续分为 4 个更小的矩阵，然后通过同样的方式赦免作弊者……直到矩阵无法再分下去为止。所有没有被赦免的作弊者都将被处以棕名处罚。</p>
<p>给出 $n$，请输出每名作弊者的命运，其中 0 代表被赦免，1 代表不被赦免。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>一个整数 $n$。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>$2^n \times 2^n$ 的 01 矩阵，代表每个人是否被赦免。数字之间有一个空格。</p>
<h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>本题基本思路是分治，代码可以通过递归来实现，每次递归将左上方的正方形清零，并再次递归剩余的三个正方形，当正方形的边长为2时结束递归。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,p=<span class="number">1</span>,a[<span class="number">1050</span>][<span class="number">1050</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">di</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> q)</span> <span class="comment">//x为正方形边长，l、q分别为递归正方形的横纵坐标</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==<span class="number">2</span>) <span class="comment">//递归边界</span></span><br><span class="line">	&#123;</span><br><span class="line">		a[l][q]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=l; i&lt;=l+x/<span class="number">2</span><span class="number">-1</span>; i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=q; j&lt;=q+x/<span class="number">2</span><span class="number">-1</span>; j++)</span><br><span class="line">			a[i][j]=<span class="number">0</span>; <span class="comment">//将左上方的正方形清零</span></span><br><span class="line">	<span class="built_in">di</span>(x/<span class="number">2</span>,l+x/<span class="number">2</span>,q);</span><br><span class="line">	<span class="built_in">di</span>(x/<span class="number">2</span>,l+x/<span class="number">2</span>,q+x/<span class="number">2</span>); </span><br><span class="line">	<span class="built_in">di</span>(x/<span class="number">2</span>,l,q+x/<span class="number">2</span>); <span class="comment">//此处是递归剩余的三个正方形</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">		p*=<span class="number">2</span>; <span class="comment">//计算正方形的边长</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=p; i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=p; j++)</span><br><span class="line">			a[i][j]=<span class="number">1</span>; <span class="comment">//将a数组先赋值为1</span></span><br><span class="line">	<span class="built_in">di</span>(p,<span class="number">1</span>,<span class="number">1</span>); <span class="comment">//开始递归</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=p; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=p<span class="number">-1</span>; j++)</span><br><span class="line">			cout&lt;&lt;a[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">		cout&lt;&lt;a[i][p]&lt;&lt;endl; <span class="comment">//输出，此处可以避免输出行尾空格</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h2><h2 id="集合求和"><a href="#集合求和" class="headerlink" title="集合求和"></a>集合求和</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个集合 $s$（集合元素数量 $\le 30$），求出此集合所有子集元素之和。</p>
<h3 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h3><p>集合中的元素（元素 $\le 1000$）</p>
<h3 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h3><p>$s$ 所有子集元素之和。</p>
<h2 id="-2"><a href="#-2" class="headerlink" title=" "></a> </h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">2 </span><span class="number">3</span></span><br></pre></td></tr></table></figure>
<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure>
<h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><p><strong>【样例解释】</strong></p>
<p>子集为：$\varnothing, { 2 }, { 3 }, { 2, 3 }$，和为 $2 + 3 + 2 + 3 = 10$。</p>
<hr>
<p><strong>【数据范围】</strong></p>
<p>对于 $100 \%$ 的数据，$1 \le \lvert s \rvert \le 30$，$1 \le s_i \le 1000$，$s$ 所有子集元素之和 $\le {10}^{18}$。</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/blog/feecle6418/solution-p2415">题解 P2415 【集合求和】 - feecle6418 的博客 - 洛谷博客 (luogu.com.cn)</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">31</span>],i=<span class="number">0</span>,j;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> s=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//cout&lt;&lt;s;</span></span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;a[i++]);<span class="comment">//合写cin&gt;&gt;a[i];i++;</span></span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">        s+=a[j];</span><br><span class="line">    &#125;</span><br><span class="line">    s*=<span class="built_in">pow</span>(<span class="number">2</span>,i<span class="number">-2</span>);<span class="comment">//注意，i-2!</span></span><br><span class="line">    cout&lt;&lt;s;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="day-10-17"><a href="#day-10-17" class="headerlink" title="day 10/17"></a>day 10/17</h1><h2 id="当需要循环的时候，试试加上总长度之后取余运算！（比如队列绕圈等）"><a href="#当需要循环的时候，试试加上总长度之后取余运算！（比如队列绕圈等）" class="headerlink" title="当需要循环的时候，试试加上总长度之后取余运算！（比如队列绕圈等）"></a>当需要循环的时候，试试加上总长度之后取余运算！（比如队列绕圈等）</h2><p>例题：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1563">P1563 [NOIP2016 提高组] 玩具谜题 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<h1 id="day-10-18"><a href="#day-10-18" class="headerlink" title="day 10/18"></a>day 10/18</h1><h2 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h2><p>此题解只面对与刚刚学算法的童鞋们</p>
<ul>
<li>什么情况下要<strong>使用高精度</strong>？</li>
</ul>
<p>当两个数超过longlong的大小并且要对这两个大数进行运算的时候。</p>
<ul>
<li>既然数这么大，我们用什么存放呢？</li>
</ul>
<p>用<strong>字符串</strong>存放。</p>
<ul>
<li>怎么运算呢？</li>
</ul>
<p>小学学加法的时候，我们是从最低位开始计算，两两相加，逢十进一。</p>
<p>我们也可以用计算机模拟这一过程。</p>
<p>具体代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>; j&lt;=<span class="built_in">max</span>(a[<span class="number">0</span>],b[<span class="number">0</span>])+<span class="number">1</span>; j++) &#123;</span><br><span class="line">	c[j]=a[j]+b[j];</span><br><span class="line">	<span class="keyword">if</span>(c[j]&gt;=<span class="number">10</span>) &#123;</span><br><span class="line">		c[j]%=<span class="number">10</span>;</span><br><span class="line">		a[j+<span class="number">1</span>]++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>既然要进行运算，我们总得知道字符串的长度吧？怎么获取呢？</li>
</ul>
<p>用<em>s<strong>t</strong>r<strong>l</strong>e</em>n函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="number">0</span>]=<span class="built_in">strlen</span>(s);</span><br><span class="line">b[<span class="number">0</span>]=<span class="built_in">strlen</span>(ss);</span><br></pre></td></tr></table></figure>
<ul>
<li>要运算，怎么知道某一位的具体数值是几呢？</li>
</ul>
<p>这个跟a<strong>s</strong>c<strong>l</strong>l码有关了。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/godwad/tianxuan4/main/tianxuan/1-1356-png_6_0_0_0_0_959_1356_959_1356-959-0-0-959.jpg" alt="img"></p>
<p>一个字符数字的a<strong>s</strong>c<strong>l</strong>l<em>码－48（也就是0的a<strong>s</strong>c<strong>l</strong>l</em>码）就是那个数字的a<strong>s</strong>c<strong>l</strong>l码。</p>
<p>转化过程：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=a[<span class="number">0</span>]; i++) a[i]=s[a[<span class="number">0</span>]-i]-<span class="string">&#x27;0&#x27;</span>;<span class="comment">//倒序存入数组，从低到高位</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=b[<span class="number">0</span>]; i++) b[i]=ss[b[<span class="number">0</span>]-i]-<span class="string">&#x27;0&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>☆ 注意：</p>
<h1 id="一定要考虑进位！！-1"><a href="#一定要考虑进位！！-1" class="headerlink" title="一定要考虑进位！！"></a>一定要考虑进位！！</h1><p>具体的说，就是最高位相加时可能会有进位，需特判。</p>
<p>如果d<strong>a</strong>l<strong>a</strong>o们看前面的不顺眼觉得蔡那看看这个：</p>
<p>读入第一行字符串A与第二行字符串B，</p>
<p>将两串字符串的每个字符转成数字存储在数组中，字符转数字的方式是：<strong>ch-’0’</strong></p>
<p>我们将个位存在a<em>[1]，高位存在a</em>[l]，l是数字位数，也即字符串长度。</p>
<p>字符串B<em>也用一个数组</em>b来记录。</p>
<p>高精度加法就是模拟加法的过程，我们要做的就是让a和b的每一位相加，并判断任意一位数是否大于等于1010，即应进位的问题。</p>
<p>处理完进位同时也要考虑最终和的位数（长度）是否有变化。 最终逐位输出达成输出大数的效果。</p>
<p>说了这么多，上一下A<em>C</em>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">1000001</span>],b[<span class="number">1000001</span>],c[<span class="number">1000001</span>],j;</span><br><span class="line"><span class="type">bool</span> x=<span class="literal">false</span>;</span><br><span class="line"><span class="type">char</span> s[<span class="number">1000001</span>],ss[<span class="number">1000001</span>];<span class="comment">//或string s,ss;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));</span><br><span class="line">	<span class="built_in">memset</span>(b,<span class="number">0</span>,<span class="built_in">sizeof</span>(b));</span><br><span class="line">	<span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="built_in">sizeof</span>(c));<span class="comment">//初始化</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>,s,ss);<span class="comment">//读入两个数</span></span><br><span class="line">	a[<span class="number">0</span>]=<span class="built_in">strlen</span>(s);</span><br><span class="line">	b[<span class="number">0</span>]=<span class="built_in">strlen</span>(ss);<span class="comment">//获取长度</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=a[<span class="number">0</span>]; i++) a[i]=s[a[<span class="number">0</span>]-i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=b[<span class="number">0</span>]; i++) b[i]=ss[b[<span class="number">0</span>]-i]-<span class="string">&#x27;0&#x27;</span>;<span class="comment">//转化为数字</span></span><br><span class="line">	<span class="keyword">for</span>(j=<span class="number">1</span>; j&lt;=<span class="built_in">max</span>(a[<span class="number">0</span>],b[<span class="number">0</span>])+<span class="number">1</span>; j++) &#123;</span><br><span class="line">		c[j]=a[j]+b[j];</span><br><span class="line">		<span class="keyword">if</span>(c[j]&gt;=<span class="number">10</span>) &#123;</span><br><span class="line">			c[j]%=<span class="number">10</span>;</span><br><span class="line">			a[j+<span class="number">1</span>]++;<span class="comment">//或者让c[j+1]++，然后上面换成c[j]+=a[j]+b[j];</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="comment">//模拟加法</span></span><br><span class="line">	c[<span class="number">0</span>]=j;</span><br><span class="line">	<span class="keyword">if</span>(c[j+<span class="number">1</span>]&gt;<span class="number">0</span>) c[<span class="number">0</span>]++;<span class="comment">//特判进位</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=c[<span class="number">0</span>]; i&gt;=<span class="number">1</span>; i--) &#123;<span class="comment">//输出（删除前导零）</span></span><br><span class="line">		<span class="keyword">if</span>(x==<span class="literal">false</span>&amp;&amp;c[i]==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">		x=<span class="literal">true</span>;</span><br><span class="line">		cout&lt;&lt;c[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(x==<span class="literal">false</span>) cout&lt;&lt;<span class="number">0</span>;<span class="comment">//一重保险</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);<span class="comment">//二重保险</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//三重保险</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在以后的学习中，高精度会成为一个很重（ke）要（pa）的算法，T<em>a</em>会成为一种工具。</p>
<h1 id="day-10-21"><a href="#day-10-21" class="headerlink" title="day 10/21"></a>day 10/21</h1><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1067">P1067 [NOIP2009 普及组] 多项式输出 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,a;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        cin&gt;&gt;a;</span><br><span class="line">        <span class="keyword">if</span>(a)&#123;    判<span class="number">0</span>系数</span><br><span class="line">            <span class="keyword">if</span>(i!=n&amp;&amp;a&gt;<span class="number">0</span>)cout&lt;&lt;<span class="string">&quot;+&quot;</span>;    根据正负、是否为最高此项决定加号</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(a)&gt;<span class="number">1</span>||i==<span class="number">0</span>)cout&lt;&lt;a;    输出系数（系数不为正负<span class="number">1</span>或指数为<span class="number">0</span>）</span><br><span class="line">            <span class="keyword">if</span>(a==<span class="number">-1</span>&amp;&amp;i)cout&lt;&lt;<span class="string">&quot;-&quot;</span>;    <span class="number">-1</span>系数特判，常数项已特判</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">1</span>)cout&lt;&lt;<span class="string">&quot;x^&quot;</span>&lt;&lt;i;    二次及以上输出指数</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">1</span>)cout&lt;&lt;<span class="string">&quot;x&quot;</span>;    一次项</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="day-10-22"><a href="#day-10-22" class="headerlink" title="day 10/22"></a>day 10/22</h1><h2 id="题目最后要求输出时，不一定都要最后一块输出，可以输入一组数据马上输出其对应的结果！！"><a href="#题目最后要求输出时，不一定都要最后一块输出，可以输入一组数据马上输出其对应的结果！！" class="headerlink" title="题目最后要求输出时，不一定都要最后一块输出，可以输入一组数据马上输出其对应的结果！！!"></a>题目最后要求输出时，不一定都要最后一块输出，可以输入一组数据马上输出其对应的结果！！!</h2><h2 id="sort与函数结合"><a href="#sort与函数结合" class="headerlink" title="sort与函数结合"></a>sort与函数结合</h2><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool </span>cmp(arr <span class="built_in">a1</span>,arr <span class="built_in">a2</span>)&#123;</span><br><span class="line">    if (<span class="built_in">a1</span>.chinese + <span class="built_in">a1</span>.english + <span class="built_in">a1</span>.math != <span class="built_in">a2</span>.chinese + <span class="built_in">a2</span>.english + <span class="built_in">a2</span>.math)</span><br><span class="line">    &#123;</span><br><span class="line">        return <span class="built_in">a1</span>.chinese + <span class="built_in">a1</span>.english + <span class="built_in">a1</span>.math &gt; <span class="built_in">a2</span>.chinese + <span class="built_in">a2</span>.english +<span class="built_in">a2</span>.math;</span><br><span class="line">    &#125;如果<span class="built_in">a1</span>总分比<span class="built_in">a2</span>总分高，则排在前面</span><br><span class="line">    if (<span class="built_in">a1</span>.chinese != <span class="built_in">a2</span>.chinese) &#123; return <span class="built_in">a1</span>.chinese &gt; <span class="built_in">a2</span>.chinese<span class="comment">; &#125;如果a1比a2语文成绩高，则排在前面</span></span><br><span class="line">  </span><br><span class="line">    return <span class="built_in">a1</span>.id &lt; <span class="built_in">a2</span>.id<span class="comment">;如果a1序号比a2序号小，则排在前面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="堆（重要！！！）"><a href="#堆（重要！！！）" class="headerlink" title="堆（重要！！！）"></a>堆（重要！！！）</h2><h3 id="什么是堆"><a href="#什么是堆" class="headerlink" title="什么是堆"></a>什么是堆</h3><p>堆（英语：heap)是计算机科学中一类特殊的数据结构的统称。堆通常是一个可以被看做一棵树的数组对象。</p>
<h3 id="堆的定义"><a href="#堆的定义" class="headerlink" title="堆的定义"></a>堆的定义</h3><ul>
<li>堆中某个节点的值总是<strong>不大于或不小于其父节点的值</strong>；</li>
<li>堆总是一棵<strong>完全二叉树</strong>。</li>
</ul>
<h3 id="堆的分类"><a href="#堆的分类" class="headerlink" title="堆的分类"></a>堆的分类</h3><p>分<strong>大根堆</strong>和<strong>小根堆</strong></p>
<p>例如：</p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">                    / \</span><br><span class="line">                  <span class="number"> 2 </span>  8</span><br><span class="line">                  /\   /\</span><br><span class="line">                <span class="number"> 3 </span><span class="number"> 7 </span>8 <span class="number"> 9 </span></span><br></pre></td></tr></table></figure>
<p>这是一个小根堆。小根堆的定义是：任何一个子节点都不小于它的父节点。因此，堆的根节点总是最小。</p>
<p>又例如：</p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">9</span><br><span class="line">                    / \</span><br><span class="line">                  <span class="number"> 6 </span>  8</span><br><span class="line">                  /\   /\</span><br><span class="line">                <span class="number"> 3 </span><span class="number"> 2 </span>1 <span class="number"> 4 </span>		</span><br></pre></td></tr></table></figure>
<p>这是一个大根堆。大根堆的定义是：任何一个子节点都不大于它的父节点。因此，堆的根节点总是最大。</p>
<h3 id="堆的存储与遍历。"><a href="#堆的存储与遍历。" class="headerlink" title="堆的存储与遍历。"></a>堆的存储与遍历。</h3><p>堆用数组存储。</p>
<p>拿上面的小根堆举例</p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">                    / \</span><br><span class="line">                  <span class="number"> 2 </span>  8</span><br><span class="line">                  /\   /\</span><br><span class="line">                <span class="number"> 3 </span><span class="number"> 7 </span>8 <span class="number"> 9 </span></span><br></pre></td></tr></table></figure>
<p>用数组存储就是：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center">6</th>
<th style="text-align:center">7</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">8</td>
<td style="text-align:center">3</td>
<td style="text-align:center">7</td>
<td style="text-align:center">8</td>
<td style="text-align:center">9</td>
</tr>
</tbody>
</table>
</div>
<p>显然，堆的存储是按照每一层的顺序存进数组里的。</p>
<p>那么，怎么找到一个堆的父亲与儿子？</p>
<p>拿第二个点2举例。</p>
<p>如图，第二个点2的父亲是第一个点1，第二个点2的儿子为第四个点3与第五个点7。</p>
<p>得出结论：一个点的父亲为这个点的数组下表整除2;一个点的儿子为这个点的数组下标乘2或乘2加1.</p>
<p>很好理解吧。</p>
<h3 id="堆的操作。"><a href="#堆的操作。" class="headerlink" title="堆的操作。"></a>堆的操作。</h3><p>重点是如何维护一个堆。</p>
<p>在运行代码的时候，经常会从堆里面插入元素或取出元素。</p>
<p>因此堆的秩序经常会被打乱。</p>
<p>维护堆需要掌握两个操作：将一个点上浮或下沉。</p>
<p>这里拿小根堆举例，大根堆也是一样的。</p>
<h4 id="下沉操作："><a href="#下沉操作：" class="headerlink" title="下沉操作："></a>下沉操作：</h4><p>这里我将点一更改成9</p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">9</span><br><span class="line">                    / \</span><br><span class="line">                  <span class="number"> 2 </span>  8</span><br><span class="line">                  /\   /\</span><br><span class="line">                <span class="number"> 3 </span><span class="number"> 7 </span>8 <span class="number"> 9 </span></span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center">6</th>
<th style="text-align:center">7</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center">2</td>
<td style="text-align:center">8</td>
<td style="text-align:center">3</td>
<td style="text-align:center">7</td>
<td style="text-align:center">8</td>
<td style="text-align:center">9</td>
</tr>
</tbody>
</table>
</div>
<p>它已经不是一个正常的堆了，至少不是一个正常的小根堆。</p>
<p>这时候我们就要将它下沉。</p>
<p>下沉关键代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">//x为需要下沉的点的下标</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>((a[x]&gt;=a[x*<span class="number">2</span>]&amp;&amp;x*<span class="number">2</span>&lt;=n)||(a[x]&gt;=a[<span class="number">2</span>*x+<span class="number">1</span>]&amp;&amp;x*<span class="number">2</span>+<span class="number">1</span>&lt;=n))<span class="comment">//只要找到有一个点小于它，那么就下沉，直无法下沉为止。。</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[x*<span class="number">2</span>]&lt;=a[x*<span class="number">2</span>+<span class="number">1</span>])<span class="comment">//两个子节点，往更小的地方下沉。</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(a[x],a[x*<span class="number">2</span>]);</span><br><span class="line">            x*=<span class="number">2</span>;<span class="comment">//需要改变下标。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(a[x],a[x*<span class="number">2</span>+<span class="number">1</span>]);</span><br><span class="line">            x=<span class="number">2</span>*x+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下沉之后它就成了这样：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line">                    / <span class="string">\</span></span><br><span class="line">                   <span class="number">3</span>   <span class="number">8</span></span><br><span class="line">                  /<span class="string">\</span>   /<span class="string">\</span></span><br><span class="line">                 <span class="number">9</span>  <span class="number">7</span> <span class="number">8</span>  <span class="number">9</span></span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center">6</th>
<th style="text-align:center">7</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">8</td>
<td style="text-align:center">9</td>
<td style="text-align:center">7</td>
<td style="text-align:center">8</td>
<td style="text-align:center">9</td>
</tr>
</tbody>
</table>
</div>
<p>符合堆的性质。</p>
<h4 id="上浮操作："><a href="#上浮操作：" class="headerlink" title="上浮操作："></a>上浮操作：</h4><p>比下沉简单多了，不作太多讲解。</p>
<p>拿小根堆举例，当一个节点的父节点比它大，那么它就上浮until它呆在它应有的位置为止。</p>
<p>上浮代码：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void up(int <span class="keyword">x</span>)</span><br><span class="line">&#123;</span><br><span class="line">    while(a[<span class="keyword">x</span>]&lt;a[<span class="keyword">x</span>/<span class="number">2</span>]&amp;&amp;<span class="keyword">x</span>&gt;<span class="number">1</span>)//注意这个<span class="keyword">x</span>&gt;<span class="number">1</span>。如果没了它可能会使<span class="keyword">x</span>变成<span class="number">0</span>。</span><br><span class="line">    &#123;</span><br><span class="line">        swap(a[<span class="keyword">x</span>]<span class="punctuation">,</span>a[<span class="keyword">x</span>/<span class="number">2</span>])<span class="comment">;</span></span><br><span class="line">        <span class="keyword">x</span>/<span class="operator">=</span><span class="number">2</span><span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><p>往堆里面插入一个元素，可能会使堆不正常。</p>
<p>那么这样做，（不分大小根堆）：</p>
<p>1.最大下标加1，一个元素插入堆底（数组后）。</p>
<p>2.对它实行上升操作。</p>
<p>上代码可能会好理解一点。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a[++n]=x;</span><br><span class="line">    <span class="built_in">up</span>(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="建堆操作"><a href="#建堆操作" class="headerlink" title="建堆操作"></a>建堆操作</h4><p>好吧重点来了。</p>
<p>这里讲的建堆，就是给你很多数字，把它存进数组里使其变成一个堆。</p>
<p>注意，排序一遍之后再建堆也是可以的，但是你既然排序过了还用什么堆排呢？</p>
<p>很简单。</p>
<p>1.最大标加1，插入队尾。</p>
<p>2.上升。</p>
<p>3.回到1.，直到没有数据再次插入。</p>
<h4 id="删除堆顶元素"><a href="#删除堆顶元素" class="headerlink" title="删除堆顶元素"></a>删除堆顶元素</h4><p>很多人不知道为什么要删除。</p>
<p>其实当这个堆是一个正常的堆时，它的根节点总是最大或最小的。</p>
<p>堆排序只要求你把它输出出来，然后将根的值赋为堆底元素（即当前最大下标所指的数组，记得最大下标要减一），最后对堆顶（因为执行上一操作会打破堆的正常秩序）执行下沉操作。</p>
<p>给出代码：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="number">1</span>] <span class="operator">=</span>a[n]<span class="comment">;</span></span><br><span class="line">   n--<span class="comment">;</span></span><br><span class="line">   down(<span class="number">1</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>其中a数组是存储这个堆的数组，n为它的最大下标。</p>
<p>回到原题，这一题要求我们每次累加最大的。</p>
<p>我们就建大根堆。</p>
<p>具体注释代码会有的。</p>
<p>有些地方会编译错误，说不定是故意的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1000000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[N],n;<span class="comment">//a数组存储堆，n为堆的最大下标。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">//下沉</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>((a[x]&lt;=a[x*<span class="number">2</span>]&amp;&amp;x*<span class="number">2</span>&lt;=n)||(a[x]&lt;=a[<span class="number">2</span>*x+<span class="number">1</span>]&amp;&amp;x*<span class="number">2</span>+<span class="number">1</span>&lt;=n))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> wrong=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;<span class="comment">//检查异常情况</span></span><br><span class="line">            <span class="keyword">if</span>(a[x*<span class="number">2</span>]&gt;=a[x*<span class="number">2</span>+<span class="number">1</span>]) <span class="keyword">throw</span> wrong;<span class="comment">//当找出x的左儿子比x的右二子大（或相等）时停止try的运行并抛出异常。</span></span><br><span class="line">            <span class="built_in">swap</span>(a[x],a[x*<span class="number">2</span>+<span class="number">1</span>]);</span><br><span class="line">            x=<span class="number">2</span>*x+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">catch</span>(<span class="type">int</span> error)&#123;<span class="comment">//当接收到异常</span></span><br><span class="line">            <span class="keyword">if</span>(wrong == error)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(a[x],a[x*<span class="number">2</span>]);</span><br><span class="line">                x*=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//实际上这个try和throw和catch完全可以用if和else 和else if 代替，但是如此写比较正式（扯淡吧）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">//下沉</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(a[x]&gt;a[x/<span class="number">2</span>]&amp;&amp;x&gt;<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(a[x],a[x/<span class="number">2</span>]);</span><br><span class="line">        x/=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">//插入堆底</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a[++n]=x;</span><br><span class="line">    <span class="built_in">up</span>(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>,sum=<span class="number">0</span>,h;</span><br><span class="line">    <span class="type">int</span> nn;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;nn,&amp;h)<span class="comment">//nn代表要插入的元素数量，h代表书架的高度。</span></span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">1</span>;i&lt;=nn;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b);</span><br><span class="line">        <span class="built_in">work</span>(b);<span class="comment">//读入一个插入一个建堆。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> wrong = <span class="number">0</span>;</span><br><span class="line">        sum+=a[<span class="number">1</span>];<span class="comment">//大根堆，堆顶最大。</span></span><br><span class="line">        ans++;</span><br><span class="line">        <span class="keyword">try</span>&#123;	</span><br><span class="line">		<span class="keyword">if</span>(sum&gt;=h) <span class="keyword">throw</span> wrong;<span class="comment">//当高度足够时跳出。</span></span><br><span class="line">		a[<span class="number">1</span>] =a[n];</span><br><span class="line">		n--;</span><br><span class="line">		<span class="built_in">down</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">catch</span>(<span class="type">int</span> error)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(wrong==error)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h2 id="当代码能通过部分案例而不能完全通过时，考虑是不是结果越界了，可以考虑将数组开大一点"><a href="#当代码能通过部分案例而不能完全通过时，考虑是不是结果越界了，可以考虑将数组开大一点" class="headerlink" title="当代码能通过部分案例而不能完全通过时，考虑是不是结果越界了，可以考虑将数组开大一点"></a>当代码能通过部分案例而不能完全通过时，考虑是不是结果越界了，可以考虑将数组开大一点</h2><h2 id="欧几里德距离（两点之间距离公式）"><a href="#欧几里德距离（两点之间距离公式）" class="headerlink" title="欧几里德距离（两点之间距离公式）"></a>欧几里德距离（两点之间距离公式）</h2><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">	ans+=sqrt((a[i<span class="number">-1</span>].x-a[i].x)*(a[i<span class="number">-1</span>].x-a[i].x)+(a[i<span class="number">-1</span>].y-a[i].y)*(a[i<span class="number">-1</span>].y-a[i].y)+(a[i<span class="number">-1</span>].z-a[i].z)*(a[i<span class="number">-1</span>].z-a[i].z));//题意给的公式,sqrt是开根号</span><br><span class="line">	或者</span><br><span class="line">	ans+=sqrt(pow(s[i].x - s[j].x,<span class="number">2</span>) + pow(s[i].y - s[j].y,<span class="number">2</span>) + pow(s[i].z-s[j].z,<span class="number">2</span>));</span><br><span class="line">	</span><br><span class="line">printf(<span class="string">&quot;%.3lf&quot;</span>,ans);//保留三位小数</span><br></pre></td></tr></table></figure>
<h2 id="排序算法（几个数如何连接组成的和最大）"><a href="#排序算法（几个数如何连接组成的和最大）" class="headerlink" title="排序算法（几个数如何连接组成的和最大）"></a>排序算法（几个数如何连接组成的和最大）</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>设有 $n$ 个正整数 $a_1 \dots a_n$，将它们联接成一排，相邻数字首尾相接，组成一个最大的整数。</p>
<h3 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行有一个整数，表示数字个数 $n$。</p>
<p>第二行有 $n$ 个整数，表示给出的 $n$ 个整数 $a_i$。</p>
<h3 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h3><p>一个正整数，表示最大的整数</p>
<h3 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h3><h4 id="样例输入-1-1"><a href="#样例输入-1-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="symbol">13 </span><span class="number">312</span> <span class="number">343</span></span><br></pre></td></tr></table></figure>
<h4 id="样例输出-1-1"><a href="#样例输出-1-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h4><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">34331213</span></span><br></pre></td></tr></table></figure>
<h3 id="样例-2"><a href="#样例-2" class="headerlink" title="样例 #2"></a>样例 #2</h3><h4 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入 #2"></a>样例输入 #2</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="symbol">7 </span><span class="number">13</span> <span class="number">4</span> <span class="number">246</span></span><br></pre></td></tr></table></figure>
<h4 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出 #2"></a>样例输出 #2</h4><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">7424613</span></span><br></pre></td></tr></table></figure>
<h4 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h4><p>对于全部的测试点，保证 $1 \leq n \leq 20$，$1 \leq a_i \leq 10^9$。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">使用比较函数 cmp 后 sort 将字符串输出可得答案</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">bool</span> <span class="title">cmp</span>(<span class="params"><span class="built_in">string</span> a,<span class="built_in">string</span> b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b;<span class="comment">//比如19 219  21919比19219大</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="day-10-23"><a href="#day-10-23" class="headerlink" title="day 10/23"></a>day 10/23</h1><h2 id="求矩阵包含正方形和长方形个数（递归）"><a href="#求矩阵包含正方形和长方形个数（递归）" class="headerlink" title="求矩阵包含正方形和长方形个数（递归）"></a>求矩阵包含正方形和长方形个数（递归）</h2><p><strong>一、算正方形的个数</strong></p>
<p>1.如果我们固定了正方形的右下角(i,j),你能不能算出此时可能的正方形的个数？</p>
<p>2.显然，此时答案为Min(i,j).</p>
<p>3.所以可以枚举右下角，计算此时答案，求和即可。</p>
<p><strong>二、算长方形个数</strong></p>
<p>1.其实算长方形并不常见，但算矩形大家应该经常遇到，所以如果你会算矩形，再联系第一个问题，那答案就转化为 矩形个数-正方形个数.</p>
<p>2.像求解正方形个数一样，固定矩形右下角(i,j),显然此时矩形个数为i*j.</p>
<p>3.同理，求和即可.</p>
<p>时间复杂度：O(n*m)，是挺慢的，其实可以写成一个式子</p>
<p><strong>代码如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll n,m,i,j,sum=<span class="number">0</span>,sum1=<span class="number">0</span>;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">	  &#123;</span><br><span class="line">	    sum+=<span class="built_in">min</span>(i,j);</span><br><span class="line">	    sum1+=i*j;</span><br><span class="line">	  &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	cout&lt;&lt;sum&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;sum1-sum&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第二种算法："><a href="#第二种算法：" class="headerlink" title="第二种算法："></a>第二种算法：</h3><p>首先，统计一个n*m的矩形里有多少个正方形，长方形。</p>
<p>要明确，正方形和长方形都是矩形，那么n*m的矩形里的</p>
<p><strong>矩形数</strong>=<strong>正方形数</strong>+<strong>长方形数</strong></p>
<p>明确这一点后，就可以一次求出二者了</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/godwad/tianxuan4/main/tianxuan/51556.png" alt="img"> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/godwad/tianxuan4/main/tianxuan/51554.png" alt="img"></p>
<p>如图，长为2宽为1的小长方形用〇来表示，那么</p>
<p>横向排列的就有 <strong>（n-1）*m</strong> 个</p>
<p>竖向排列的就有 <strong>n*（m-1）</strong> 个</p>
<p>证明：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">∵ 矩形长不等于宽</span><br><span class="line"></span><br><span class="line">∴ 子矩形构成的矩阵的长宽是由原矩形长宽减去不同数而得</span><br><span class="line"></span><br><span class="line">即(n-<span class="selector-tag">b</span>)*(m-<span class="selector-tag">a</span>) (<span class="selector-tag">a</span>≠<span class="selector-tag">b</span>)</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/godwad/tianxuan4/main/tianxuan/51557.png" alt="img"></p>
<p>如图，用 · 表示长宽均为二的正方形</p>
<p>即有(n-1)*(m-1)个小正方形</p>
<p>证明：</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">∵正方形长等于宽</span><br><span class="line"></span><br><span class="line">   ∴子正方形构成的矩阵的长宽由原矩形长宽减去相同数而得</span><br><span class="line">   </span><br><span class="line">   即<span class="comment">(n-b)</span>*<span class="comment">(m-a)</span> <span class="comment">(a=b)</span></span><br></pre></td></tr></table></figure>
<hr>
<p>上代码！（最短）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> n,m,rec,sqr;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)<span class="comment">//循环，从n-0到n-(n-1)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;m; j++) &#123;<span class="comment">//循环，从m-0到m-(m-1)</span></span><br><span class="line">            <span class="keyword">if</span>(i==j) sqr+=(n-i)*(m-j);<span class="comment">//如果i==j，说明是正方形</span></span><br><span class="line">            <span class="keyword">else</span> rec+=(n-i)*(m-j);<span class="comment">//如果不等说明是矩形</span></span><br><span class="line">        &#125;</span><br><span class="line">    cout&lt;&lt;sqr&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;rec&lt;&lt;endl;<span class="comment">//输出</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="暴力枚举—for循环的魅力"><a href="#暴力枚举—for循环的魅力" class="headerlink" title="暴力枚举—for循环的魅力"></a>暴力枚举—for循环的魅力</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#include&lt;iostream&gt;  </span></span><br><span class="line">using namespace std;  </span><br><span class="line">int main()  </span><br><span class="line">&#123;  </span><br><span class="line">    int a,b,c,d,e,f,g,h,i,j,<span class="keyword">in</span>,<span class="attribute">x</span>=0;  </span><br><span class="line">    cin&gt;&gt;<span class="keyword">in</span>;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="attribute">a</span>=1;a&lt;=3;a++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="attribute">b</span>=1;b&lt;=3;b++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">for</span> (<span class="attribute">c</span>=1;c&lt;=3;c++)  </span><br><span class="line">            &#123;  </span><br><span class="line">                <span class="keyword">for</span> (<span class="attribute">d</span>=1;d&lt;=3;d++)  </span><br><span class="line">                &#123;  </span><br><span class="line">                    <span class="keyword">for</span> (<span class="attribute">e</span>=1;e&lt;=3;e++)  </span><br><span class="line">                    &#123;  </span><br><span class="line">                        <span class="keyword">for</span> (<span class="attribute">f</span>=1;f&lt;=3;f++)  </span><br><span class="line">                        &#123;  </span><br><span class="line">                            <span class="keyword">for</span> (<span class="attribute">g</span>=1;g&lt;=3;g++)  </span><br><span class="line">                            &#123;  </span><br><span class="line">                                <span class="keyword">for</span>(<span class="attribute">h</span>=1;h&lt;=3;h++)  </span><br><span class="line">                                &#123;  </span><br><span class="line">                                    <span class="keyword">for</span> (<span class="attribute">i</span>=1;i&lt;=3;i++)  </span><br><span class="line">                                    &#123;  </span><br><span class="line">                                        <span class="keyword">for</span> (<span class="attribute">j</span>=1;j&lt;=3;j++)  </span><br><span class="line">                                        &#123;  </span><br><span class="line">                                            <span class="keyword">if</span> (a+b+c+d+e+f+g+h+i+<span class="attribute">j</span>==in)  </span><br><span class="line">                                            &#123;  </span><br><span class="line">                                                x++;  </span><br><span class="line">                                            &#125;  </span><br><span class="line">                                        &#125;  </span><br><span class="line">                                    &#125;  </span><br><span class="line">                                &#125;  </span><br><span class="line">                            &#125;  </span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    cout&lt;&lt;x&lt;&lt;endl;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="attribute">a</span>=1;a&lt;=3;a++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="attribute">b</span>=1;b&lt;=3;b++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">for</span> (<span class="attribute">c</span>=1;c&lt;=3;c++)  </span><br><span class="line">            &#123;  </span><br><span class="line">                <span class="keyword">for</span> (<span class="attribute">d</span>=1;d&lt;=3;d++)  </span><br><span class="line">                &#123;  </span><br><span class="line">                    <span class="keyword">for</span> (<span class="attribute">e</span>=1;e&lt;=3;e++)  </span><br><span class="line">                    &#123;  </span><br><span class="line">                        <span class="keyword">for</span> (<span class="attribute">f</span>=1;f&lt;=3;f++)  </span><br><span class="line">                        &#123;  </span><br><span class="line">                            <span class="keyword">for</span> (<span class="attribute">g</span>=1;g&lt;=3;g++)  </span><br><span class="line">                            &#123;  </span><br><span class="line">                                <span class="keyword">for</span>(<span class="attribute">h</span>=1;h&lt;=3;h++)  </span><br><span class="line">                                &#123;  </span><br><span class="line">                                    <span class="keyword">for</span> (<span class="attribute">i</span>=1;i&lt;=3;i++)  </span><br><span class="line">                                    &#123;  </span><br><span class="line">                                        <span class="keyword">for</span> (<span class="attribute">j</span>=1;j&lt;=3;j++)  </span><br><span class="line">                                        &#123;  </span><br><span class="line">                                            <span class="keyword">if</span> (a+b+c+d+e+f+g+h+i+<span class="attribute">j</span>==in)  </span><br><span class="line">                                            &#123;  </span><br><span class="line">                                                cout&lt;&lt;a&lt;&lt;<span class="string">&quot; &quot;</span>;  </span><br><span class="line">                                                cout&lt;&lt;b&lt;&lt;<span class="string">&quot; &quot;</span>;  </span><br><span class="line">                                                cout&lt;&lt;c&lt;&lt;<span class="string">&quot; &quot;</span>;  </span><br><span class="line">                                                cout&lt;&lt;d&lt;&lt;<span class="string">&quot; &quot;</span>;  </span><br><span class="line">                                                cout&lt;&lt;e&lt;&lt;<span class="string">&quot; &quot;</span>;  </span><br><span class="line">                                                cout&lt;&lt;f&lt;&lt;<span class="string">&quot; &quot;</span>;  </span><br><span class="line">                                                cout&lt;&lt;g&lt;&lt;<span class="string">&quot; &quot;</span>;  </span><br><span class="line">                                                cout&lt;&lt;h&lt;&lt;<span class="string">&quot; &quot;</span>;  </span><br><span class="line">                                                cout&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>;  </span><br><span class="line">                                                cout&lt;&lt;j&lt;&lt;endl;  </span><br><span class="line">                                            &#125;  </span><br><span class="line">                                        &#125;  </span><br><span class="line">                                    &#125;  </span><br><span class="line">                                &#125;  </span><br><span class="line">                            &#125;  </span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>或者写成递归算法就是</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//来个短短的递归~~(估计没人看...)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,kind=<span class="number">0</span>,m1[<span class="number">10000</span>][<span class="number">10</span>],m2[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">peiliao</span><span class="params">(<span class="type">int</span> total,<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a==<span class="number">10</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (total==n) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">10</span>;j++) m1[kind][j]=m2[j];<span class="comment">//符合要求存起来~~ </span></span><br><span class="line">            kind++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (total&gt;=n) ;<span class="comment">//小小优化一下 </span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">3</span>;i++)&#123;</span><br><span class="line">          m2[a]=i;</span><br><span class="line">          <span class="built_in">peiliao</span>(total+i,a+<span class="number">1</span>);<span class="comment">//其实这和十连for没什么区别。。。 </span></span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">peiliao</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    cout&lt;&lt;kind&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;kind;j++)&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) cout&lt;&lt;m1[j][i]&lt;&lt;<span class="string">&quot; &quot;</span>; <span class="comment">//大家一定要记得打空格... </span></span><br><span class="line">     cout&lt;&lt;endl; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="dfs—-深度优先算法（回溯）"><a href="#dfs—-深度优先算法（回溯）" class="headerlink" title="dfs—-深度优先算法（回溯）"></a>dfs—-深度优先算法（回溯）</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> step)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>（到达目的地）&#123;</span><br><span class="line">	输出解</span><br><span class="line">	返回</span><br><span class="line">	&#125;</span><br><span class="line">合理的剪枝操作</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=枚举数；i++)&#123;</span><br><span class="line">	<span class="keyword">if</span>（满足条件）[</span><br><span class="line">	更新状态位；</span><br><span class="line">	<span class="built_in">dfs</span>(step+<span class="number">1</span>);</span><br><span class="line">	恢复状态位；</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">当进入一个递归完返回时记得把变量赋初值！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> r,a[<span class="number">100</span>],n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;<span class="comment">//搜索第k个数</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">if</span>(k&gt;r)&#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=r;i++)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="built_in">setw</span>(<span class="number">3</span>)&lt;&lt;a[i];<span class="comment">//输出，场宽为三</span></span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> ;<span class="comment">//回到前一层</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=a[k<span class="number">-1</span>]+<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        a[k]=i;</span><br><span class="line">        <span class="built_in">dfs</span>(k+<span class="number">1</span>);<span class="comment">//直接进行下一次调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    cin&gt;&gt;n&gt;&gt;r;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h3 id="当进入一个递归完返回时记得把变量赋初值！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！"><a href="#当进入一个递归完返回时记得把变量赋初值！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！" class="headerlink" title="当进入一个递归完返回时记得把变量赋初值！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！"></a><strong>当进入一个递归完返回时记得把变量赋初值！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！</strong></h3><h3 id="与其相近的模板，递归（比上面多传一个参数）"><a href="#与其相近的模板，递归（比上面多传一个参数）" class="headerlink" title="与其相近的模板，递归（比上面多传一个参数）"></a>与其相近的模板，递归（比上面多传一个参数）</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> m, n, b[<span class="number">21</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span>(<span class="params"><span class="built_in">int</span> start, <span class="built_in">int</span> total</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (n == total) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>;i &lt;= m;i++)</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">if</span> (b[i])&#123;cout &lt;&lt; i;	&#125;</span><br><span class="line">		&#125;	</span><br><span class="line">		cout &lt;&lt; endl;	<span class="keyword">return</span>;&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">int</span> i = start;i &lt;= m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		b[i] = <span class="number">1</span>;</span><br><span class="line">		f(i + <span class="number">1</span>, total+<span class="number">1</span>);</span><br><span class="line">		b[i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">	cin &gt;&gt; m &gt;&gt; n;<span class="comment">//从m个元素里面挑出来n个数</span></span><br><span class="line">	f(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="求回文数dfs算法（自己花两个小时写的写的-歪门邪道）"><a href="#求回文数dfs算法（自己花两个小时写的写的-歪门邪道）" class="headerlink" title="求回文数dfs算法（自己花两个小时写的写的,歪门邪道）"></a>求回文数dfs算法（自己花两个小时写的写的,歪门邪道）</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">灵感来自</span><br><span class="line">产生长度为 <span class="number">5</span> 的回文数：</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (d1 = <span class="number">1</span>; d1 &lt;= <span class="number">9</span>; d1+=<span class="number">2</span>) &#123;    <span class="comment">// 只有奇数才会是素数</span></span><br><span class="line">     <span class="keyword">for</span> (d2 = <span class="number">0</span>; d2 &lt;= <span class="number">9</span>; d2++) &#123;</span><br><span class="line">         <span class="keyword">for</span> (d3 = <span class="number">0</span>; d3 &lt;= <span class="number">9</span>; d3++) &#123;</span><br><span class="line">           palindrome = <span class="number">10000</span>*d1 + <span class="number">1000</span>*d2 +<span class="number">100</span>*d3 + <span class="number">10</span>*d2 + d1;<span class="comment">//(处理回文数...)</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">自己写的</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> step)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (step == <span class="number">0</span>) &#123; <span class="keyword">if</span> (<span class="built_in">isprime</span>(p)) &#123; cout &lt;&lt; p &lt;&lt; endl; &#125;<span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">9</span>;i += <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            temp1 = p;p += i * <span class="built_in">pow</span>(<span class="number">10</span>, <span class="number">2</span> * step + r) + i * <span class="built_in">pow</span>(<span class="number">10</span>, k);r++;k++;</span><br><span class="line">            <span class="built_in">dfs</span>(--step);</span><br><span class="line">            step++;r--;k--;</span><br><span class="line">            p = temp1;;</span><br><span class="line">        &#125;      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">9</span>;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (step == <span class="number">1</span>) &#123; temp2 = p;p += i * <span class="built_in">pow</span>(<span class="number">10</span>, k);<span class="built_in">dfs</span>(--step);  p = temp2;step++; &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            temp3 = p; p += i * <span class="built_in">pow</span>(<span class="number">10</span>, <span class="number">2</span> * step + r) + i * <span class="built_in">pow</span>(<span class="number">10</span>, k);r++;k++;</span><br><span class="line">            <span class="built_in">dfs</span>(--step);</span><br><span class="line">            step++;r--;k--;</span><br><span class="line">            p = temp3;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">实际上。。。</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isHWS</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> temp=num,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (temp!=<span class="number">0</span>) &#123;</span><br><span class="line">        ans=ans*<span class="number">10</span>+temp%<span class="number">10</span>;</span><br><span class="line">        temp/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ans==num)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="day-10-26"><a href="#day-10-26" class="headerlink" title="day 10/26"></a>day 10/26</h1><h2 id="01背包问题—-左右脑，"><a href="#01背包问题—-左右脑，" class="headerlink" title="01背包问题—-左右脑，"></a>01背包问题—-左右脑，</h2><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">01</span>背包算法</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="built_in">int</span> a[<span class="number">5</span>],i,j,k,<span class="built_in">sum</span>,<span class="built_in">t</span>,homework[<span class="number">21</span>],dp[<span class="number">2501</span>];</span><br><span class="line"><span class="built_in">int</span> main()&#123;</span><br><span class="line">	for(i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++)</span><br><span class="line">		cin&gt;&gt;a[i];</span><br><span class="line">	for(i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++)&#123;</span><br><span class="line">		<span class="built_in">sum</span>=<span class="number">0</span>;	</span><br><span class="line">		for(j=<span class="number">1</span>;j&lt;=a[i];j++)</span><br><span class="line">			&#123;cin&gt;&gt;homework[j];//输入</span><br><span class="line">			<span class="built_in">sum</span>+=homework[j];&#125;//总时间累加</span><br><span class="line">		for(j=<span class="number">1</span>;j&lt;=a[i];j++)</span><br><span class="line">			for(k=<span class="built_in">sum</span>/<span class="number">2</span>;k&gt;=homework[j];k--)//只要是总和的一半</span><br><span class="line">				dp[k]=<span class="built_in">max</span>(dp[k],dp[k-homework[j]]+homework[j]);//<span class="number">01</span>背包</span><br><span class="line">		<span class="built_in">t</span>+=<span class="built_in">sum</span>-dp[<span class="built_in">sum</span>/<span class="number">2</span>];//累加为另一个脑子</span><br><span class="line">		for(j=<span class="number">1</span>;j&lt;=<span class="built_in">sum</span>/<span class="number">2</span>;j++)</span><br><span class="line">		dp[j]=<span class="number">0</span>;//清零</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;<span class="built_in">t</span>;//输出</span><br><span class="line">	return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dfs算法</span><br><span class="line"></span><br><span class="line">void f(<span class="built_in">int</span> <span class="built_in">left</span>,<span class="built_in">int</span> <span class="built_in">right</span>,<span class="built_in">int</span> step,<span class="built_in">int</span> <span class="built_in">n</span>)&#123;</span><br><span class="line"><span class="built_in">if</span>(step==s[<span class="built_in">n</span>])&#123;</span><br><span class="line"><span class="built_in">int</span> tmp= <span class="built_in">max</span>(<span class="built_in">left</span>,<span class="built_in">right</span>);</span><br><span class="line"><span class="built_in">if</span>(tmp &lt;mark[<span class="built_in">n</span>])mark[<span class="built_in">n</span>]=tmp;</span><br><span class="line">&#125;</span><br><span class="line">step++;</span><br><span class="line">f(<span class="built_in">time</span>[<span class="built_in">n</span>][step]+<span class="built_in">left</span>,<span class="built_in">right</span>,step,<span class="built_in">n</span>);</span><br><span class="line">f(<span class="built_in">left</span>,<span class="built_in">time</span>[nl[stepl+<span class="built_in">right</span>,step,<span class="built_in">n</span>)；</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="dfs算法另一种写法-跟左右脑相似"><a href="#dfs算法另一种写法-跟左右脑相似" class="headerlink" title="dfs算法另一种写法,跟左右脑相似"></a>dfs算法另一种写法,跟左右脑相似</h2><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2036">P2036 [COCI2008-2009#2] PERKET - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> step,<span class="type">int</span> suandu,<span class="type">int</span> kudu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (step == n) &#123;</span><br><span class="line">		 temp= <span class="built_in">abs</span>(suandu - kudu); </span><br><span class="line">		<span class="keyword">if</span> (temp &lt; max1 &amp;&amp; kudu != <span class="number">0</span>) &#123; max1 = temp; &#125;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	step++;</span><br><span class="line">	<span class="comment">///下面两行是重点！！！包含了所有情况</span></span><br><span class="line">	<span class="built_in">dfs</span>(step, suandu*a[step], kudu+b[step]);<span class="comment">///每一次在里面乘，不会影响外面的结果</span></span><br><span class="line">	<span class="built_in">dfs</span>(step, suandu, kudu);<span class="comment">//跳过这一次，不乘！！！</span></span><br><span class="line">	<span class="comment">///</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123; cin &gt;&gt; a[i]&gt;&gt;b[i]; &#125;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">0</span>,suandu,kudu);</span><br><span class="line">	cout &lt;&lt; temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="day10-27"><a href="#day10-27" class="headerlink" title="day10/27"></a>day10/27</h1><h2 id="斐波拉契数列-高精度求法-范围较大时"><a href="#斐波拉契数列-高精度求法-范围较大时" class="headerlink" title="斐波拉契数列+高精度求法(范围较大时)"></a>斐波拉契数列+高精度求法(范围较大时)</h2><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">long long n, a[<span class="number">10000</span>] = &#123; <span class="number">1</span> &#125;, b[<span class="number">10000</span>] = &#123; <span class="number">1</span> &#125;, c[<span class="number">10000</span>] = &#123; <span class="number">1</span> &#125;, clen = <span class="number">1</span>;</span><br><span class="line">void f() &#123;</span><br><span class="line">	int jw = <span class="number">0</span>;</span><br><span class="line">	for (int i = <span class="number">0</span>;i &lt;clen;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		c[i]= jw+a[i] + b[i];</span><br><span class="line">		jw = c[i] / <span class="number">10</span>;</span><br><span class="line">		c[i] <span class="comment">%= 10;</span></span><br><span class="line">	&#125;</span><br><span class="line">	if (jw != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		c[clen++] = jw;</span><br><span class="line">	&#125;</span><br><span class="line">	for (int i = <span class="number">0</span>;i&lt;clen;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		a[i] = b[i];</span><br><span class="line">		b[i] = c[i];</span><br><span class="line">	&#125;//相当于a=b c=b</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	a[<span class="number">0</span>] = <span class="number">1</span>;b[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	for (int i = <span class="number">2</span>;i &lt;= n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		f();</span><br><span class="line">	&#125;</span><br><span class="line">	for (int i = clen<span class="number">-1</span>;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; c[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="过河卒！！！本质为递归，梦开始的地方"><a href="#过河卒！！！本质为递归，梦开始的地方" class="headerlink" title="过河卒！！！本质为递归，梦开始的地方"></a>过河卒！！！本质为递归，梦开始的地方</h2><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1002">P1002 [NOIP2002 普及组] 过河卒 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<h3 id="核心思路：让它的上面一个点和左面的一个点加和，因为只能从这两种方向到达这个点。与斐波那契数列思路一样"><a href="#核心思路：让它的上面一个点和左面的一个点加和，因为只能从这两种方向到达这个点。与斐波那契数列思路一样" class="headerlink" title="核心思路：让它的上面一个点和左面的一个点加和，因为只能从这两种方向到达这个点。与斐波那契数列思路一样"></a>核心思路：让它的上面一个点和左面的一个点加和，因为只能从这两种方向到达这个点。与斐波那契数列思路一样</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">long long  tx, ty, mx, my,  arr<span class="comment">[30]</span><span class="comment">[30]</span> = &#123; 0 &#125;, tmp<span class="comment">[30]</span><span class="comment">[30]</span> = &#123; 0 &#125;;//</span><br><span class="line">数组开大点，防止越界！！！且用long long </span><br><span class="line">arr用来记录能不能走，</span><br><span class="line">tmp用来记录到达每个点分别有多少种方法，就是让它的上面和左面的点加和，因为只能从这两种方向到达这个点。</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	</span><br><span class="line">	cin &gt;&gt; tx &gt;&gt; ty &gt;&gt; mx &gt;&gt; my;</span><br><span class="line">	tx += 2;ty += 2;mx += 2;my += 2;//初始点加2</span><br><span class="line">	for (int i = 2;i &lt;= 30;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		tmp<span class="comment">[i]</span><span class="comment">[2]</span> = 1;</span><br><span class="line">		tmp<span class="comment">[2]</span><span class="comment">[i]</span> = 1;</span><br><span class="line">	&#125;//把第一行和第一列全赋值为1，因为只有一条路能到达！</span><br><span class="line">	arr<span class="comment">[mx+2]</span><span class="comment">[my+1]</span> = 1;</span><br><span class="line">	arr<span class="comment">[mx-1]</span><span class="comment">[my+2]</span> = 1;</span><br><span class="line">	arr<span class="comment">[mx+1]</span><span class="comment">[my+2]</span> = 1;</span><br><span class="line">	arr<span class="comment">[mx-2]</span><span class="comment">[my+1]</span> = 1;</span><br><span class="line">	arr<span class="comment">[mx]</span><span class="comment">[my]</span> = 1;</span><br><span class="line">	arr<span class="comment">[mx - 2]</span><span class="comment">[my - 1]</span> = 1;</span><br><span class="line">	arr<span class="comment">[mx-1]</span><span class="comment">[my-2]</span> = 1;</span><br><span class="line">	arr<span class="comment">[mx+1]</span><span class="comment">[my-2]</span> = 1;</span><br><span class="line">	arr<span class="comment">[mx+2]</span><span class="comment">[my-1]</span> = 1;</span><br><span class="line">	//将马所在的点和其余能跳到的8个点都赋值为1，表示不能到达</span><br><span class="line">	tmp<span class="comment">[2]</span><span class="comment">[1]</span> = 1;//起始点为2,2，到达方式为1，让<span class="comment">[2]</span><span class="comment">[1]</span>或者<span class="comment">[1]</span><span class="comment">[2]</span>=1都可，这样才能让<span class="comment">[2]</span><span class="comment">[2]</span>加和为1</span><br><span class="line">	for (int i = 2;i &lt;= 30;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		for (int j = 2;j &lt;= 30;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			if (arr<span class="comment">[i]</span><span class="comment">[j]</span> == 1) &#123; tmp<span class="comment">[i]</span><span class="comment">[j]</span> = 0;continue; &#125;//如果不能到达，则让其等于零，表示无法到达，也就不用加和了</span><br><span class="line">			tmp<span class="comment">[i]</span><span class="comment">[j]</span> = tmp<span class="comment">[i - 1]</span><span class="comment">[j]</span> + tmp<span class="comment">[i]</span><span class="comment">[j - 1]</span>;//让它的上面和左面的点加和，因为只能从这两种方向到达这个点</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; tmp<span class="comment">[tx]</span><span class="comment">[ty]</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="卡特兰数—-递归与栈"><a href="#卡特兰数—-递归与栈" class="headerlink" title="卡特兰数—-递归与栈"></a>卡特兰数—-递归与栈</h2><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1044">P1044 [NOIP2003 普及组] 栈 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<p>既然很多Dalao都说过，那我直接给式子了；</p>
<ul>
<li><strong>递推式11：</strong></li>
</ul>
<p><em>f</em>[<em>n</em>]=<em>f</em>[0]∗<em>f</em>[<em>n</em>−1]+<em>f</em>[1]∗<em>f</em>[<em>n</em>−2]+…+<em>f</em>[<em>n</em>−1]∗<em>f</em><a href="*n*≥2">0</a></p>
<p>然后按照这个递推式模拟就好了(代码后面给)</p>
<p>既然上面标了1，那就有递推式2~</p>
<ul>
<li><strong>递推式22：</strong></li>
</ul>
<p><em>h</em>[<em>n</em>]=<em>h</em>[<em>n</em>−1]∗(4∗<em>n</em>−2)/(<em>n</em>+1)</p>
<p>依旧按式子模拟(代码后面给)</p>
<p>既然有2，那再来个3吧~</p>
<ul>
<li><strong>递推式33：</strong></li>
</ul>
<p><em>h</em>[<em>n</em>]=<em>C</em>[2<em>n</em>,<em>n</em>]/(<em>n</em>+1)(<em>n</em>=0,1,2,…),<em>C</em>是组合数</p>
<p><em>P**S</em>:<em>C</em>[<em>m</em>,<em>n</em>]=<em>C</em>[<em>m</em>−1,<em>n</em>−1]+<em>C</em>[<em>m</em>−1,<em>n</em>]:且规定： </p>
<p>[0,0]=1<em>C</em>[<em>n</em>,0]=1<em>C</em>[<em>n</em>,<em>n</em>]=1<em>C</em>[0,0]=1</p>
<p><strong>这个公式也叫组合数公式(下面那个也是)</strong></p>
<p>（不知道组合数可以百度）</p>
<p>于是仍然把标程放到最后~</p>
<ul>
<li><strong>递推式44：</strong></li>
</ul>
<p><em>h</em>[<em>n</em>]=<em>C</em>[2<em>n</em>,<em>n</em>]−<em>C</em><a href="*n*=0,1,2,...">2<em>n</em>,<em>n</em>−1</a> 组合数<em>C</em>不解释了；</p>
<p><strong>没有55了</strong></p>
<p>但是有个Dalao写的组合数我没看懂，于是我搜集了各方资料，还是没看懂，不知道他写的组合数是怎么求的，虽然最后结果对了，但是组合数求出来都是错的(￣_￣|||)，不知道是不是巧合？</p>
<p>不管了，A<em>*C</em>就好；（程序还是后面给~）</p>
<ul>
<li>但是，出现了一个问题，上面介绍了四种公式，哪种最好？其实是第4种：如果这个数太大，那么题目可能会要求取模，那么第11种<em>n</em>太大的时候时空太大；第22种在取模运算中万一不小心整除了就凉了；第33种是除法运算，更行不通；唯有第44种,满足取模原则（加减无所谓），且不会出现倍数 <em>W**A</em> 的情况，所以第44种解为最优解；</li>
<li>接着，比较上面四种做法：很明显的，递推式长得差得不多，它们都源于卡特兰思想，那么就没什么好说的了，只是时空复杂度的不同而已；</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">h</span>(n)=<span class="built_in">h</span>(<span class="number">1</span>)∗<span class="built_in">h</span>(n−<span class="number">1</span>)+<span class="built_in">h</span>(<span class="number">2</span>)∗<span class="built_in">h</span>(n−<span class="number">2</span>)+...+<span class="built_in">h</span>(n−<span class="number">1</span>)<span class="built_in">h</span>(<span class="number">1</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">h</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">0</span> <span class="keyword">or</span> n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> a=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		a+=<span class="built_in">h</span>(i)*<span class="built_in">h</span>(n<span class="number">-1</span>-i);<span class="comment">//我是公式</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	cout&lt;&lt;<span class="built_in">h</span>(n);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="day10-28"><a href="#day10-28" class="headerlink" title="day10/28"></a>day10/28</h1><h2 id="记忆化"><a href="#记忆化" class="headerlink" title="记忆化"></a>记忆化</h2><p>记忆化一般出现在递归题中，由于递归会一次一次的调用先前已经调用过的值，可能会造成时间复杂度非常大，因此我们可以用一个数组等记录已经出现过的结果，等第二次在调用时可直接返回值。例题如下</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1464">P1464 Function - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a, b, c, f[<span class="number">30</span>][<span class="number">30</span>][<span class="number">30</span>];<span class="comment">//f数组即为记忆化数组，记下已经调用过的值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">w</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt;= <span class="number">0</span> || b &lt;= <span class="number">0</span> || c &lt;= <span class="number">0</span>) &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; <span class="number">20</span> || b &gt; <span class="number">20</span> || c &gt; <span class="number">20</span>) &#123; <span class="keyword">return</span>(<span class="built_in">w</span>(<span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>)); &#125;</span><br><span class="line">    <span class="keyword">if</span> (f[a][b][c] &gt; <span class="number">0</span>)<span class="keyword">return</span>(f[a][b][c]);<span class="comment">//这句只能前两句边界判断之后！！！一定要先判断边界！</span></span><br><span class="line">    <span class="keyword">if</span> (a &lt; b &amp;&amp; b &lt; c) &#123; f[a][b][c] = <span class="built_in">w</span>(a, b, c - <span class="number">1</span>) + <span class="built_in">w</span>(a, b - <span class="number">1</span>, c - <span class="number">1</span>) - <span class="built_in">w</span>(a, b - <span class="number">1</span>, c);<span class="keyword">return</span>(f[a][b][c]); &#125;</span><br><span class="line">    f[a][b][c] = <span class="built_in">w</span>(a - <span class="number">1</span>, b, c) + <span class="built_in">w</span>(a - <span class="number">1</span>, b - <span class="number">1</span>, c) + <span class="built_in">w</span>(a - <span class="number">1</span>, b, c - <span class="number">1</span>) - <span class="built_in">w</span>(a - <span class="number">1</span>, b - <span class="number">1</span>, c - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span>(f[a][b][c]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">-1</span> &amp;&amp; b == <span class="number">-1</span> &amp;&amp; c == <span class="number">-1</span>) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;w(%d, %d, %d) = %d\n&quot;</span>, a, b, c, <span class="built_in">w</span>(a, b, c));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="dfs超时后的新思路—-01背包（对于每一种物品，只有选中与未选中两种状态）！！！！！"><a href="#dfs超时后的新思路—-01背包（对于每一种物品，只有选中与未选中两种状态）！！！！！" class="headerlink" title="dfs超时后的新思路—-01背包（对于每一种物品，只有选中与未选中两种状态）！！！！！"></a>dfs超时后的新思路—-01背包（对于每一种物品，只有选中与未选中两种状态）！！！！！</h2><p>01背包原理：在选与不选之间抉择。若剩余的东西（比如钱）充足，办法总数就等于选这个东西的办法数与不选这个东西的办法数之和；若不充足，办法总数就只能承袭选择前i-1种东西的办法总数。依次递推，在最后，我们只要输出f[n][m]的值即可。</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1164">P1164 小A点菜 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/godwad/tianxuan4/main/tianxuan/image-20231028210225636.png" alt="image-20231028210225636"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m,value[<span class="number">105</span>] = &#123;<span class="number">0</span>&#125;, f[<span class="number">105</span>][<span class="number">1005</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; value[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)<span class="comment">//i代表菜品</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>;j &lt;= m;j++)<span class="comment">//j表示钱数</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (value[i] == j) &#123; f[i][j] = f[i - <span class="number">1</span>][j] + <span class="number">1</span>; &#125;<span class="comment">//如果价值等于钱数，选择这道菜以后就一种情况，再加上不选的情况</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (value[i] &gt; j) &#123; f[i][j] = f[i - <span class="number">1</span>][j]; &#125;<span class="comment">//如果价值大于钱数，就只有不选的情况</span></span><br><span class="line">			<span class="keyword">else</span> &#123; f[i][j] = f[i - <span class="number">1</span>][j] + f[i - <span class="number">1</span>][j - value[i]]; &#125;<span class="comment">//如果价值小于钱数，分为选与不选两种情况,选的情况要用钱数减去该物品价值</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; f[n][m];</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="当数据范围过大或长度超过限制时，就不要用暴力破解了，记得找规律！比如将第一个跟第二比，再把第一跟第三比"><a href="#当数据范围过大或长度超过限制时，就不要用暴力破解了，记得找规律！比如将第一个跟第二比，再把第一跟第三比" class="headerlink" title="当数据范围过大或长度超过限制时，就不要用暴力破解了，记得找规律！比如将第一个跟第二比，再把第一跟第三比"></a>当数据范围过大或长度超过限制时，就不要用暴力破解了，记得找规律！比如将第一个跟第二比，再把第一跟第三比</h2><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3612">P3612 [USACO17JAN] Secret Cow Code S - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	string s;<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> n,k,len=<span class="number">0</span>,len1=<span class="number">0</span>;cin &gt;&gt; s &gt;&gt; n;</span><br><span class="line">	len = s.<span class="built_in">length</span>();</span><br><span class="line">	k = len;</span><br><span class="line">	<span class="keyword">while</span> (n &gt; k)</span><br><span class="line">	&#123;</span><br><span class="line">		k *= <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (n &gt; len) &#123;</span><br><span class="line">		len1 = k / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (n &gt;= len1) &#123;</span><br><span class="line">			<span class="keyword">if</span> (n == len1) &#123; n--; &#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">else</span> &#123; n -= len1; &#125;</span><br><span class="line">		&#125;</span><br><span class="line">		k = k / <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; s[n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注意对特殊情况的判断，比如多项式最后一项没有加号"><a href="#注意对特殊情况的判断，比如多项式最后一项没有加号" class="headerlink" title="注意对特殊情况的判断，比如多项式最后一项没有加号"></a>注意对特殊情况的判断，比如多项式最后一项没有加号</h2><h2 id="当递归题涉及到两种不同的情况（比如两种长度不同的砖块），要对这两种情况分别讨论，最好建立两个数组，然后最好从最后算起，看他跟他的上一个有没有什么规律可找，即类似f-n-f-n-1-f-n-2-的"><a href="#当递归题涉及到两种不同的情况（比如两种长度不同的砖块），要对这两种情况分别讨论，最好建立两个数组，然后最好从最后算起，看他跟他的上一个有没有什么规律可找，即类似f-n-f-n-1-f-n-2-的" class="headerlink" title="当递归题涉及到两种不同的情况（比如两种长度不同的砖块），要对这两种情况分别讨论，最好建立两个数组，然后最好从最后算起，看他跟他的上一个有没有什么规律可找，即类似f(n)=f(n-1)+f(n+2)的"></a>当递归题涉及到两种不同的情况（比如两种长度不同的砖块），要对这两种情况分别讨论，最好建立两个数组，然后最好从最后算起，看他跟他的上一个有没有什么规律可找，即类似f(n)=f(n-1)+f(n+2)的</h2><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1990">P1990 覆盖墙壁 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="type">int</span> n, b2[<span class="number">10005</span>] = &#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span> &#125;, b3[<span class="number">10005</span>] = &#123; <span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span> &#125;;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>;i &lt;= n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		b2[i] = (b2[i - <span class="number">1</span>] + b2[i - <span class="number">2</span>] + <span class="number">2</span> * b3[i - <span class="number">1</span>])%<span class="number">10000</span>;</span><br><span class="line">		b3[i] = (b2[i - <span class="number">2</span>] + b3[i - <span class="number">1</span>])%<span class="number">10000</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; b2[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="当题目涉及的范围比较大的时候，比如100-100，要先拆分成一个一个的小单位，寻找有无规律可循，由局部推整体"><a href="#当题目涉及的范围比较大的时候，比如100-100，要先拆分成一个一个的小单位，寻找有无规律可循，由局部推整体" class="headerlink" title="当题目涉及的范围比较大的时候，比如100*100，要先拆分成一个一个的小单位，寻找有无规律可循，由局部推整体"></a>当题目涉及的范围比较大的时候，比如100*100，要先拆分成一个一个的小单位，寻找有无规律可循，由局部推整体</h2><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1228">P1228 地毯填补问题 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<h2 id="当前面都有规律可循，而到最后却没有规律的时候，不妨试试对最后几行打表（）"><a href="#当前面都有规律可循，而到最后却没有规律的时候，不妨试试对最后几行打表（）" class="headerlink" title="当前面都有规律可循，而到最后却没有规律的时候，不妨试试对最后几行打表（）"></a>当前面都有规律可循，而到最后却没有规律的时候，不妨试试对最后几行打表（）</h2><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1259">P1259 黑白棋子的移动 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<h1 id="day10-30"><a href="#day10-30" class="headerlink" title="day10-30"></a>day10-30</h1><h2 id="暴力算法—-结构体排序"><a href="#暴力算法—-结构体排序" class="headerlink" title="暴力算法—-结构体排序"></a>暴力算法—-结构体排序</h2><p>在计算排序大小时，可以构建数组，然后用sort(在algorithm头文件里)按照某种规则对数组进行排序</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1803">P1803 凌乱的yyy / 线段覆盖 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> time;</span><br><span class="line">	<span class="type">int</span> id;</span><br><span class="line">&#125;coin;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(coin c1, coin c2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> c1.time&lt;c2.time;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="type">int</span> n;<span class="type">double</span> result = <span class="number">0</span>; coin coin1[<span class="number">1000</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	cin &gt;&gt; n ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; coin1[i].time;</span><br><span class="line">		coin1[i].id = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(coin1+<span class="number">1</span>, coin1 + n+<span class="number">1</span>, cmp);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; coin1[i].id &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		result += (n - i) * coin1[i].time;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%.2lf&quot;</span>,result/n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="线段覆盖—-结构体排序"><a href="#线段覆盖—-结构体排序" class="headerlink" title="线段覆盖—-结构体排序"></a>线段覆盖—-结构体排序</h2><p>按时间排序，有先后顺序，问最多能参加多少场</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1803">P1803 凌乱的yyy / 线段覆盖 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span><span class="comment">//（万能库）</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">px</span>&#123;<span class="comment">//（定义一个结构体数组，分别储存开始时间和结束时间）</span></span><br><span class="line"><span class="type">int</span> a;<span class="comment">//（开始时间）</span></span><br><span class="line"><span class="type">int</span> b;<span class="comment">//（结束时间）</span></span><br><span class="line">&#125;x[<span class="number">2000000</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(px x,px y)</span></span>&#123;<span class="comment">//（不管开始时间，直接按照结束时间排序）</span></span><br><span class="line"><span class="keyword">return</span> x.b&lt;y.b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> n,sum=<span class="number">1</span>,mi;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">cin&gt;&gt;x[i].a&gt;&gt;x[i].b;<span class="comment">//（读入数据）</span></span><br><span class="line"><span class="built_in">sort</span>(x+<span class="number">1</span>,x+n+<span class="number">1</span>,cmp);<span class="comment">//（排序）</span></span><br><span class="line">mi=x[<span class="number">1</span>].b;<span class="comment">//（无脑记录第一个值）</span></span><br><span class="line"><span class="type">int</span> j=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(j&lt;=n)<span class="comment">//（未优化的超长循环）</span></span><br><span class="line">&#123;</span><br><span class="line">    j++;</span><br><span class="line">    <span class="keyword">if</span>(x[j].a&gt;=mi) &#123;<span class="comment">//（找到符合要求的比赛，记录，参加）</span></span><br><span class="line">    sum++;<span class="comment">//（计数）</span></span><br><span class="line">    mi=x[j].b;&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;sum;<span class="comment">//（输出）</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//（功德圆满）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="首位相连区域-若中间中断则从左至右"><a href="#首位相连区域-若中间中断则从左至右" class="headerlink" title="首位相连区域,若中间中断则从左至右"></a>首位相连区域,若中间中断则从左至右</h2><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5019">P5019 [NOIP2018 提高组] 铺设道路 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,a[<span class="number">100005</span>];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)     cin&gt;&gt;a[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)     <span class="keyword">if</span>(a[i]&gt;a[i<span class="number">-1</span>]) ans+=a[i]-a[i<span class="number">-1</span>];</span><br><span class="line">	cout&lt;&lt;ans+a[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="暴力算法中的双指针问题"><a href="#暴力算法中的双指针问题" class="headerlink" title="暴力算法中的双指针问题"></a>暴力算法中的双指针问题</h2><p>用左右两个指针分别遍历，往往是求最大值或是最小值时使用</p>
<p> <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1094">NOIP2007 普及组] 纪念品分组 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> <span class="type">int</span>  n,arr[<span class="number">3005</span>],result=<span class="number">0</span>,left=<span class="number">0</span>,right=<span class="number">0</span>;</span><br><span class="line">	<span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; arr[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(arr + <span class="number">1</span>, arr + n + <span class="number">1</span>);</span><br><span class="line">	left = <span class="number">1</span>;right = n;</span><br><span class="line">	result += arr[n] * arr[n];</span><br><span class="line">	<span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (flag) &#123;</span><br><span class="line">			flag = <span class="literal">false</span>;result += <span class="built_in">abs</span>((arr[left] - arr[right]) * (arr[left] - arr[right]));</span><br><span class="line">			right--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123; flag = <span class="literal">true</span>; result += <span class="built_in">abs</span>((arr[left] - arr[right]) * (arr[left] - arr[right]));</span><br><span class="line">		left++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; result;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4995">P4995 跳跳！ - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<h2 id="二叉树的排序和sort排序的简化（当超出时间复杂度时）"><a href="#二叉树的排序和sort排序的简化（当超出时间复杂度时）" class="headerlink" title="二叉树的排序和sort排序的简化（当超出时间复杂度时）"></a>二叉树的排序和sort排序的简化（当超出时间复杂度时）</h2><p>找两个最小的叶子结点相加，再拿相加之和与剩余节点相比，再找找两个最小的叶子结点相加，循环往复</p>
<p>此时用sort排序可能超时，我们可以只拿新的相加之和与数组剩余元素比较，节省时间，也叫冒泡单排序</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1090">P1090 [NOIP2004 提高组] 合并果子 / [USACO06NOV] Fence Repair G - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n, arr[<span class="number">10005</span>]=&#123;<span class="number">0</span>&#125;, result = <span class="number">0</span>;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; arr[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(arr + <span class="number">1</span>, arr + n + <span class="number">1</span>);<span class="comment">//先对原数组进行排序，下面对相加之后的新元素进行排序</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>;i &lt;= n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		result += arr[i] + arr[i - <span class="number">1</span>];</span><br><span class="line">		arr[i] = arr[i] + arr[i - <span class="number">1</span>];<span class="comment">//每次取最小的两个数相加</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>;j &lt;= n;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[j] &lt; arr[j - <span class="number">1</span>]) &#123; <span class="built_in">swap</span>(arr[j], arr[j - <span class="number">1</span>]); &#125;<span class="comment">//每次只拿这个新元素与数组元素比较，而sort排序需要对数组全新重排，这种方法可以减少时间复杂度</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="day11-2"><a href="#day11-2" class="headerlink" title="day11-2"></a>day11-2</h1><h2 id="在做有关于数字类的题目时，考虑0这种特殊情况！"><a href="#在做有关于数字类的题目时，考虑0这种特殊情况！" class="headerlink" title="在做有关于数字类的题目时，考虑0这种特殊情况！"></a>在做有关于数字类的题目时，考虑0这种特殊情况！</h2><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1106">P1106 删数问题 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<p>从s中找到n-k个数，让i从0到n-k-1进行循环，mark做标记，从mark到k+i进行循环，找到最小值</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="built_in">int</span> n, k, mark = o, flag = <span class="number">0</span>；</span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">find_min</span>(<span class="params"><span class="built_in">int</span> <span class="number">1</span>, <span class="built_in">int</span> r</span>)(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="built_in">char</span> minc = s[<span class="number">1</span>];</span></span></span><br><span class="line"><span class="params"><span class="function">mark = <span class="number">1</span> + <span class="number">1</span>;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">for</span>(<span class="built_in">int</span> i = mark; i &lt;= r; i++</span>)(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">if</span>(s[i] &lt; minc</span>)(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">minc = s[il;</span></span></span><br><span class="line"><span class="params"><span class="function">mark = i+ <span class="number">1</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;&#125;<span class="keyword">return</span> minc;&#125;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="built_in">int</span> main(</span>)(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">//输入数据<span class="built_in">string</span> s，<span class="built_in">int</span> k，求出n</span></span></span><br><span class="line"><span class="params"><span class="function">cin &gt;&gt; s &gt;&gt; k;</span></span></span><br><span class="line"><span class="params"><span class="function">n = s.length(</span>)</span>;</span><br><span class="line"><span class="comment">// 丛s 中找到n-k 个数</span></span><br><span class="line"><span class="comment">//i:θ - n-k-1 mark~k+i 找出最小值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n - k; i++)(</span><br><span class="line">cout &lt;&lt; find_min(mark, k + i);&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i =<span class="number">0</span>;i&lt; n -k;i++)&#123;</span><br><span class="line">tempi= find_min(mark,k +i);</span><br><span class="line"><span class="keyword">if</span>(tempi ==<span class="number">0</span> &amp;&amp;flag ==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">flag=<span class="number">1</span>;</span><br><span class="line">cout &lt;tempi;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="定义结构体数组时不要加typedef！！！"><a href="#定义结构体数组时不要加typedef！！！" class="headerlink" title="定义结构体数组时不要加typedef！！！"></a>定义结构体数组时不要加typedef！！！</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">struct</span> zu1&#123;</span><br><span class="line">	<span class="type">int</span> <span class="built_in">len</span>;</span><br><span class="line">	<span class="type">int</span> nowvalue;</span><br><span class="line">&#125;zu[<span class="number">100005</span>];</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="蜘蛛纸牌类排序问题写法"><a href="#蜘蛛纸牌类排序问题写法" class="headerlink" title="蜘蛛纸牌类排序问题写法"></a>蜘蛛纸牌类排序问题写法</h2><p> <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4447">AHOI2018初中组] 分组 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="type">int</span> n, arr[<span class="number">100005</span>],min1=<span class="number">9999</span>,number=<span class="number">0</span>,mark=<span class="number">0</span>;</span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">zu1</span>&#123;</span><br><span class="line">	<span class="type">int</span> len;</span><br><span class="line">	<span class="type">int</span> nowvalue;</span><br><span class="line"> &#125;zu[<span class="number">100005</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> flag = <span class="number">0</span>, find = <span class="number">0</span>,tnum=<span class="number">100005</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; mark;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (zu[i].nowvalue == k - <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (zu[i].len &lt; tnum)</span><br><span class="line">			&#123;</span><br><span class="line">				flag = i;find = <span class="number">1</span>;tnum = zu[i].len;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">		<span class="keyword">if</span> (find == <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">			zu[flag].nowvalue = k;</span><br><span class="line">			zu[flag].len++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			zu[mark].nowvalue = k;</span><br><span class="line">			zu[mark].len = <span class="number">1</span>;</span><br><span class="line">			mark++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; arr[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(arr , arr  + n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">insert</span>(arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt;mark;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (zu[i].len &lt; min1) &#123; min1 = zu[i].len; &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; min1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="day11-3"><a href="#day11-3" class="headerlink" title="day11-3"></a>day11-3</h1><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="type">int</span> n, m, arr[<span class="number">10005</span>] = &#123; <span class="number">0</span> &#125;, chaxun = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">erfen</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> l = <span class="number">1</span>, r = n,mid=l+(r-l)/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">		mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (arr[mid] &gt;= k) &#123; r = mid; &#125;</span><br><span class="line">		<span class="keyword">else</span> &#123; l = mid + <span class="number">1</span>; &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (arr[l] == k) &#123; <span class="keyword">return</span> l; &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">	&#123;	cin &gt;&gt; arr[i];&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; chaxun;</span><br><span class="line">		chaxun=<span class="built_in">erfen</span>(chaxun);</span><br><span class="line">		cout &lt;&lt; chaxun&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="lower-bound和upper-bound的妙用"><a href="#lower-bound和upper-bound的妙用" class="headerlink" title="lower_bound和upper_bound的妙用"></a>lower_bound和upper_bound的妙用</h2><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1102">P1102 A-B 数对 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<h3 id="原写法（映射）"><a href="#原写法（映射）" class="headerlink" title="原写法（映射）"></a>原写法（映射）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="type">int</span> n=<span class="number">0</span>, m=<span class="number">0</span>, arr[<span class="number">2000005</span>], len = <span class="number">0</span>,temp=<span class="number">0</span>,b[<span class="number">3000005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;arr[i];</span><br><span class="line">		b[arr[i]]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i]&lt;m)&#123;<span class="keyword">continue</span>;&#125;</span><br><span class="line">		len += b[arr[i] - m];</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; len;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>用c++ stl库函数lower_bound和upper_bound的写法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span><span class="comment">//万能头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;/命名空间</span><br><span class="line"><span class="type">int</span> n,c,a[<span class="number">200005</span>];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> main（）&#123;</span><br><span class="line">cin &gt;&gt;n&gt;&gt;c;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)cin &gt;&gt;a[i];</span><br><span class="line"><span class="built_in">sort</span>(a,a+n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">ans +=<span class="built_in">upper_bound</span>(a,a+n,a[i]+c)-<span class="built_in">lower_bound</span>(a,a+n,a[i]+c);&#125;<span class="comment">//用找到第一个大于的数的下标和减去第一个找到的大于等于的数的下标，即为该数在数组中的个数，若没有二者都指向为迭代器，结果为0；</span></span><br><span class="line">cout &lt;&lt;ans;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="砍树，求长度最小值中的二分"><a href="#砍树，求长度最小值中的二分" class="headerlink" title="砍树，求长度最小值中的二分"></a>砍树，求长度最小值中的二分</h2><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1873">P1873 [COCI2011-2012#5] EKO / 砍树 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<p>把所有可能出现的长度都试一遍，如果满足结果就输出，如果在一个范围里（或者说不是整数）就用二分求出最</p>
<p>符合的题解</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="type">int</span> n = <span class="number">0</span>, m = <span class="number">0</span>, arr[<span class="number">1000005</span>], len = <span class="number">0</span>, temp = <span class="number">0</span>, b[<span class="number">3000005</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; arr[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(arr, arr + n, cmp);</span><br><span class="line">	<span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">100000000</span>; <span class="comment">//树最高是100000000米，所以右边界要取到100000000，从0到10000000遍历</span></span><br><span class="line">	<span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">		<span class="type">long</span> <span class="type">long</span> total = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[i] &gt; mid) &#123;</span><br><span class="line">				total += arr[i] - mid;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123; <span class="keyword">break</span>; &#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (total &gt; m) &#123; l = mid + <span class="number">1</span>; &#125;</span><br><span class="line">		<span class="keyword">if</span> (total &lt; m) &#123; r = mid - <span class="number">1</span>; &#125;<span class="comment">//刚开始右边界是100000000，每次减1，mid每次也除于2</span></span><br><span class="line">		<span class="keyword">if</span> (total == m) &#123; cout &lt;&lt; mid;<span class="keyword">return</span> <span class="number">0</span>; &#125;<span class="comment">//正好求出结果时，直接打印</span></span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; r;<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//若未完美求出结果，则打印最接近结果的的数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="用二分法求方程组为0的解"><a href="#用二分法求方程组为0的解" class="headerlink" title="用二分法求方程组为0的解"></a>用二分法求方程组为0的解</h2><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1024">P1024 [NOIP2001 提高组] 一元三次方程求解 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<p>方程f<em>(</em>x)=0，若存在 2 个数 x1 和 <em>x</em>2，且 x<em>1&lt;</em>x<em>2，f</em>(<em>x</em>1)×<em>f</em>(<em>x</em>2)&lt;0，则在 (<em>x</em>1,x2) 之间一定有一个根，此时我们就可以把区间定在一个数和这个数加1之内，用二分法求解</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="type">double</span> a, b, c, d;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">fc</span><span class="params">(<span class="type">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * x * x * x + b * x * x + c * x + d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> l, r, m, x1, x2;</span><br><span class="line">    <span class="type">int</span> s = <span class="number">0</span>, i;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf%lf%lf&quot;</span>, &amp;a, &amp;b, &amp;c, &amp;d);  <span class="comment">//输入</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">-100</span>;i &lt; <span class="number">100</span>;i++)<span class="comment">//从题中所给的范围进行遍历</span></span><br><span class="line">    &#123;</span><br><span class="line">        l = i;</span><br><span class="line">        r = i + <span class="number">1</span>;</span><br><span class="line">        x1 = <span class="built_in">fc</span>(l);</span><br><span class="line">        x2 = <span class="built_in">fc</span>(r);</span><br><span class="line">        <span class="keyword">if</span> (!x1)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%.2lf &quot;</span>, l);</span><br><span class="line">            s++;</span><br><span class="line">        &#125;      <span class="comment">//判断左端点，是零点直接输出。</span></span><br><span class="line"></span><br><span class="line">                        <span class="comment">//不能判断右端点，会重复。</span></span><br><span class="line">        <span class="keyword">if</span> (x1 * x2 &lt; <span class="number">0</span>)                             <span class="comment">//区间内有根。</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (r - l &gt;= <span class="number">0.001</span>)                     <span class="comment">//二分控制精度。</span></span><br><span class="line">            &#123;</span><br><span class="line">                m = (l + r) / <span class="number">2</span>;  <span class="comment">//middle</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">fc</span>(m) * <span class="built_in">fc</span>(r) &lt;= <span class="number">0</span>)</span><br><span class="line">                    l = m;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    r = m;   <span class="comment">//计算中点处函数值缩小区间。</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%.2lf &quot;</span>, r);</span><br><span class="line">            <span class="comment">//输出右端点。</span></span><br><span class="line">            s++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//找到三个就退出大概会省一点时间</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="lower-bound-返回第一个大于等于的值的下标）用法巩固，注意全部大于和全部小于的情况"><a href="#lower-bound-返回第一个大于等于的值的下标）用法巩固，注意全部大于和全部小于的情况" class="headerlink" title="lower_bound(返回第一个大于等于的值的下标）用法巩固，注意全部大于和全部小于的情况"></a>lower_bound(返回第一个大于等于的值的下标）用法巩固，注意全部大于和全部小于的情况</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a,b,c[<span class="number">100002</span>],d,e,f,g,h,i,j,k,l;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=a;i++)</span><br><span class="line">        cin&gt;&gt;c[i];</span><br><span class="line">    <span class="built_in">sort</span>(c+<span class="number">1</span>,c+a+<span class="number">1</span>);<span class="comment">//先排序一下</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=b;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;d;</span><br><span class="line">        e=<span class="built_in">lower_bound</span>(c+<span class="number">1</span>,c+a+<span class="number">1</span>,d)-c;<span class="comment">//返回查询到的位置</span></span><br><span class="line">        <span class="keyword">if</span>(e==a+<span class="number">1</span>)</span><br><span class="line">        ans+=d-c[a];<span class="comment">//特判比所有数都大的情况</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">if</span>(e==<span class="number">1</span>)<span class="comment">//特判比所有数都小的情况</span></span><br><span class="line">                ans+=c[<span class="number">1</span>]-d;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ans+=<span class="built_in">min</span>(<span class="built_in">abs</span>(c[e]-d),<span class="built_in">abs</span>(d-c[e<span class="number">-1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="day11-8"><a href="#day11-8" class="headerlink" title="day11-8"></a>day11-8</h1><h2 id="二分法，尝试可能的所有结果"><a href="#二分法，尝试可能的所有结果" class="headerlink" title="二分法，尝试可能的所有结果"></a>二分法，尝试可能的所有结果</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="type">int</span> m, n, a[<span class="number">100005</span>], b[<span class="number">100005</span>], result = <span class="number">0</span>, l = <span class="number">0</span>, r = <span class="number">100000000</span>, mid = l + (r - l) / <span class="number">2</span>, mark = <span class="number">0</span>,max1=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m, n, k;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">    &#123; cin &gt;&gt; a[i];&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        b[i] = a[i + <span class="number">1</span>] - a[i];</span><br><span class="line">        max1 = <span class="built_in">max</span>(max1, b[i]);<span class="comment">//取间隔最大值，结果不可能比这个大，所以让右边界与其相等即可</span></span><br><span class="line">    &#125;</span><br><span class="line">    r = max1;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        mark = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt; n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            max1 = b[i];</span><br><span class="line">            <span class="keyword">while</span> (max1 &gt; mid)</span><br><span class="line">            &#123;</span><br><span class="line">                mark++;</span><br><span class="line">                max1 -= mid;<span class="comment">//每一种间隔都对应一种结果加和</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mark &lt;= k) &#123; r = mid - <span class="number">1</span>; &#125;<span class="comment">//看看在当前间隔时结果是大了还是小了</span></span><br><span class="line">        <span class="keyword">else</span>&#123; l = mid + <span class="number">1</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="第二道类似的题"><a href="#第二道类似的题" class="headerlink" title="第二道类似的题"></a>第二道类似的题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"> <span class="type">int</span> m, n, a[<span class="number">100005</span>] , l = <span class="number">0</span>, r = <span class="number">12</span>, mid = l + (r - l) / <span class="number">2</span>, mark = <span class="number">1</span>,temp=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i++) &#123; cin &gt;&gt; a[i];l = <span class="built_in">max</span>(l, a[i]); &#125;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        temp = <span class="number">0</span>;mark = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i++)</span><br><span class="line">        &#123;        </span><br><span class="line">            <span class="keyword">if</span> (a[i] + temp &lt;= mid) &#123; temp += a[i];<span class="keyword">continue</span>; &#125;</span><br><span class="line">            <span class="keyword">if</span> (a[i] + temp &gt; mid) &#123; temp = a[i];mark++;<span class="keyword">continue</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mark &lt;= n) &#123; r = mid - <span class="number">1</span>; &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; l = mid + <span class="number">1</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="银行贷款利息问题"><a href="#银行贷款利息问题" class="headerlink" title="银行贷款利息问题"></a>银行贷款利息问题</h2><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1163">P1163 银行贷款 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">a=(...（m*(<span class="number">1</span>+x)-y)(<span class="number">1</span>+x)-y)...)（共t次乘法）（秦九韶算法）（m表示贷款的原值、y表示每月支付的分期付款金额、t表示分期付款还清贷款所需的总月数，a表示在t个月后按二分得到的利率还剩下多少钱没有还）。如果a是正数说明利率过大，则从左侧继续二分查找；如果a是负数说明利率过大，则从右侧继续二分查找；如果a等于零则输出结束程序。二分查找结束的另一个条件是精度小于<span class="number">0.0001</span>。</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">double</span> m,y,s;</span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">out</span><span class="params">(<span class="type">double</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.1f&quot;</span>,k*<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">double</span> l,<span class="type">double</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> k=(l+r)/<span class="number">2</span>,u=r-l;</span><br><span class="line">    <span class="type">double</span> a=m;</span><br><span class="line">    <span class="keyword">if</span>(u&lt;<span class="number">0.0001</span>) <span class="built_in">out</span>(k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=t;i++)</span><br><span class="line">          a=a*(<span class="number">1</span>+k)-y;</span><br><span class="line">    <span class="keyword">if</span>(a&gt;<span class="number">0</span>) <span class="built_in">solve</span>(l,k);</span><br><span class="line">    <span class="keyword">if</span>(a&lt;<span class="number">0</span>) <span class="built_in">solve</span>(k,r);</span><br><span class="line">    <span class="keyword">if</span>(a==<span class="number">0</span>) <span class="built_in">out</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;m&gt;&gt;y&gt;&gt;t;</span><br><span class="line">    <span class="built_in">solve</span>(<span class="number">0</span>,<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="day11-9"><a href="#day11-9" class="headerlink" title="day11-9"></a>day11-9</h1><h2 id="递归加搜索"><a href="#递归加搜索" class="headerlink" title="递归加搜索"></a>递归加搜索</h2><h3 id="搜索的写法一般都是有好几个数组，每个数组对应一种情况，然后通常会与递归相结合起来"><a href="#搜索的写法一般都是有好几个数组，每个数组对应一种情况，然后通常会与递归相结合起来" class="headerlink" title="搜索的写法一般都是有好几个数组，每个数组对应一种情况，然后通常会与递归相结合起来"></a>搜索的写法一般都是有好几个数组，每个数组对应一种情况，然后通常会与递归相结合起来</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span><span class="comment">//个人不建议采用头文件，可能和定义的变量或名字起冲突，从而引起编译错误；</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">100</span>],b[<span class="number">100</span>],c[<span class="number">100</span>],d[<span class="number">100</span>];</span><br><span class="line"><span class="comment">//a数组表示的是行；</span></span><br><span class="line"><span class="comment">//b数组表示的是列；</span></span><br><span class="line"><span class="comment">//c表示的是左下到右上的对角线；</span></span><br><span class="line"><span class="comment">//d表示的是左上到右下的对角线；</span></span><br><span class="line"><span class="type">int</span> total;<span class="comment">//总数:记录解的总数</span></span><br><span class="line"><span class="type">int</span> n;<span class="comment">//输入的数，即N*N的格子，全局变量，搜索中要用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(total&lt;=<span class="number">2</span>)<span class="comment">//保证只输出前三个解，如果解超出三个就不再输出，但后面的total还需要继续叠加</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">        cout&lt;&lt;a[k]&lt;&lt;<span class="string">&quot; &quot;</span>;<span class="comment">//for语句输出</span></span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    total++;<span class="comment">//total既是总数，也是前三个排列的判断</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">queen</span><span class="params">(<span class="type">int</span> i)</span><span class="comment">//搜索与回溯主体</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">print</span>();<span class="comment">//输出函数，自己写的</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)<span class="comment">//尝试可能的位置</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((!b[j])&amp;&amp;(!c[i+j])&amp;&amp;(!d[i-j+n]))<span class="comment">//如果没有皇后占领，执行以下程序，这里的d数组加n是考虑到可能会相减成负数的情况，所以加上n的偏移量</span></span><br><span class="line">            &#123;</span><br><span class="line">                a[i]=j;<span class="comment">//标记i排是第j个</span></span><br><span class="line">                b[j]=<span class="number">1</span>;<span class="comment">//宣布占领纵列</span></span><br><span class="line">                c[i+j]=<span class="number">1</span>;左边上下对角线，每行的i+j都相等,相减为定值</span><br><span class="line">                d[i-j+n]=<span class="number">1</span>;右边上下正对角线，每行的i-j都相等</span><br><span class="line">                <span class="comment">//宣布占领两条对角线</span></span><br><span class="line">                <span class="built_in">queen</span>(i+<span class="number">1</span>);<span class="comment">//进一步搜索，下一个皇后</span></span><br><span class="line">                b[j]=<span class="number">0</span>;</span><br><span class="line">                c[i+j]=<span class="number">0</span>;</span><br><span class="line">                d[i-j+n]=<span class="number">0</span>;</span><br><span class="line">                <span class="comment">//（回到上一步）清除标记</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    cin&gt;&gt;n;<span class="comment">//输入N*N网格，n已在全局中定义</span></span><br><span class="line">    <span class="built_in">queen</span>(<span class="number">1</span>);<span class="comment">//第一个皇后</span></span><br><span class="line">    cout&lt;&lt;total;<span class="comment">//输出可能的总数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="当有两个组别求最大值时，可以先求一组的最大值，然后让他慢慢减，每减一次求一下当前的结果，如果大了就更新、最后直接输出最大值即可"><a href="#当有两个组别求最大值时，可以先求一组的最大值，然后让他慢慢减，每减一次求一下当前的结果，如果大了就更新、最后直接输出最大值即可" class="headerlink" title="当有两个组别求最大值时，可以先求一组的最大值，然后让他慢慢减，每减一次求一下当前的结果，如果大了就更新、最后直接输出最大值即可"></a>当有两个组别求最大值时，可以先求一组的最大值，然后让他慢慢减，每减一次求一下当前的结果，如果大了就更新、最后直接输出最大值即可</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/godwad/tianxuan4/main/tianxuan/image-20231109231424158.png" alt="image-20231109231424158"></p>
<figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#include&lt;<span class="string">stdio.h</span>&gt;</span></span><br><span class="line"><span class="meta">#include&lt;<span class="string">math.h</span>&gt;</span></span><br><span class="line"><span class="type">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n,m,a,b;</span><br><span class="line">   long long <span class="built_in">sum</span>,sum1,sum2,t;</span><br><span class="line">   scanf(<span class="string">&quot;%d %d %d %d&quot;</span>,&amp;n,&amp;m,&amp;a,&amp;b);</span><br><span class="line">   sum1=<span class="built_in">fmin</span>(n/<span class="number">2</span>,m);<span class="comment">//a礼包的最大数量 </span></span><br><span class="line">   sum2=<span class="built_in">fmin</span>(n-sum1*<span class="number">2</span>,(m-sum1)/<span class="number">2</span>);<span class="comment">//a最大时，b的数量 </span></span><br><span class="line">   <span class="built_in">sum</span>=sum1*a+sum2*b;</span><br><span class="line">   <span class="keyword">while</span>(sum1)&#123;</span><br><span class="line">   	sum1--;<span class="comment">//a礼包数目逐渐减少 </span></span><br><span class="line">   	sum2=<span class="built_in">fmin</span>(n-sum1*<span class="number">2</span>,(m-sum1)/<span class="number">2</span>);</span><br><span class="line">   	t=sum1*a+sum2*b;</span><br><span class="line">   	<span class="keyword">if</span>(t&gt;<span class="built_in">sum</span>)</span><br><span class="line">   	&#123;</span><br><span class="line">   		<span class="built_in">sum</span>=t;</span><br><span class="line">	   &#125;</span><br><span class="line">   	</span><br><span class="line">   &#125;</span><br><span class="line">   printf(<span class="string">&quot;%lld&quot;</span>,<span class="built_in">sum</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="day11-10"><a href="#day11-10" class="headerlink" title="day11-10"></a>day11-10</h1><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/the_ZED/article/details/105126583?ops_request_misc=%7B%22request%5Fid%22%3A%22169962882516800188563576%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=169962882516800188563576&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-105126583-null-null.142^v96^pc_search_result_base8&amp;utm_term=并查集&amp;spm=1018.2226.3001.4187">【算法与数据结构】—— 并查集-CSDN博客</a></p>
</article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>算法合集</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://godwad.github.io/posts/54150.html">https://godwad.github.io/posts/54150.html</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>小s今天吃什么</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2023-03-23</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2023-11-11</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/"><div class="tags-punctuation"><svg class="faa-tada icon" style="height:1.1em;width:1.1em;fill:currentColor;position:relative;top:2px;margin-right:3px" aria-hidden="true"><use xlink:href="#icon-sekuaibiaoqian"></use></svg></div>算法</a></div></div><link rel="stylesheet" href="/css/coin.css" media="defer" onload="this.media='all'"/><div class="post-reward"><button class="tip-button reward-button"><span class="tip-button__text">投喂作者</span><div class="coin-wrapper"><div class="coin"><div class="coin__middle"></div><div class="coin__back"></div><div class="coin__front"></div></div></div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://tuchuang.voooe.cn/images/2023/01/04/2.webp" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://tuchuang.voooe.cn/images/2023/01/04/2.webp" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://tuchuang.voooe.cn/images/2023/01/04/20f8e49805975b8f8.webp" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://tuchuang.voooe.cn/images/2023/01/04/20f8e49805975b8f8.webp" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></button></div><audio id="coinAudio" src="https://npm.elemecdn.com/akilar-candyassets@1.0.36/audio/aowu.m4a"></audio><script defer="defer" src="/js/coin.js"></script><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/54497.html"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cache.4ce.cn/star3/origin/43abab99fbcf544680bb607fc6d3b23d.jpg?rw=5120&amp;rh=3200&amp;_fileSize=566&amp;_orientation=1" onerror="onerror=null;src='/assets/r2.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">c++读取写入数据</div></div></a></div><div class="next-post pull-right"><a href="/posts/11750.html"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.horosama.com/api/image_all/anime/1080p/pc/54C84A3303Bd3372a6C1f2d6a160712E.jpg" onerror="onerror=null;src='/assets/r2.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">从零开始的力扣刷题</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><svg class="meta_icon" style="width:22px;height:22px;position:relative;top:5px"><use xlink:href="#icon-mulu1"></use></svg><span style="font-weight:bold">目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text"> </span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#longlongint%E7%9A%84%E8%8C%83%E5%9B%B4-9223372036854775808%EF%BD%9E9223372036854775807%E3%80%8219%E4%BD%8D%E6%95%B0%EF%BC%8C%E5%B0%8F%E4%BA%8E10%E7%9A%8419%E6%AC%A1%E6%96%B9-%EF%BC%88%E7%94%A8-lld%E8%BE%93%E5%87%BA%EF%BC%89"><span class="toc-text">longlongint的范围-9223372036854775808～9223372036854775807。19位数，小于10的19次方 （用%lld输出）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#int%E8%8C%83%E5%9B%B4%E6%98%AF-2147483648%EF%BD%9E2147483647%EF%BC%882%E7%9A%8431%E6%AC%A1%E6%96%B9%EF%BC%89-%E5%B0%8F%E4%BA%8E10%E7%9A%8410%E6%AC%A1%E6%96%B9-10%E4%BD%8D%E6%95%B0"><span class="toc-text">int范围是-2147483648～2147483647（2的31次方） 小于10的10次方 10位数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-text">链表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">结构体</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A3%E5%BA%8F%E6%8F%92%E5%85%A5"><span class="toc-text">正序插入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%80%92%E5%BA%8F%E6%8F%92%E5%85%A5"><span class="toc-text">倒序插入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%81%8D%E5%8E%86"><span class="toc-text">遍历</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%91"><span class="toc-text">树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-DFS%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95"><span class="toc-text">1.DFS深度优先算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-BFS%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95"><span class="toc-text">2.BFS广度优先算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%BF%E6%90%9C%E6%A8%A1%E6%9D%BF"><span class="toc-text">广搜模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98"><span class="toc-text">例题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#P1443-%E9%A9%AC%E7%9A%84%E9%81%8D%E5%8E%86-%E6%B4%9B%E8%B0%B7-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E6%95%99%E8%82%B2%E6%96%B0%E7%94%9F%E6%80%81-luogu-com-cn"><span class="toc-text">P1443 马的遍历 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%9C%80%E7%9F%AD%E8%B7%AF%E4%B9%8Bdijkstra"><span class="toc-text">3.最短路之dijkstra</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%9C%80%E7%9F%AD%E8%B7%AF%E4%B9%8BSPFA"><span class="toc-text">4.最短路之SPFA</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%9C%80%E7%9F%AD%E8%B7%AF%E4%B9%8BFloyd"><span class="toc-text">5.最短路之Floyd</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E9%AB%98%E7%B2%BE%E5%BA%A6"><span class="toc-text">6.高精度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E5%AE%9A%E8%A6%81%E8%80%83%E8%99%91%E8%BF%9B%E4%BD%8D%EF%BC%81%EF%BC%81"><span class="toc-text">一定要考虑进位！！</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%8A%A0%E6%B3%95"><span class="toc-text">高精度加法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E7%B2%BE%E5%BA%A6%E4%B9%98%E6%B3%95"><span class="toc-text">高精度乘法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E9%AB%98%E7%B2%BE%E5%BA%A6%E7%AE%97%E6%B3%95%E7%AE%97%E4%B8%80%E4%B8%AA%E6%95%B0%E7%9A%84%E9%98%B6%E4%B9%98-%E5%B9%B6%E7%9B%B8%E5%8A%A0-%E2%80%94-%E6%B4%9B%E8%B0%B71009"><span class="toc-text">用高精度算法算一个数的阶乘(并相加) —-洛谷1009</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E4%B9%8Bkruskal"><span class="toc-text">7.最小生成树之kruskal</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E4%B9%8Bprim"><span class="toc-text">8.最小生成树之prim</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%EF%BC%8C%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%8F%AF%E8%83%BD%E6%9C%89%E5%BE%88%E5%A4%9A%E7%A7%8D%EF%BC%8C%E4%BD%86%E6%9C%80%E5%90%8E%E7%9A%84%E6%9D%83%E5%80%BC%E9%83%BD%E6%98%AF%E7%9B%B8%E5%90%8C%E7%9A%84%EF%BC%8C%E6%89%80%E4%BB%A5%E9%81%87%E8%A7%81%E4%B8%A4%E4%B8%AA%E6%9C%80%E5%B0%8F%E5%80%BC%E7%9B%B8%E5%90%8C%E7%9A%84%E8%BE%B9%E5%8F%96%E5%93%AA%E4%B8%80%E6%9D%A1%E9%83%BD%E5%8F%AF%E4%BB%A5%EF%BC%81"><span class="toc-text">注意，最小生成树可能有很多种，但最后的权值都是相同的，所以遇见两个最小值相同的边取哪一条都可以！</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84%E2%80%94%E2%80%94BFS"><span class="toc-text">9.树的直径——BFS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84%E2%80%94%E2%80%94DFS"><span class="toc-text">10.树的直径——DFS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84%E2%80%94%E2%80%94%E6%A0%91%E5%BD%A2DP"><span class="toc-text">11.树的直径——树形DP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84"><span class="toc-text">12.树状数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-%E5%AD%97%E5%85%B8%E6%A0%91"><span class="toc-text">13.字典树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="toc-text">14.线段树</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%88%86"><span class="toc-text">二分</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9A%B4%E5%8A%9B%E6%9E%9A%E4%B8%BE%EF%BC%88%E9%80%82%E5%90%88%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4%E5%B0%8F%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E6%AF%94%E5%A6%82100%E4%BB%A5%E5%86%85%EF%BC%8C%E5%B8%B8%E8%A7%81for%E5%BE%AA%E7%8E%AF%EF%BC%89"><span class="toc-text">暴力枚举（适合数据范围小的时候，比如100以内，常见for循环）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E5%92%8C"><span class="toc-text">前缀和</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%90%8E%E7%BC%80%E5%92%8C"><span class="toc-text">后缀和</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-text">位运算</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%B5%81"><span class="toc-text">网络流</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E5%9D%97"><span class="toc-text">分块</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#LCT"><span class="toc-text">LCT</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Splay"><span class="toc-text">Splay</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#LCA"><span class="toc-text">LCA</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Bellman-Ford"><span class="toc-text">Bellman-Ford</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%AF%E8%80%BB%E7%9A%84%E6%89%93%E8%A1%A8"><span class="toc-text">可耻的打表</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SPFA%E7%AE%97%E6%B3%95"><span class="toc-text">SPFA算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#SPFA%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF%E4%B9%8BSLF%E4%BC%98%E5%8C%96"><span class="toc-text">SPFA求最短路之SLF优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SPFA%E4%B9%8BLLL%E4%BC%98%E5%8C%96"><span class="toc-text">SPFA之LLL优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SPFA%E4%B9%8BSLF-LLL%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95"><span class="toc-text">SPFA之SLF+LLL优化算法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%AA%E7%94%A8%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F"><span class="toc-text">只用一个变量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95"><span class="toc-text">矩阵乘法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#STL-dijkstra"><span class="toc-text">STL+dijkstra</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E5%AD%A6%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">数学表达式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8E%8B%E4%BD%8D%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%8A%A0%E6%B3%95"><span class="toc-text">压位高精度加法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5DP"><span class="toc-text">矩阵DP</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-text">十大经典排序算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#0%E3%80%81%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0"><span class="toc-text">0、算法概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#0-1-%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB"><span class="toc-text">0.1 算法分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0-2-%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-text">0.2 算法复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0-3-%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-text">0.3 相关概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%EF%BC%88Bubble-Sort%EF%BC%89"><span class="toc-text">1、冒泡排序（Bubble Sort）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0"><span class="toc-text">1.1 算法描述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-%E5%8A%A8%E5%9B%BE%E6%BC%94%E7%A4%BA"><span class="toc-text">1.2 动图演示</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-3-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">1.3 代码实现</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%EF%BC%88Selection-Sort%EF%BC%89"><span class="toc-text">2、选择排序（Selection Sort）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0"><span class="toc-text">2.1 算法描述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-%E5%8A%A8%E5%9B%BE%E6%BC%94%E7%A4%BA"><span class="toc-text">2.2 动图演示</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">2.3 代码实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-text">2.4 算法分析</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%EF%BC%88Insertion-Sort%EF%BC%89"><span class="toc-text">3、插入排序（Insertion Sort）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0"><span class="toc-text">3.1 算法描述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-%E5%8A%A8%E5%9B%BE%E6%BC%94%E7%A4%BA"><span class="toc-text">3.2 动图演示</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">3.2 代码实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-text">3.4 算法分析</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%EF%BC%88Shell-Sort%EF%BC%89"><span class="toc-text">4、希尔排序（Shell Sort）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1-%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0"><span class="toc-text">4.1 算法描述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-%E5%8A%A8%E5%9B%BE%E6%BC%94%E7%A4%BA"><span class="toc-text">4.2 动图演示</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">4.3 代码实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-4-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-text">4.4 算法分析</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%EF%BC%88Merge-Sort%EF%BC%89"><span class="toc-text">5、归并排序（Merge Sort）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-1-%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0"><span class="toc-text">5.1 算法描述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-2-%E5%8A%A8%E5%9B%BE%E6%BC%94%E7%A4%BA"><span class="toc-text">5.2 动图演示</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-3-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">5.3 代码实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-4-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-text">5.4 算法分析</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%EF%BC%88Quick-Sort%EF%BC%89"><span class="toc-text">6、快速排序（Quick Sort）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#6-1-%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0"><span class="toc-text">6.1 算法描述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-2-%E5%8A%A8%E5%9B%BE%E6%BC%94%E7%A4%BA"><span class="toc-text">6.2 动图演示</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-3-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">6.3 代码实现</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7%E3%80%81%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%88Heap-Sort%EF%BC%89"><span class="toc-text">7、堆排序（Heap Sort）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#7-1-%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0"><span class="toc-text">7.1 算法描述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-2-%E5%8A%A8%E5%9B%BE%E6%BC%94%E7%A4%BA"><span class="toc-text">7.2 动图演示</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-3-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">7.3 代码实现</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8%E3%80%81%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%EF%BC%88Counting-Sort%EF%BC%89"><span class="toc-text">8、计数排序（Counting Sort）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#8-1-%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0"><span class="toc-text">8.1 算法描述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-2-%E5%8A%A8%E5%9B%BE%E6%BC%94%E7%A4%BA"><span class="toc-text">8.2 动图演示</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-3-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">8.3 代码实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-4-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-text">8.4 算法分析</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9%E3%80%81%E6%A1%B6%E6%8E%92%E5%BA%8F%EF%BC%88Bucket-Sort%EF%BC%89"><span class="toc-text">9、桶排序（Bucket Sort）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#9-1-%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0"><span class="toc-text">9.1 算法描述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-3-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">9.3 代码实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-4-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-text">9.4 算法分析</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10%E3%80%81%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%EF%BC%88Radix-Sort%EF%BC%89"><span class="toc-text">10、基数排序（Radix Sort）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#10-1-%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0"><span class="toc-text">10.1 算法描述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10-2-%E5%8A%A8%E5%9B%BE%E6%BC%94%E7%A4%BA"><span class="toc-text">10.2 动图演示</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10-3-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">10.3 代码实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10-4-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-text">10.4 算法分析</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%B9%82"><span class="toc-text">快速幂</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B7%AE%E5%88%86"><span class="toc-text">差分</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6"><span class="toc-text">二进制</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%83%8C%E5%8C%85"><span class="toc-text">背包</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-01%E8%83%8C%E5%8C%85"><span class="toc-text">1.01背包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85"><span class="toc-text">2.完全背包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%E4%B9%8B%E6%9A%B4%E5%8A%9B%E6%8B%86%E5%88%86%E6%B3%95"><span class="toc-text">3.多重背包之暴力拆分法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%E4%B9%8B%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%8B%86%E5%88%86"><span class="toc-text">4.多重背包之二进制拆分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E4%BA%8C%E7%BB%B4%E8%B4%B9%E7%94%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-text">5.二维费用背包问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-text">6.分组背包问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%9C%89%E4%BE%9D%E8%B5%96%E7%9A%84%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-text">7.有依赖的背包问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96"><span class="toc-text">8.多重背包队列优化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#istream-iterator"><span class="toc-text">istream_iterator</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="toc-text">进制转换</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95"><span class="toc-text">指针算法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#c-%E8%87%AA%E5%B8%A6%E7%AE%97%E6%B3%95"><span class="toc-text">c++自带算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%89%8D%E8%A8%80"><span class="toc-text">1 前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8"><span class="toc-text">2 常用容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E5%86%85%E5%AE%B9%E6%80%BB%E8%A7%88"><span class="toc-text">2.1 内容总览</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E5%90%91%E9%87%8F-vector"><span class="toc-text">2.2 向量 vector</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">2.2.1 常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0"><span class="toc-text">构造</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%BE%E6%8E%A5-amp-%E5%B0%BE%E5%88%A0"><span class="toc-text">尾接 &amp; 尾删</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%8B%AC%E5%8F%B7%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">中括号运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E9%95%BF%E5%BA%A6"><span class="toc-text">获取长度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B8%85%E7%A9%BA"><span class="toc-text">清空</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A4%E7%A9%BA"><span class="toc-text">判空</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B9%E5%8F%98%E9%95%BF%E5%BA%A6"><span class="toc-text">改变长度</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-%E9%80%82%E7%94%A8%E6%83%85%E5%BD%A2"><span class="toc-text">2.2.2 适用情形</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-3-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">2.2.3 注意事项</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%90%E5%89%8D%E6%8C%87%E5%AE%9A%E9%95%BF%E5%BA%A6"><span class="toc-text">提前指定长度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%93%E5%BF%83-size-t-%E6%BA%A2%E5%87%BA"><span class="toc-text">当心 size_t 溢出</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E6%A0%88-stack"><span class="toc-text">2.3 栈 stack</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">2.3.1 常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2-%E9%80%82%E7%94%A8%E6%83%85%E5%BD%A2"><span class="toc-text">2.3.2 适用情形</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-3-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">2.3.3 注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E9%98%9F%E5%88%97-queue"><span class="toc-text">2.4 队列 queue</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-1-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">2.4.1 常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-2-%E9%80%82%E7%94%A8%E6%83%85%E5%BD%A2"><span class="toc-text">2.4.2 适用情形</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-3-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">2.4.3 注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97-priority-queue"><span class="toc-text">2.5 优先队列 priority_queue</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-1-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">2.5.1 常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0-1"><span class="toc-text">构造</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-text">其他</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-2-%E9%80%82%E7%94%A8%E6%83%85%E5%BD%A2"><span class="toc-text">2.5.2 适用情形</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-3-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">2.5.3 注意事项</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%85%E5%A0%86%E9%A1%B6%E5%8F%AF%E8%AF%BB"><span class="toc-text">仅堆顶可读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%80%E6%9C%89%E5%85%83%E7%B4%A0%E4%B8%8D%E5%8F%AF%E5%86%99"><span class="toc-text">所有元素不可写</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-%E9%9B%86%E5%90%88-set"><span class="toc-text">2.6 集合 set</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-1-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">2.6.1 常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0-2"><span class="toc-text">构造</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%8D%E5%8E%86-1"><span class="toc-text">遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96-1"><span class="toc-text">其他</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#begin-%E8%BF%94%E5%9B%9Eset%E5%AE%B9%E5%99%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E7%9A%84-%E5%9C%B0%E5%9D%80"><span class="toc-text">begin() 　　 返回set容器的第一个元素的 地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#end-%E8%BF%94%E5%9B%9Eset%E5%AE%B9%E5%99%A8%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0-%E5%9C%B0%E5%9D%80"><span class="toc-text">end() 　　　　 返回set容器的最后一个元素 地址 </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#clear-%E5%88%A0%E9%99%A4set%E5%AE%B9%E5%99%A8%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-text">clear() 　　 删除set容器中的所有的元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#empty-%E5%88%A4%E6%96%ADset%E5%AE%B9%E5%99%A8%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA"><span class="toc-text">empty() 　　　 判断set容器是否为空</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#max-size-%E8%BF%94%E5%9B%9Eset%E5%AE%B9%E5%99%A8%E5%8F%AF%E8%83%BD%E5%8C%85%E5%90%AB%E7%9A%84%E5%85%83%E7%B4%A0%E6%9C%80%E5%A4%A7%E4%B8%AA%E6%95%B0"><span class="toc-text">max_size() 　 返回set容器可能包含的元素最大个数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#size-%E8%BF%94%E5%9B%9E%E5%BD%93%E5%89%8Dset%E5%AE%B9%E5%99%A8%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0%E4%B8%AA%E6%95%B0"><span class="toc-text">size() 　　　　 返回当前set容器中的元素个数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#erase-it-%E5%88%A0%E9%99%A4%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%8C%87%E9%92%88it%E5%A4%84%E5%85%83%E7%B4%A0"><span class="toc-text">erase(it) 删除迭代器指针it处元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#insert-a-%E6%8F%92%E5%85%A5%E6%9F%90%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="toc-text">insert(a) 插入某个元素</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-2-%E9%80%82%E7%94%A8%E6%83%85%E5%BD%A2"><span class="toc-text">2.6.2 适用情形</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-3-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">2.6.3 注意事项</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%AD%98%E5%9C%A8%E4%B8%8B%E6%A0%87%E7%B4%A2%E5%BC%95"><span class="toc-text">不存在下标索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E5%8F%AA%E8%AF%BB"><span class="toc-text">元素只读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E7%94%A8%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%AE%A1%E7%AE%97%E4%B8%8B%E6%A0%87"><span class="toc-text">不可用迭代器计算下标</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-7-%E6%98%A0%E5%B0%84-map"><span class="toc-text">2.7 映射 map</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-1-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">2.7.1 常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0-3"><span class="toc-text">构造</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%8D%E5%8E%86-2"><span class="toc-text">遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96-2"><span class="toc-text">其他</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-2-%E9%80%82%E7%94%A8%E6%83%85%E5%BD%A2"><span class="toc-text">2.7.2 适用情形</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-3-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">2.7.3 注意事项</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%8B%AC%E5%8F%B7%E8%AE%BF%E9%97%AE%E6%97%B6%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="toc-text">中括号访问时默认值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E7%94%A8%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%AE%A1%E7%AE%97%E4%B8%8B%E6%A0%87-1"><span class="toc-text">不可用迭代器计算下标</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-8-%E5%AD%97%E7%AC%A6%E4%B8%B2-string"><span class="toc-text">2.8 字符串 string</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8-1-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">2.8.1 常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0-4"><span class="toc-text">构造</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="toc-text">输入输出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96-3"><span class="toc-text">其他</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E5%80%BC%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BA%92%E8%BD%AC%EF%BC%88C-11%EF%BC%89"><span class="toc-text">数值与字符串互转（C++11）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8-2-%E9%80%82%E7%94%A8%E6%83%85%E5%BD%A2"><span class="toc-text">2.8.2 适用情形</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8-3-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">2.8.3 注意事项</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%BE%E6%8E%A5%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%80%E5%AE%9A%E8%A6%81%E7%94%A8"><span class="toc-text">尾接字符串一定要用 +&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#substr-%E6%96%B9%E6%B3%95%E7%9A%84%E5%A5%87%E8%91%A9%E5%8F%82%E6%95%B0"><span class="toc-text">.substr() 方法的奇葩参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#find-%E6%96%B9%E6%B3%95%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-text">.find() 方法的复杂度</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#toupper%E5%A4%A7%E5%86%99"><span class="toc-text">toupper大写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B"><span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tolower%E5%B0%8F%E5%86%99"><span class="toc-text">tolower小写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-1"><span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kmp%E7%AE%97%E6%B3%95%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-text">kmp算法（重要）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-9-%E4%BA%8C%E5%85%83%E7%BB%84-pair"><span class="toc-text">2.9 二元组 pair</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-9-1-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">2.9.1 常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0-5"><span class="toc-text">构造</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC"><span class="toc-text">赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%96%E5%80%BC"><span class="toc-text">取值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A4%E5%90%8C"><span class="toc-text">判同</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-9-2-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">2.9.2 适用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-9-3-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">2.9.3 注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%AE%80%E4%BB%8B"><span class="toc-text">3 迭代器简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">3.1 迭代器是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E4%B8%BA%E4%BD%95%E9%9C%80%E8%A6%81%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%9F"><span class="toc-text">3.2 为何需要迭代器？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%94%A8%E6%B3%95"><span class="toc-text">3.3 迭代器用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="toc-text">3.4 常见问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95"><span class="toc-text">4 常用算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%86%85%E5%AE%B9%E6%80%BB%E8%A7%88"><span class="toc-text">4.1 内容总览</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-swap"><span class="toc-text">4.2 swap()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-sort"><span class="toc-text">4.3 sort()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-lower-bound-upper-bound"><span class="toc-text">4.4 lower_bound() &#x2F; upper_bound()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B0%E5%BE%97%E8%80%83%E8%99%91%E5%85%A8%E9%83%A8%E9%83%BD%E6%AF%94%E8%A6%81%E6%89%BE%E7%9A%84%E5%A4%A7%E6%88%96%E8%80%85%E5%B0%8F%E7%9A%84%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5%EF%BC%81%EF%BC%81%EF%BC%81"><span class="toc-text">记得考虑全部都比要找的大或者小的特殊情况！！！</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-reverse"><span class="toc-text">4.5 reverse()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-max-min"><span class="toc-text">4.6 max() &#x2F; min()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-unique"><span class="toc-text">4.7 unique()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-8-%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0"><span class="toc-text">4.8 数学函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-9-gcd-lcm"><span class="toc-text">4.9 gcd() &#x2F; lcm()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-10-nth-element"><span class="toc-text">4.10 nth_element</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-11-next-permutation"><span class="toc-text">4.11 next_permutation</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E3%80%81next-permutation%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-text">一、next_permutation的介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E3%80%81next-permutation%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-text">二、next_permutation的基本用法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E6%99%AE%E9%80%9A%E6%95%B0%E7%BB%84%E5%85%A8%E6%8E%92%E5%88%97"><span class="toc-text">1、普通数组全排列</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#include"><span class="toc-text">include</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#include-%E4%BD%BF%E7%94%A8-next-permutation-%E5%92%8Csort-%E9%9C%80%E8%A6%81%E5%AF%BC%E5%85%A5%E7%9A%84%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-text">include&#x2F;&#x2F;使用 next_permutation()和sort()需要导入的头文件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E7%BB%93%E6%9E%84%E4%BD%93%E5%85%A8%E6%8E%92%E5%88%97"><span class="toc-text">2、结构体全排列</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#include-1"><span class="toc-text">include</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#include-%E4%BD%BF%E7%94%A8-next-permutation-%E5%92%8Csort-%E9%9C%80%E8%A6%81%E5%AF%BC%E5%85%A5%E7%9A%84%E5%A4%B4%E6%96%87%E4%BB%B6-1"><span class="toc-text">include&#x2F;&#x2F;使用 next_permutation()和sort()需要导入的头文件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81vector"><span class="toc-text">3、vector</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#include-2"><span class="toc-text">include</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#include-%E4%BD%BF%E7%94%A8vector%E9%9C%80%E8%A6%81%E5%AF%BC%E5%85%A5%E7%9A%84%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-text">include &#x2F;&#x2F;使用vector需要导入的头文件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#include-%E4%BD%BF%E7%94%A8-next-permutation-%E5%92%8Csort-%E9%9C%80%E8%A6%81%E5%AF%BC%E5%85%A5%E7%9A%84%E5%A4%B4%E6%96%87%E4%BB%B6-2"><span class="toc-text">include&#x2F;&#x2F;使用 next_permutation()和sort()需要导入的头文件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-text">复杂度</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-text">一、时间复杂度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-text">二、空间复杂度</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%82%E6%88%96"><span class="toc-text">异或</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97%EF%BC%9A%E6%8C%89%E4%BD%8D%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">　异或运算：按位异或运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-1"><span class="toc-text">例题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E3%80%91"><span class="toc-text">【题目】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%BE%93%E5%85%A5%E3%80%91"><span class="toc-text">【输入】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%BE%93%E5%87%BA%E3%80%91"><span class="toc-text">【输出】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E7%A4%BA%E4%BE%8B%E3%80%91"><span class="toc-text">【示例】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%A4%8D%E6%9D%82%E5%BA%A6%E3%80%91"><span class="toc-text">【复杂度】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E4%BB%A3%E7%A0%81%E3%80%91"><span class="toc-text">【代码】</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E9%98%B6%EF%BC%9A%E6%95%B0%E7%BB%84%E4%B8%AD%E5%AD%98%E5%9C%A8%E4%B8%A4%E4%B8%AA%E5%87%BA%E7%8E%B0%E5%A5%87%E6%95%B0%E6%AC%A1%E7%9A%84%E6%95%B0"><span class="toc-text">进阶：数组中存在两个出现奇数次的数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%A2%98%E7%9B%AE%E3%80%91-1"><span class="toc-text">【题目】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%BE%93%E5%85%A5%E3%80%91-1"><span class="toc-text">【输入】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%BE%93%E5%87%BA%E3%80%91-1"><span class="toc-text">【输出】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E7%A4%BA%E4%BE%8B%E3%80%91-1"><span class="toc-text">【示例】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%88%86%E6%9E%90%E3%80%91"><span class="toc-text">【分析】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E4%BB%A3%E7%A0%81%E3%80%91-1"><span class="toc-text">【代码】</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#day-10-15"><span class="toc-text">day 10.15</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B1%82%E4%B8%A4%E7%82%B9%E4%B9%8B%E9%97%B4%E7%9A%84%E8%B7%9D%E7%A6%BB%EF%BC%88%E4%B8%A4%E7%82%B9%E8%B7%9D%E7%A6%BB%E5%B9%B3%E6%96%B9%E5%86%8D%E5%BC%80%E6%96%B9%EF%BC%89"><span class="toc-text">求两点之间的距离（两点距离平方再开方）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#day10-16"><span class="toc-text">day10.16</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B1%82%E7%B4%A0%E6%95%B0%E6%96%B9%E6%B3%95"><span class="toc-text">求素数方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%BC%80%E6%A0%B9"><span class="toc-text">1.开根</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%BC%80%E6%A0%B9%E4%BC%98%E5%8C%96"><span class="toc-text">2.开根优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%AC%A7%E6%8B%89%E7%AD%9B%E6%B3%95%EF%BC%88%E6%9C%80%E4%BC%98%E8%A7%A3%EF%BC%89%EF%BC%9A"><span class="toc-text">3.欧拉筛法（最优解）：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%9C%80%E5%90%8E%EF%BC%9A%E5%9F%83%E6%B0%8F%E7%AD%9B%E6%B3%95%EF%BC%88%E6%AF%94%E6%AC%A7%E6%8B%89%E7%AD%9B%E6%B3%95%E6%9B%B4%E5%AE%B9%E6%98%93%E7%90%86%E8%A7%A3%EF%BC%89"><span class="toc-text">4.最后：埃氏筛法（比欧拉筛法更容易理解）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%B2%BB-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92-%E9%80%92%E5%BD%92"><span class="toc-text">分治&#x2F;杨辉三角&#x2F;递归</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F"><span class="toc-text">输入格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F"><span class="toc-text">输出格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B%E8%BE%93%E5%85%A5"><span class="toc-text">样例输入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B%E8%BE%93%E5%87%BA"><span class="toc-text">样例输出</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#-1"><span class="toc-text"> </span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E6%B1%82%E5%92%8C"><span class="toc-text">集合求和</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-1"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-1"><span class="toc-text">输入格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-1"><span class="toc-text">输出格式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#-2"><span class="toc-text"> </span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B%E8%BE%93%E5%85%A5-1"><span class="toc-text">样例输入 #1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B%E8%BE%93%E5%87%BA-1"><span class="toc-text">样例输出 #1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E7%A4%BA"><span class="toc-text">提示</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#day-10-17"><span class="toc-text">day 10&#x2F;17</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%93%E9%9C%80%E8%A6%81%E5%BE%AA%E7%8E%AF%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E8%AF%95%E8%AF%95%E5%8A%A0%E4%B8%8A%E6%80%BB%E9%95%BF%E5%BA%A6%E4%B9%8B%E5%90%8E%E5%8F%96%E4%BD%99%E8%BF%90%E7%AE%97%EF%BC%81%EF%BC%88%E6%AF%94%E5%A6%82%E9%98%9F%E5%88%97%E7%BB%95%E5%9C%88%E7%AD%89%EF%BC%89"><span class="toc-text">当需要循环的时候，试试加上总长度之后取余运算！（比如队列绕圈等）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#day-10-18"><span class="toc-text">day 10&#x2F;18</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E7%B2%BE%E5%BA%A6"><span class="toc-text">高精度</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E5%AE%9A%E8%A6%81%E8%80%83%E8%99%91%E8%BF%9B%E4%BD%8D%EF%BC%81%EF%BC%81-1"><span class="toc-text">一定要考虑进位！！</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#day-10-21"><span class="toc-text">day 10&#x2F;21</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#day-10-22"><span class="toc-text">day 10&#x2F;22</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%9C%80%E5%90%8E%E8%A6%81%E6%B1%82%E8%BE%93%E5%87%BA%E6%97%B6%EF%BC%8C%E4%B8%8D%E4%B8%80%E5%AE%9A%E9%83%BD%E8%A6%81%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E8%BE%93%E5%87%BA%EF%BC%8C%E5%8F%AF%E4%BB%A5%E8%BE%93%E5%85%A5%E4%B8%80%E7%BB%84%E6%95%B0%E6%8D%AE%E9%A9%AC%E4%B8%8A%E8%BE%93%E5%87%BA%E5%85%B6%E5%AF%B9%E5%BA%94%E7%9A%84%E7%BB%93%E6%9E%9C%EF%BC%81%EF%BC%81"><span class="toc-text">题目最后要求输出时，不一定都要最后一块输出，可以输入一组数据马上输出其对应的结果！！!</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sort%E4%B8%8E%E5%87%BD%E6%95%B0%E7%BB%93%E5%90%88"><span class="toc-text">sort与函数结合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%89"><span class="toc-text">堆（重要！！！）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A0%86"><span class="toc-text">什么是堆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">堆的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">堆的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E9%81%8D%E5%8E%86%E3%80%82"><span class="toc-text">堆的存储与遍历。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E7%9A%84%E6%93%8D%E4%BD%9C%E3%80%82"><span class="toc-text">堆的操作。</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8B%E6%B2%89%E6%93%8D%E4%BD%9C%EF%BC%9A"><span class="toc-text">下沉操作：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8A%E6%B5%AE%E6%93%8D%E4%BD%9C%EF%BC%9A"><span class="toc-text">上浮操作：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="toc-text">插入操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%BA%E5%A0%86%E6%93%8D%E4%BD%9C"><span class="toc-text">建堆操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%A0%86%E9%A1%B6%E5%85%83%E7%B4%A0"><span class="toc-text">删除堆顶元素</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%93%E4%BB%A3%E7%A0%81%E8%83%BD%E9%80%9A%E8%BF%87%E9%83%A8%E5%88%86%E6%A1%88%E4%BE%8B%E8%80%8C%E4%B8%8D%E8%83%BD%E5%AE%8C%E5%85%A8%E9%80%9A%E8%BF%87%E6%97%B6%EF%BC%8C%E8%80%83%E8%99%91%E6%98%AF%E4%B8%8D%E6%98%AF%E7%BB%93%E6%9E%9C%E8%B6%8A%E7%95%8C%E4%BA%86%EF%BC%8C%E5%8F%AF%E4%BB%A5%E8%80%83%E8%99%91%E5%B0%86%E6%95%B0%E7%BB%84%E5%BC%80%E5%A4%A7%E4%B8%80%E7%82%B9"><span class="toc-text">当代码能通过部分案例而不能完全通过时，考虑是不是结果越界了，可以考虑将数组开大一点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%B7%E8%B7%9D%E7%A6%BB%EF%BC%88%E4%B8%A4%E7%82%B9%E4%B9%8B%E9%97%B4%E8%B7%9D%E7%A6%BB%E5%85%AC%E5%BC%8F%EF%BC%89"><span class="toc-text">欧几里德距离（两点之间距离公式）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E5%87%A0%E4%B8%AA%E6%95%B0%E5%A6%82%E4%BD%95%E8%BF%9E%E6%8E%A5%E7%BB%84%E6%88%90%E7%9A%84%E5%92%8C%E6%9C%80%E5%A4%A7%EF%BC%89"><span class="toc-text">排序算法（几个数如何连接组成的和最大）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-2"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-2"><span class="toc-text">输入格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-2"><span class="toc-text">输出格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B-1"><span class="toc-text">样例 #1</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B%E8%BE%93%E5%85%A5-1-1"><span class="toc-text">样例输入 #1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B%E8%BE%93%E5%87%BA-1-1"><span class="toc-text">样例输出 #1</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B-2"><span class="toc-text">样例 #2</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B%E8%BE%93%E5%85%A5-2"><span class="toc-text">样例输入 #2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B%E8%BE%93%E5%87%BA-2"><span class="toc-text">样例输出 #2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%90%E7%A4%BA-1"><span class="toc-text">提示</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#day-10-23"><span class="toc-text">day 10&#x2F;23</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B1%82%E7%9F%A9%E9%98%B5%E5%8C%85%E5%90%AB%E6%AD%A3%E6%96%B9%E5%BD%A2%E5%92%8C%E9%95%BF%E6%96%B9%E5%BD%A2%E4%B8%AA%E6%95%B0%EF%BC%88%E9%80%92%E5%BD%92%EF%BC%89"><span class="toc-text">求矩阵包含正方形和长方形个数（递归）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%A7%8D%E7%AE%97%E6%B3%95%EF%BC%9A"><span class="toc-text">第二种算法：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9A%B4%E5%8A%9B%E6%9E%9A%E4%B8%BE%E2%80%94for%E5%BE%AA%E7%8E%AF%E7%9A%84%E9%AD%85%E5%8A%9B"><span class="toc-text">暴力枚举—for循环的魅力</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dfs%E2%80%94-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9E%E6%BA%AF%EF%BC%89"><span class="toc-text">dfs—-深度优先算法（回溯）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%93%E8%BF%9B%E5%85%A5%E4%B8%80%E4%B8%AA%E9%80%92%E5%BD%92%E5%AE%8C%E8%BF%94%E5%9B%9E%E6%97%B6%E8%AE%B0%E5%BE%97%E6%8A%8A%E5%8F%98%E9%87%8F%E8%B5%8B%E5%88%9D%E5%80%BC%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81"><span class="toc-text">当进入一个递归完返回时记得把变量赋初值！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E%E5%85%B6%E7%9B%B8%E8%BF%91%E7%9A%84%E6%A8%A1%E6%9D%BF%EF%BC%8C%E9%80%92%E5%BD%92%EF%BC%88%E6%AF%94%E4%B8%8A%E9%9D%A2%E5%A4%9A%E4%BC%A0%E4%B8%80%E4%B8%AA%E5%8F%82%E6%95%B0%EF%BC%89"><span class="toc-text">与其相近的模板，递归（比上面多传一个参数）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%82%E5%9B%9E%E6%96%87%E6%95%B0dfs%E7%AE%97%E6%B3%95%EF%BC%88%E8%87%AA%E5%B7%B1%E8%8A%B1%E4%B8%A4%E4%B8%AA%E5%B0%8F%E6%97%B6%E5%86%99%E7%9A%84%E5%86%99%E7%9A%84-%E6%AD%AA%E9%97%A8%E9%82%AA%E9%81%93%EF%BC%89"><span class="toc-text">求回文数dfs算法（自己花两个小时写的写的,歪门邪道）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#day-10-26"><span class="toc-text">day 10&#x2F;26</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E2%80%94-%E5%B7%A6%E5%8F%B3%E8%84%91%EF%BC%8C"><span class="toc-text">01背包问题—-左右脑，</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dfs%E7%AE%97%E6%B3%95%E5%8F%A6%E4%B8%80%E7%A7%8D%E5%86%99%E6%B3%95-%E8%B7%9F%E5%B7%A6%E5%8F%B3%E8%84%91%E7%9B%B8%E4%BC%BC"><span class="toc-text">dfs算法另一种写法,跟左右脑相似</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#day10-27"><span class="toc-text">day10&#x2F;27</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%90%E6%B3%A2%E6%8B%89%E5%A5%91%E6%95%B0%E5%88%97-%E9%AB%98%E7%B2%BE%E5%BA%A6%E6%B1%82%E6%B3%95-%E8%8C%83%E5%9B%B4%E8%BE%83%E5%A4%A7%E6%97%B6"><span class="toc-text">斐波拉契数列+高精度求法(范围较大时)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%87%E6%B2%B3%E5%8D%92%EF%BC%81%EF%BC%81%EF%BC%81%E6%9C%AC%E8%B4%A8%E4%B8%BA%E9%80%92%E5%BD%92%EF%BC%8C%E6%A2%A6%E5%BC%80%E5%A7%8B%E7%9A%84%E5%9C%B0%E6%96%B9"><span class="toc-text">过河卒！！！本质为递归，梦开始的地方</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E8%B7%AF%EF%BC%9A%E8%AE%A9%E5%AE%83%E7%9A%84%E4%B8%8A%E9%9D%A2%E4%B8%80%E4%B8%AA%E7%82%B9%E5%92%8C%E5%B7%A6%E9%9D%A2%E7%9A%84%E4%B8%80%E4%B8%AA%E7%82%B9%E5%8A%A0%E5%92%8C%EF%BC%8C%E5%9B%A0%E4%B8%BA%E5%8F%AA%E8%83%BD%E4%BB%8E%E8%BF%99%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%90%91%E5%88%B0%E8%BE%BE%E8%BF%99%E4%B8%AA%E7%82%B9%E3%80%82%E4%B8%8E%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E6%80%9D%E8%B7%AF%E4%B8%80%E6%A0%B7"><span class="toc-text">核心思路：让它的上面一个点和左面的一个点加和，因为只能从这两种方向到达这个点。与斐波那契数列思路一样</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0%E2%80%94-%E9%80%92%E5%BD%92%E4%B8%8E%E6%A0%88"><span class="toc-text">卡特兰数—-递归与栈</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#day10-28"><span class="toc-text">day10&#x2F;28</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%B0%E5%BF%86%E5%8C%96"><span class="toc-text">记忆化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dfs%E8%B6%85%E6%97%B6%E5%90%8E%E7%9A%84%E6%96%B0%E6%80%9D%E8%B7%AF%E2%80%94-01%E8%83%8C%E5%8C%85%EF%BC%88%E5%AF%B9%E4%BA%8E%E6%AF%8F%E4%B8%80%E7%A7%8D%E7%89%A9%E5%93%81%EF%BC%8C%E5%8F%AA%E6%9C%89%E9%80%89%E4%B8%AD%E4%B8%8E%E6%9C%AA%E9%80%89%E4%B8%AD%E4%B8%A4%E7%A7%8D%E7%8A%B6%E6%80%81%EF%BC%89%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81"><span class="toc-text">dfs超时后的新思路—-01背包（对于每一种物品，只有选中与未选中两种状态）！！！！！</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%93%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4%E8%BF%87%E5%A4%A7%E6%88%96%E9%95%BF%E5%BA%A6%E8%B6%85%E8%BF%87%E9%99%90%E5%88%B6%E6%97%B6%EF%BC%8C%E5%B0%B1%E4%B8%8D%E8%A6%81%E7%94%A8%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3%E4%BA%86%EF%BC%8C%E8%AE%B0%E5%BE%97%E6%89%BE%E8%A7%84%E5%BE%8B%EF%BC%81%E6%AF%94%E5%A6%82%E5%B0%86%E7%AC%AC%E4%B8%80%E4%B8%AA%E8%B7%9F%E7%AC%AC%E4%BA%8C%E6%AF%94%EF%BC%8C%E5%86%8D%E6%8A%8A%E7%AC%AC%E4%B8%80%E8%B7%9F%E7%AC%AC%E4%B8%89%E6%AF%94"><span class="toc-text">当数据范围过大或长度超过限制时，就不要用暴力破解了，记得找规律！比如将第一个跟第二比，再把第一跟第三比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E5%AF%B9%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5%E7%9A%84%E5%88%A4%E6%96%AD%EF%BC%8C%E6%AF%94%E5%A6%82%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%9C%80%E5%90%8E%E4%B8%80%E9%A1%B9%E6%B2%A1%E6%9C%89%E5%8A%A0%E5%8F%B7"><span class="toc-text">注意对特殊情况的判断，比如多项式最后一项没有加号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%93%E9%80%92%E5%BD%92%E9%A2%98%E6%B6%89%E5%8F%8A%E5%88%B0%E4%B8%A4%E7%A7%8D%E4%B8%8D%E5%90%8C%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%88%E6%AF%94%E5%A6%82%E4%B8%A4%E7%A7%8D%E9%95%BF%E5%BA%A6%E4%B8%8D%E5%90%8C%E7%9A%84%E7%A0%96%E5%9D%97%EF%BC%89%EF%BC%8C%E8%A6%81%E5%AF%B9%E8%BF%99%E4%B8%A4%E7%A7%8D%E6%83%85%E5%86%B5%E5%88%86%E5%88%AB%E8%AE%A8%E8%AE%BA%EF%BC%8C%E6%9C%80%E5%A5%BD%E5%BB%BA%E7%AB%8B%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%EF%BC%8C%E7%84%B6%E5%90%8E%E6%9C%80%E5%A5%BD%E4%BB%8E%E6%9C%80%E5%90%8E%E7%AE%97%E8%B5%B7%EF%BC%8C%E7%9C%8B%E4%BB%96%E8%B7%9F%E4%BB%96%E7%9A%84%E4%B8%8A%E4%B8%80%E4%B8%AA%E6%9C%89%E6%B2%A1%E6%9C%89%E4%BB%80%E4%B9%88%E8%A7%84%E5%BE%8B%E5%8F%AF%E6%89%BE%EF%BC%8C%E5%8D%B3%E7%B1%BB%E4%BC%BCf-n-f-n-1-f-n-2-%E7%9A%84"><span class="toc-text">当递归题涉及到两种不同的情况（比如两种长度不同的砖块），要对这两种情况分别讨论，最好建立两个数组，然后最好从最后算起，看他跟他的上一个有没有什么规律可找，即类似f(n)&#x3D;f(n-1)+f(n+2)的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%93%E9%A2%98%E7%9B%AE%E6%B6%89%E5%8F%8A%E7%9A%84%E8%8C%83%E5%9B%B4%E6%AF%94%E8%BE%83%E5%A4%A7%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E6%AF%94%E5%A6%82100-100%EF%BC%8C%E8%A6%81%E5%85%88%E6%8B%86%E5%88%86%E6%88%90%E4%B8%80%E4%B8%AA%E4%B8%80%E4%B8%AA%E7%9A%84%E5%B0%8F%E5%8D%95%E4%BD%8D%EF%BC%8C%E5%AF%BB%E6%89%BE%E6%9C%89%E6%97%A0%E8%A7%84%E5%BE%8B%E5%8F%AF%E5%BE%AA%EF%BC%8C%E7%94%B1%E5%B1%80%E9%83%A8%E6%8E%A8%E6%95%B4%E4%BD%93"><span class="toc-text">当题目涉及的范围比较大的时候，比如100*100，要先拆分成一个一个的小单位，寻找有无规律可循，由局部推整体</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%93%E5%89%8D%E9%9D%A2%E9%83%BD%E6%9C%89%E8%A7%84%E5%BE%8B%E5%8F%AF%E5%BE%AA%EF%BC%8C%E8%80%8C%E5%88%B0%E6%9C%80%E5%90%8E%E5%8D%B4%E6%B2%A1%E6%9C%89%E8%A7%84%E5%BE%8B%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E4%B8%8D%E5%A6%A8%E8%AF%95%E8%AF%95%E5%AF%B9%E6%9C%80%E5%90%8E%E5%87%A0%E8%A1%8C%E6%89%93%E8%A1%A8%EF%BC%88%EF%BC%89"><span class="toc-text">当前面都有规律可循，而到最后却没有规律的时候，不妨试试对最后几行打表（）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#day10-30"><span class="toc-text">day10-30</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9A%B4%E5%8A%9B%E7%AE%97%E6%B3%95%E2%80%94-%E7%BB%93%E6%9E%84%E4%BD%93%E6%8E%92%E5%BA%8F"><span class="toc-text">暴力算法—-结构体排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%AE%B5%E8%A6%86%E7%9B%96%E2%80%94-%E7%BB%93%E6%9E%84%E4%BD%93%E6%8E%92%E5%BA%8F"><span class="toc-text">线段覆盖—-结构体排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A6%96%E4%BD%8D%E7%9B%B8%E8%BF%9E%E5%8C%BA%E5%9F%9F-%E8%8B%A5%E4%B8%AD%E9%97%B4%E4%B8%AD%E6%96%AD%E5%88%99%E4%BB%8E%E5%B7%A6%E8%87%B3%E5%8F%B3"><span class="toc-text">首位相连区域,若中间中断则从左至右</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9A%B4%E5%8A%9B%E7%AE%97%E6%B3%95%E4%B8%AD%E7%9A%84%E5%8F%8C%E6%8C%87%E9%92%88%E9%97%AE%E9%A2%98"><span class="toc-text">暴力算法中的双指针问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%8E%92%E5%BA%8F%E5%92%8Csort%E6%8E%92%E5%BA%8F%E7%9A%84%E7%AE%80%E5%8C%96%EF%BC%88%E5%BD%93%E8%B6%85%E5%87%BA%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%97%B6%EF%BC%89"><span class="toc-text">二叉树的排序和sort排序的简化（当超出时间复杂度时）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#day11-2"><span class="toc-text">day11-2</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E5%81%9A%E6%9C%89%E5%85%B3%E4%BA%8E%E6%95%B0%E5%AD%97%E7%B1%BB%E7%9A%84%E9%A2%98%E7%9B%AE%E6%97%B6%EF%BC%8C%E8%80%83%E8%99%910%E8%BF%99%E7%A7%8D%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5%EF%BC%81"><span class="toc-text">在做有关于数字类的题目时，考虑0这种特殊情况！</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E7%BB%93%E6%9E%84%E4%BD%93%E6%95%B0%E7%BB%84%E6%97%B6%E4%B8%8D%E8%A6%81%E5%8A%A0typedef%EF%BC%81%EF%BC%81%EF%BC%81"><span class="toc-text">定义结构体数组时不要加typedef！！！</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%9C%98%E8%9B%9B%E7%BA%B8%E7%89%8C%E7%B1%BB%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98%E5%86%99%E6%B3%95"><span class="toc-text">蜘蛛纸牌类排序问题写法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#day11-3"><span class="toc-text">day11-3</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-text">二分查找</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lower-bound%E5%92%8Cupper-bound%E7%9A%84%E5%A6%99%E7%94%A8"><span class="toc-text">lower_bound和upper_bound的妙用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%86%99%E6%B3%95%EF%BC%88%E6%98%A0%E5%B0%84%EF%BC%89"><span class="toc-text">原写法（映射）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A0%8D%E6%A0%91%EF%BC%8C%E6%B1%82%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E5%80%BC%E4%B8%AD%E7%9A%84%E4%BA%8C%E5%88%86"><span class="toc-text">砍树，求长度最小值中的二分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E4%BA%8C%E5%88%86%E6%B3%95%E6%B1%82%E6%96%B9%E7%A8%8B%E7%BB%84%E4%B8%BA0%E7%9A%84%E8%A7%A3"><span class="toc-text">用二分法求方程组为0的解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lower-bound-%E8%BF%94%E5%9B%9E%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E%E7%9A%84%E5%80%BC%E7%9A%84%E4%B8%8B%E6%A0%87%EF%BC%89%E7%94%A8%E6%B3%95%E5%B7%A9%E5%9B%BA%EF%BC%8C%E6%B3%A8%E6%84%8F%E5%85%A8%E9%83%A8%E5%A4%A7%E4%BA%8E%E5%92%8C%E5%85%A8%E9%83%A8%E5%B0%8F%E4%BA%8E%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-text">lower_bound(返回第一个大于等于的值的下标）用法巩固，注意全部大于和全部小于的情况</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#day11-8"><span class="toc-text">day11-8</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%B3%95%EF%BC%8C%E5%B0%9D%E8%AF%95%E5%8F%AF%E8%83%BD%E7%9A%84%E6%89%80%E6%9C%89%E7%BB%93%E6%9E%9C"><span class="toc-text">二分法，尝试可能的所有结果</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E9%81%93%E7%B1%BB%E4%BC%BC%E7%9A%84%E9%A2%98"><span class="toc-text">第二道类似的题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%B6%E8%A1%8C%E8%B4%B7%E6%AC%BE%E5%88%A9%E6%81%AF%E9%97%AE%E9%A2%98"><span class="toc-text">银行贷款利息问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#day11-9"><span class="toc-text">day11-9</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E5%8A%A0%E6%90%9C%E7%B4%A2"><span class="toc-text">递归加搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2%E7%9A%84%E5%86%99%E6%B3%95%E4%B8%80%E8%88%AC%E9%83%BD%E6%98%AF%E6%9C%89%E5%A5%BD%E5%87%A0%E4%B8%AA%E6%95%B0%E7%BB%84%EF%BC%8C%E6%AF%8F%E4%B8%AA%E6%95%B0%E7%BB%84%E5%AF%B9%E5%BA%94%E4%B8%80%E7%A7%8D%E6%83%85%E5%86%B5%EF%BC%8C%E7%84%B6%E5%90%8E%E9%80%9A%E5%B8%B8%E4%BC%9A%E4%B8%8E%E9%80%92%E5%BD%92%E7%9B%B8%E7%BB%93%E5%90%88%E8%B5%B7%E6%9D%A5"><span class="toc-text">搜索的写法一般都是有好几个数组，每个数组对应一种情况，然后通常会与递归相结合起来</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%93%E6%9C%89%E4%B8%A4%E4%B8%AA%E7%BB%84%E5%88%AB%E6%B1%82%E6%9C%80%E5%A4%A7%E5%80%BC%E6%97%B6%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%85%88%E6%B1%82%E4%B8%80%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%EF%BC%8C%E7%84%B6%E5%90%8E%E8%AE%A9%E4%BB%96%E6%85%A2%E6%85%A2%E5%87%8F%EF%BC%8C%E6%AF%8F%E5%87%8F%E4%B8%80%E6%AC%A1%E6%B1%82%E4%B8%80%E4%B8%8B%E5%BD%93%E5%89%8D%E7%9A%84%E7%BB%93%E6%9E%9C%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%A4%A7%E4%BA%86%E5%B0%B1%E6%9B%B4%E6%96%B0%E3%80%81%E6%9C%80%E5%90%8E%E7%9B%B4%E6%8E%A5%E8%BE%93%E5%87%BA%E6%9C%80%E5%A4%A7%E5%80%BC%E5%8D%B3%E5%8F%AF"><span class="toc-text">当有两个组别求最大值时，可以先求一组的最大值，然后让他慢慢减，每减一次求一下当前的结果，如果大了就更新、最后直接输出最大值即可</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#day11-10"><span class="toc-text">day11-10</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-text">并查集</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-color: transparent;"><div id="footer-wrap"><div id="ft"><div class="ft-item-1"><div class="t-top"><div class="t-t-l"><p class="ft-t t-l-t">格言🧬</p><div class="bg-ad"><div>再看看那个光点，它就在这里，这是家园，这是我们 —— 你所爱的每一个人，你认识的一个人，你听说过的每一个人，曾经有过的每一个人，都在它上面度过他们的一生✨</div><div class="btn-xz-box"><a class="btn-xz" target="_blank" rel="noopener" href="https://stellarium.org/">点击开启星辰之旅</a></div></div></div><div class="t-t-r"><p class="ft-t t-l-t">猜你想看💡</p><ul class="ft-links"><li><a href="/posts/eec9786.html">魔改指南</a><a href="/box/nav/">网址导航</a></li><li><a href="/social/link/">我的朋友</a><a href="/comments/">留点什么</a></li><li><a href="/personal/about/">关于作者</a><a href="/archives/">文章归档</a></li><li><a href="/categories/">文章分类</a><a href="/tags/">文章标签</a></li><li><a href="/box/Gallery/">我的画廊</a><a href="/personal/bb/">我的唠叨</a></li><li><a href="/site/time/">建设进程</a><a href="/site/census/">网站统计</a></li></ul></div></div></div><div class="ft-item-2"><p class="ft-t">推荐友链⌛</p><div class="ft-img-group"><div class="img-group-item"><a target="_blank" rel="noopener" href="https://www.fomal.cc/" title="Fomalhaut🥝"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fsafe-img.xhscdn.com%2Fbw1%2F5680794c-f7f8-4b02-8778-f893746d50e5%3FimageView2%2F2%2Fw%2F1080%2Fformat%2Fjpg&amp;refer=http%3A%2F%2Fsafe-img.xhscdn.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1689256065&amp;t=158a3f4d7f8445a7830db3e3d0c9855d" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fsafe-img.xhscdn.com%2Fbw1%2Fba23f9d6-a343-4775-a4ba-6a75a1d1534a%3FimageView2%2F2%2Fw%2F1080%2Fformat%2Fjpg&amp;refer=http%3A%2F%2Fsafe-img.xhscdn.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1689256065&amp;t=94cbb7420fdb3fde6174422c4f9ce088" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://inews.gtimg.com/newsapp_bt/0/13613201613/1000" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic1.zhimg.com/v2-ca8c833cf905207881c55be1f8f3d5ec_r.jpg" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fc-ssl.duitang.com%2Fuploads%2Fitem%2F201909%2F11%2F20190911194436_mzunv.thumb.1000_0.jpg&amp;refer=http%3A%2F%2Fc-ssl.duitang.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1689256273&amp;t=df44fbf97e12f5b8d63a3280de154e87" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fc-ssl.duitang.com%2Fuploads%2Fblog%2F202104%2F28%2F20210428162418_ac936.thumb.1000_0.jpg&amp;refer=http%3A%2F%2Fc-ssl.duitang.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1689256486&amp;t=677806a056194cc8089e0a675d7a0359" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img2.baidu.com/it/u=4014948925,1148047137&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=501&amp;h=500" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fc-ssl.duitang.com%2Fuploads%2Fitem%2F202004%2F27%2F20200427065657_nojeh.thumb.1000_0.jpg&amp;refer=http%3A%2F%2Fc-ssl.duitang.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1689256098&amp;t=b75f07f327788990c4b90868abdac671" alt=""/></a></div></div></div></div><div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" title="博客框架为Hexo_v6.3.0"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Frame-Hexo-blue.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" title="主题版本Butterfly_v4.3.1"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Theme-Butterfly-6513df.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://vercel.com/" style="margin-inline:5px" title="本站采用多线部署，主线路托管于Vercel"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Hosted-Vercel-brightgreen.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://user.51.la/" style="margin-inline:5px" title="本站数据分析得益于51la技术支持"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Analytics-51la-3db1eb.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://icp.gov.moe/?keyword=20226665" style="margin-inline:5px" title="本站已加入萌ICP豪华套餐，萌ICP备20226665号"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/萌ICP备-20226665-fe1384.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://bitiful.dogecast.com/buckets" style="margin-inline:5px" title="本网站经Service Worker分流至缤纷云对象存储"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src=" https://sourcebucket.s3.ladydaily.com/badge/Bucket-缤纷云-9c62da.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://www.netdun.net/" style="margin-inline:5px" title="本站使用网盾星球提供CDN加速与防护"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/CDN-网盾星球-fff2cc.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" title="本网站源码由Github提供存储仓库"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src=" https://sourcebucket.s3.ladydaily.com/badge/Source-Github-d021d6.svg" alt=""/></a></p></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><a class="icon-V hidden" onclick="switchNightMode()" title="浅色和深色模式转换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button><button class="share" type="button" title="右键模式" onclick="changeMouseMode()"><i class="fas fa-mouse"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog right_side"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button class="share" type="button" title="分享链接" onclick="share()"><i class="fas fa-share-nodes"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i><span id="percent">0<span>%</span></span></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight, 500)"><i class="fas fa-arrow-down"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div class="js-pjax" id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();"><i class="fa fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();"><i class="fa fa-arrow-right"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();"><i class="fa fa-refresh"></i></a><a class="rightMenu-item" href="javascript:rmf.scrollToTop();"><i class="fa fa-arrow-up"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();"><i class="fa fa-copy"></i><span>复制</span></a><a class="rightMenu-item" href="javascript:window.open(&quot;https://www.baidu.com/s?wd=&quot;+window.getSelection().toString());window.location.reload();"><i class="fa fa-search"></i><span>百度搜索</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-too"><a class="rightMenu-item" href="javascript:window.open(window.getSelection().toString());window.location.reload();"><i class="fa fa-link"></i><span>转到链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-paste"><a class="rightMenu-item" href="javascript:rmf.paste()"><i class="fa fa-copy"></i><span>粘贴</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-post"><a class="rightMenu-item" href="#post-comment"><i class="fas fa-comment"></i><span>空降评论</span></a><a class="rightMenu-item" href="javascript:rmf.copyWordsLink()"><i class="fa fa-link"></i><span>复制本文地址</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-to"><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>新窗口打开</span></a><a class="rightMenu-item" id="menu-too" href="javascript:rmf.open()"><i class="fa fa-link"></i><span>转到链接</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-img"><a class="rightMenu-item" href="javascript:rmf.saveAs()"><i class="fa fa-download"></i><span>保存图片</span></a><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>在新窗口打开</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制图片链接</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:randomPost()"><i class="fa fa-paper-plane"></i><span>随便逛逛</span></a><a class="rightMenu-item" href="javascript:switchNightMode();"><i class="fa fa-moon"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="javascript:rmf.switchReadMode();"><i class="fa fa-book"></i><span>阅读模式</span></a><a class="rightMenu-item" href="/personal/about/"><i class="fa fa-info-circle"></i><span>关于博客</span></a><a class="rightMenu-item" href="javascript:toggleWinbox();"><i class="fas fa-cog"></i><span>美化设置</span></a><a class="rightMenu-item" href="javascript:rmf.fullScreen();"><i class="fas fa-expand"></i><span>切换全屏</span></a><a class="rightMenu-item" href="javascript:window.print();"><i class="fa-solid fa-print"></i><span>打印页面</span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.staticfile.org/fancyapps-ui/4.0.31/fancybox.umd.min.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/instant.page/5.1.0/instantpage.min.js" type="module"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/vanilla-lazyload/17.3.1/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><script async="async">var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())
setTimeout(function(){preloader.endLoading();}, 5000);
document.getElementById('loading-box').addEventListener('click',()=> {preloader.endLoading()})</script><div class="js-pjax"><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: '',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: '',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.staticfile.org/twikoo/1.6.8/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script src="https://cdn.staticfile.org/jquery/3.6.3/jquery.min.js"></script><script async src="https://cdn1.tianli0.top/npm/vue@2.6.14/dist/vue.min.js"></script><script async src="https://cdn1.tianli0.top/npm/element-ui@2.15.6/lib/index.js"></script><script async src="https://cdn.bootcdn.net/ajax/libs/clipboard.js/2.0.11/clipboard.min.js"></script><script defer type="text/javascript" src="https://cdn1.tianli0.top/npm/sweetalert2@8.19.0/dist/sweetalert2.all.js"></script><script async src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><script defer src="https://cdn1.tianli0.top/gh/nextapps-de/winbox/dist/winbox.bundle.min.js"></script><script async src="//at.alicdn.com/t/c/font_3586335_hsivh70x0fm.js"></script><script async src="//at.alicdn.com/t/c/font_3636804_gr02jmjr3y9.js"></script><script async src="//at.alicdn.com/t/c/font_3612150_kfv55xn3u2g.js"></script><script async src="https://cdn.wpon.cn/2022-sucai/Gold-ingot.js"></script><canvas id="universe"></canvas><canvas id="snow"></canvas><script defer src="/js/fomal.js"></script><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.js"></script><script src="https://cdn1.tianli0.top/npm/js-heo@1.0.12/metingjs/Meting.min.js"></script><script src="https://lib.baomitu.com/pjax/0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show","#web_bg",".js-pjax","#bibi","body > title","#app","#tag-echarts","#posts-echart","#categories-echarts"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="https://godwad.github.io/categories/算法/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍡 小sの算法学习笔记 (2)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://godwad.github.io/categories/软件/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍉 小sの软件使用教程 (2)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://godwad.github.io/categories/数据库/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍨 小sの数据库笔记 (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://godwad.github.io/categories/演示/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍥 小sの案例演示笔记 (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item" style="visibility: hidden"></div><div class="magnet_item" style="visibility: hidden"></div><a class="magnet_link_more"  href="https://godwad.github.io/categories/" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(33.333333333333336% - 5px);background: #e9e9e9;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: var(--text-bg-hover)}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/26494.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.horosama.com/api/image_all/anime/1080p/pc/D5bB596d66E33614A6406961348740cE.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-01-16</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/26494.html&quot;);" href="javascript:void(0);" alt="">从零开始学手游外挂</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/26494.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/4d7662.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://w.wallhaven.cc/full/ex/wallhaven-exejgw.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-06-14</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/4d7662.html&quot;);" href="javascript:void(0);" alt="">客制化键盘</a><div class="blog-slider__text">人生中的第一个DIY产品</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/4d7662.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/2d57d79b.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://w.wallhaven.cc/full/3l/wallhaven-3l5d36.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-06-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/2d57d79b.html&quot;);" href="javascript:void(0);" alt="">MYSQL数据库</a><div class="blog-slider__text">懂的都懂</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/2d57d79b.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/54150.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://w.wallhaven.cc/full/x6/wallhaven-x6jvdl.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-03-23</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/54150.html&quot;);" href="javascript:void(0);" alt="">算法合集</a><div class="blog-slider__text">🥧内含多达70种算法，后续会补充案例</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/54150.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/62324.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://imgo.68h5.com/6h/img2020/6/8/20/2020060806585602.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-02-15</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/62324.html&quot;);" href="javascript:void(0);" alt="">c语言项目</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/62324.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/3895.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.horosama.com/api/image_all/anime/1080p/pc/DD1dec9A0198314383c5f6F5D7Cc6676.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-02-06</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/3895.html&quot;);" href="javascript:void(0);" alt="">从零开始的blender教程</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/3895.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/41926.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.horosama.com/api/image_all/anime/1080p/pc/FE485Fed50273154B8253b02099BAC95.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-02-14</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/41926.html&quot;);" href="javascript:void(0);" alt="">windows命令行与批处理基础</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/41926.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/22062.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.horosama.com/api/image_all/anime/1080p/pc/822dBF1363523c8a8dbeF0f91db71Ae0.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-08-03</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/22062.html&quot;);" href="javascript:void(0);" alt="">6 款贼好用的油猴脚本</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/22062.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/23040.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.horosama.com/api/image_all/anime/1080p/pc/647553239ED3397e91eee03609Bba112.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-08-03</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/23040.html&quot;);" href="javascript:void(0);" alt="">基于 PotPlayer 和 madVR 的播放器的设置教程和方法</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/23040.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/24281.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.horosama.com/api/image_all/anime/1080p/pc/4297De6e630538DF9D1327F0e02F08c7.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-01-12</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/24281.html&quot;);" href="javascript:void(0);" alt="">自制云游戏服务器!月光Moonlight使用教程,使用串流技术将电脑游戏搬运到手机上游玩!(带外网无卡顿串流技术)</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/24281.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/2928.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://file.dujin.org/image/yuanshen/466f79e8ly1gzoedikysuj21tm1ioqit.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-01-09</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/2928.html&quot;);" href="javascript:void(0);" alt="">alist+raildrive+emby打造家庭影院</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/2928.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/65105.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://w.wallhaven.cc/full/7p/wallhaven-7ppp33.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-01-10</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/65105.html&quot;);" href="javascript:void(0);" alt="">ChatGPT</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/65105.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/34592.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://file.dujin.org/image/yuanshen/466f79e8ly1gzoecifvvuj21xc1llh70.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-01-11</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/34592.html&quot;);" href="javascript:void(0);" alt="">游戏playnite</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/34592.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/28254.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wallpapercave.com/wp/wp11267290.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-01-10</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/28254.html&quot;);" href="javascript:void(0);" alt="">关于视频码率的一些问题</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/28254.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/35796.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.horosama.com/api/image_all/anime/1080p/pc/C6c96684a65C3fB7afE02F20e2A6ff97.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-12-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/35796.html&quot;);" href="javascript:void(0);" alt="">节点搭建系列</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/35796.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/2013454d.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-08-09</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/2013454d.html&quot;);" href="javascript:void(0);" alt="">Markdown语法与外挂标签写法汇总</a><div class="blog-slider__text">🥧本文汇总Markdown格式以及外挂标签在网页端的渲染效果，可作为文档进行查询</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/2013454d.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><script data-pjax src="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.js"></script><script data-pjax>
  function gitcalendar_injector_config(){
      var parent_div_git = document.getElementById('gitZone');
      var item_html = '<div class="recent-post-item" id="gitcalendarBar" style="width:100%;height:auto;padding:10px;"><style>#git_container{min-height: 320px}@media screen and (max-width:650px) {#git_container{min-height: 0px}}</style><div id="git_loading" style="width:10%;height:100%;margin:0 auto;display: block;"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animatetransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animatetransform></path></svg><style>#git_container{display: none;}</style></div><div id="git_container"></div></div>';
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      console.log('已挂载gitcalendar')
      }

    if( document.getElementById('gitZone') && (location.pathname ==='/site/census/'|| '/site/census/' ==='all')){
        gitcalendar_injector_config()
        GitCalendarInit("/api?null",['#d9e0df', '#c6e0dc', '#a8dcd4', '#9adcd2', '#89ded1', '#77e0d0', '#5fdecb', '#47dcc6', '#39dcc3', '#1fdabe', '#00dab9'],'null')
    }
  </script><!-- hexo injector body_end end --></body></html>